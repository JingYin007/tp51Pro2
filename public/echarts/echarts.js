!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.echarts = {})
}(this, function (t) {
    "use strict";

    function e(t) {
        var e = {}, i = {}, n = t.match(/Firefox\/([\d.]+)/),
            o = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/), a = t.match(/Edge\/([\d.]+)/),
            r = /micromessenger/i.test(t);
        return n && (i.firefox = !0, i.version = n[1]), o && (i.ie = !0, i.version = o[1]), a && (i.edge = !0, i.version = a[1]), r && (i.weChat = !0), {
            browser: i,
            os: e,
            node: !1,
            canvasSupported: !!document.createElement("canvas").getContext,
            svgSupported: "undefined" != typeof SVGRect,
            touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge,
            pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 11),
            domSupported: "undefined" != typeof document
        }
    }

    function i(t, e) {
        "createCanvas" === t && (tM = null), JS[t] = e
    }

    function n(t) {
        if (null == t || "object" != typeof t) return t;
        var e = t, i = US.call(t);
        if ("[object Array]" === i) {
            if (!R(t)) {
                e = [];
                for (var o = 0, a = t.length; a > o; o++) e[o] = n(t[o])
            }
        } else if (ZS[i]) {
            if (!R(t)) {
                var r = t.constructor;
                if (t.constructor.from) e = r.from(t); else {
                    e = new r(t.length);
                    for (var o = 0, a = t.length; a > o; o++) e[o] = n(t[o])
                }
            }
        } else if (!HS[i] && !R(t) && !T(t)) {
            e = {};
            for (var s in t) t.hasOwnProperty(s) && (e[s] = n(t[s]))
        }
        return e
    }

    function o(t, e, i) {
        if (!S(e) || !S(t)) return i ? n(e) : t;
        for (var a in e) if (e.hasOwnProperty(a)) {
            var r = t[a], s = e[a];
            !S(s) || !S(r) || _(s) || _(r) || T(s) || T(r) || M(s) || M(r) || R(s) || R(r) ? !i && a in t || (t[a] = n(e[a], !0)) : o(r, s, i)
        }
        return t
    }

    function a(t, e) {
        for (var i = t[0], n = 1, a = t.length; a > n; n++) i = o(i, t[n], e);
        return i
    }

    function r(t, e) {
        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
        return t
    }

    function s(t, e, i) {
        for (var n in e) e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
        return t
    }

    function l() {
        return tM || (tM = QS().getContext("2d")), tM
    }

    function u(t, e) {
        if (t) {
            if (t.indexOf) return t.indexOf(e);
            for (var i = 0, n = t.length; n > i; i++) if (t[i] === e) return i
        }
        return -1
    }

    function h(t, e) {
        function i() {
        }

        var n = t.prototype;
        i.prototype = e.prototype, t.prototype = new i;
        for (var o in n) n.hasOwnProperty(o) && (t.prototype[o] = n[o]);
        t.prototype.constructor = t, t.superClass = e
    }

    function c(t, e, i) {
        t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, s(t, e, i)
    }

    function d(t) {
        return t ? "string" == typeof t ? !1 : "number" == typeof t.length : void 0
    }

    function f(t, e, i) {
        if (t && e) if (t.forEach && t.forEach === YS) t.forEach(e, i); else if (t.length === +t.length) for (var n = 0, o = t.length; o > n; n++) e.call(i, t[n], n, t); else for (var a in t) t.hasOwnProperty(a) && e.call(i, t[a], a, t)
    }

    function p(t, e, i) {
        if (t && e) {
            if (t.map && t.map === KS) return t.map(e, i);
            for (var n = [], o = 0, a = t.length; a > o; o++) n.push(e.call(i, t[o], o, t));
            return n
        }
    }

    function g(t, e, i, n) {
        if (t && e) {
            if (t.reduce && t.reduce === $S) return t.reduce(e, i, n);
            for (var o = 0, a = t.length; a > o; o++) i = e.call(n, i, t[o], o, t);
            return i
        }
    }

    function m(t, e, i) {
        if (t && e) {
            if (t.filter && t.filter === jS) return t.filter(e, i);
            for (var n = [], o = 0, a = t.length; a > o; o++) e.call(i, t[o], o, t) && n.push(t[o]);
            return n
        }
    }

    function v(t, e, i) {
        if (t && e) for (var n = 0, o = t.length; o > n; n++) if (e.call(i, t[n], n, t)) return t[n]
    }

    function y(t, e) {
        var i = qS.call(arguments, 2);
        return function () {
            return t.apply(e, i.concat(qS.call(arguments)))
        }
    }

    function x(t) {
        var e = qS.call(arguments, 1);
        return function () {
            return t.apply(this, e.concat(qS.call(arguments)))
        }
    }

    function _(t) {
        return "[object Array]" === US.call(t)
    }

    function w(t) {
        return "function" == typeof t
    }

    function b(t) {
        return "[object String]" === US.call(t)
    }

    function S(t) {
        var e = typeof t;
        return "function" === e || !!t && "object" === e
    }

    function M(t) {
        return !!HS[US.call(t)]
    }

    function I(t) {
        return !!ZS[US.call(t)]
    }

    function T(t) {
        return "object" == typeof t && "number" == typeof t.nodeType && "object" == typeof t.ownerDocument
    }

    function A(t) {
        return t !== t
    }

    function D() {
        for (var t = 0, e = arguments.length; e > t; t++) if (null != arguments[t]) return arguments[t]
    }

    function C(t, e) {
        return null != t ? t : e
    }

    function L(t, e, i) {
        return null != t ? t : null != e ? e : i
    }

    function k() {
        return Function.call.apply(qS, arguments)
    }

    function P(t) {
        if ("number" == typeof t) return [t, t, t, t];
        var e = t.length;
        return 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
    }

    function O(t, e) {
        if (!t) throw new Error(e)
    }

    function E(t) {
        return null == t ? null : "function" == typeof t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
    }

    function N(t) {
        t[eM] = !0
    }

    function R(t) {
        return t[eM]
    }

    function z(t) {
        function e(t, e) {
            i ? n.set(t, e) : n.set(e, t)
        }

        var i = _(t);
        this.data = {};
        var n = this;
        t instanceof z ? t.each(e) : t && f(t, e)
    }

    function B(t) {
        return new z(t)
    }

    function V(t, e) {
        for (var i = new t.constructor(t.length + e.length), n = 0; n < t.length; n++) i[n] = t[n];
        var o = t.length;
        for (n = 0; n < e.length; n++) i[n + o] = e[n];
        return i
    }

    function G() {
    }

    function F(t, e) {
        var i = new nM(2);
        return null == t && (t = 0), null == e && (e = 0), i[0] = t, i[1] = e, i
    }

    function W(t, e) {
        return t[0] = e[0], t[1] = e[1], t
    }

    function H(t) {
        var e = new nM(2);
        return e[0] = t[0], e[1] = t[1], e
    }

    function Z(t, e, i) {
        return t[0] = e, t[1] = i, t
    }

    function U(t, e, i) {
        return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
    }

    function X(t, e, i, n) {
        return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
    }

    function Y(t, e, i) {
        return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
    }

    function j(t) {
        return Math.sqrt(q(t))
    }

    function q(t) {
        return t[0] * t[0] + t[1] * t[1]
    }

    function K(t, e, i) {
        return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
    }

    function $(t, e, i) {
        return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
    }

    function J(t, e) {
        return t[0] * e[0] + t[1] * e[1]
    }

    function Q(t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t
    }

    function te(t, e) {
        var i = j(e);
        return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t
    }

    function ee(t, e) {
        return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
    }

    function ie(t, e) {
        return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
    }

    function ne(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t
    }

    function oe(t, e, i, n) {
        return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
    }

    function ae(t, e, i) {
        var n = e[0], o = e[1];
        return t[0] = i[0] * n + i[2] * o + i[4], t[1] = i[1] * n + i[3] * o + i[5], t
    }

    function re(t, e, i) {
        return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
    }

    function se(t, e, i) {
        return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
    }

    function le() {
        this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this)
    }

    function ue(t, e) {
        return {target: t, topTarget: e && e.topTarget}
    }

    function he(t, e) {
        var i = t._$eventProcessor;
        return null != e && i && i.normalizeQuery && (e = i.normalizeQuery(e)), e
    }

    function ce(t, e, i, n, o, a) {
        var r = t._$handlers;
        if ("function" == typeof i && (o = n, n = i, i = null), !n || !e) return t;
        i = he(t, i), r[e] || (r[e] = []);
        for (var s = 0; s < r[e].length; s++) if (r[e][s].h === n) return t;
        var l = {h: n, one: a, query: i, ctx: o || t, callAtLast: n.zrEventfulCallAtLast}, u = r[e].length - 1,
            h = r[e][u];
        return h && h.callAtLast ? r[e].splice(u, 0, l) : r[e].push(l), t
    }

    function de(t, e, i, n, o, a) {
        var r = n + "-" + o, s = t.length;
        if (a.hasOwnProperty(r)) return a[r];
        if (1 === e) {
            var l = Math.round(Math.log((1 << s) - 1 & ~o) / cM);
            return t[i][l]
        }
        for (var u = n | 1 << i, h = i + 1; n & 1 << h;) h++;
        for (var c = 0, d = 0, f = 0; s > d; d++) {
            var p = 1 << d;
            p & o || (c += (f % 2 ? -1 : 1) * t[i][d] * de(t, e - 1, h, u, o | p, a), f++)
        }
        return a[r] = c, c
    }

    function fe(t, e) {
        var i = [[t[0], t[1], 1, 0, 0, 0, -e[0] * t[0], -e[0] * t[1]], [0, 0, 0, t[0], t[1], 1, -e[1] * t[0], -e[1] * t[1]], [t[2], t[3], 1, 0, 0, 0, -e[2] * t[2], -e[2] * t[3]], [0, 0, 0, t[2], t[3], 1, -e[3] * t[2], -e[3] * t[3]], [t[4], t[5], 1, 0, 0, 0, -e[4] * t[4], -e[4] * t[5]], [0, 0, 0, t[4], t[5], 1, -e[5] * t[4], -e[5] * t[5]], [t[6], t[7], 1, 0, 0, 0, -e[6] * t[6], -e[6] * t[7]], [0, 0, 0, t[6], t[7], 1, -e[7] * t[6], -e[7] * t[7]]],
            n = {}, o = de(i, 8, 0, 0, 0, n);
        if (0 !== o) {
            for (var a = [], r = 0; 8 > r; r++) for (var s = 0; 8 > s; s++) null == a[s] && (a[s] = 0), a[s] += ((r + s) % 2 ? -1 : 1) * de(i, 7, 0 === r ? 1 : 0, 1 << r, 1 << s, n) / o * e[r];
            return function (t, e, i) {
                var n = e * a[6] + i * a[7] + 1;
                t[0] = (e * a[0] + i * a[1] + a[2]) / n, t[1] = (e * a[3] + i * a[4] + a[5]) / n
            }
        }
    }

    function pe(t, e, i, n, o) {
        return ge(fM, e, n, o, !0) && ge(t, i, fM[0], fM[1])
    }

    function ge(t, e, i, n, o) {
        if (e.getBoundingClientRect && WS.domSupported && !ye(e)) {
            var a = e[dM] || (e[dM] = {}), r = me(e, a), s = ve(r, a, o);
            if (s) return s(t, i, n), !0
        }
        return !1
    }

    function me(t, e) {
        var i = e.markers;
        if (i) return i;
        i = e.markers = [];
        for (var n = ["left", "right"], o = ["top", "bottom"], a = 0; 4 > a; a++) {
            var r = document.createElement("div"), s = r.style, l = a % 2, u = (a >> 1) % 2;
            s.cssText = ["position: absolute", "visibility: hidden", "padding: 0", "margin: 0", "border-width: 0", "user-select: none", "width:0", "height:0", n[l] + ":0", o[u] + ":0", n[1 - l] + ":auto", o[1 - u] + ":auto", ""].join("!important;"), t.appendChild(r), i.push(r)
        }
        return i
    }

    function ve(t, e, i) {
        for (var n = i ? "invTrans" : "trans", o = e[n], a = e.srcCoords, r = !0, s = [], l = [], u = 0; 4 > u; u++) {
            var h = t[u].getBoundingClientRect(), c = 2 * u, d = h.left, f = h.top;
            s.push(d, f), r = r && a && d === a[c] && f === a[c + 1], l.push(t[u].offsetLeft, t[u].offsetTop)
        }
        return r && o ? o : (e.srcCoords = s, e[n] = i ? fe(l, s) : fe(s, l))
    }

    function ye(t) {
        return "CANVAS" === t.nodeName.toUpperCase()
    }

    function xe(t, e, i, n) {
        return i = i || {}, n || !WS.canvasSupported ? _e(t, e, i) : WS.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : _e(t, e, i), i
    }

    function _e(t, e, i) {
        if (WS.domSupported && t.getBoundingClientRect) {
            var n = e.clientX, o = e.clientY;
            if (ye(t)) {
                var a = t.getBoundingClientRect();
                return i.zrX = n - a.left, void (i.zrY = o - a.top)
            }
            if (ge(mM, t, n, o)) return i.zrX = mM[0], void (i.zrY = mM[1])
        }
        i.zrX = i.zrY = 0
    }

    function we(t) {
        return t || window.event
    }

    function be(t, e, i) {
        if (e = we(e), null != e.zrX) return e;
        var n = e.type, o = n && n.indexOf("touch") >= 0;
        if (o) {
            var a = "touchend" !== n ? e.targetTouches[0] : e.changedTouches[0];
            a && xe(t, a, e, i)
        } else xe(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
        var r = e.button;
        return null == e.which && void 0 !== r && gM.test(e.type) && (e.which = 1 & r ? 1 : 2 & r ? 3 : 4 & r ? 2 : 0), e
    }

    function Se(t, e, i, n) {
        pM ? t.addEventListener(e, i, n) : t.attachEvent("on" + e, i)
    }

    function Me(t, e, i, n) {
        pM ? t.removeEventListener(e, i, n) : t.detachEvent("on" + e, i)
    }

    function Ie(t) {
        return 2 === t.which || 3 === t.which
    }

    function Te(t) {
        var e = t[1][0] - t[0][0], i = t[1][1] - t[0][1];
        return Math.sqrt(e * e + i * i)
    }

    function Ae(t) {
        return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
    }

    function De(t, e, i) {
        return {
            type: t,
            event: i,
            target: e.target,
            topTarget: e.topTarget,
            cancelBubble: !1,
            offsetX: i.zrX,
            offsetY: i.zrY,
            gestureEvent: i.gestureEvent,
            pinchX: i.pinchX,
            pinchY: i.pinchY,
            pinchScale: i.pinchScale,
            wheelDelta: i.zrDelta,
            zrByTouch: i.zrByTouch,
            which: i.which,
            stop: Ce
        }
    }

    function Ce() {
        vM(this.event)
    }

    function Le() {
    }

    function ke(t, e, i) {
        if (t[t.rectHover ? "rectContain" : "contain"](e, i)) {
            for (var n, o = t; o;) {
                if (o.clipPath && !o.clipPath.contain(e, i)) return !1;
                o.silent && (n = !0), o = o.parent
            }
            return n ? _M : !0
        }
        return !1
    }

    function Pe(t, e, i) {
        var n = t.painter;
        return 0 > e || e > n.getWidth() || 0 > i || i > n.getHeight()
    }

    function Oe() {
        var t = new SM(6);
        return Ee(t), t
    }

    function Ee(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
    }

    function Ne(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
    }

    function Re(t, e, i) {
        var n = e[0] * i[0] + e[2] * i[1], o = e[1] * i[0] + e[3] * i[1], a = e[0] * i[2] + e[2] * i[3],
            r = e[1] * i[2] + e[3] * i[3], s = e[0] * i[4] + e[2] * i[5] + e[4], l = e[1] * i[4] + e[3] * i[5] + e[5];
        return t[0] = n, t[1] = o, t[2] = a, t[3] = r, t[4] = s, t[5] = l, t
    }

    function ze(t, e, i) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
    }

    function Be(t, e, i) {
        var n = e[0], o = e[2], a = e[4], r = e[1], s = e[3], l = e[5], u = Math.sin(i), h = Math.cos(i);
        return t[0] = n * h + r * u, t[1] = -n * u + r * h, t[2] = o * h + s * u, t[3] = -o * u + h * s, t[4] = h * a + u * l, t[5] = h * l - u * a, t
    }

    function Ve(t, e, i) {
        var n = i[0], o = i[1];
        return t[0] = e[0] * n, t[1] = e[1] * o, t[2] = e[2] * n, t[3] = e[3] * o, t[4] = e[4] * n, t[5] = e[5] * o, t
    }

    function Ge(t, e) {
        var i = e[0], n = e[2], o = e[4], a = e[1], r = e[3], s = e[5], l = i * r - a * n;
        return l ? (l = 1 / l, t[0] = r * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - r * o) * l, t[5] = (a * o - i * s) * l, t) : null
    }

    function Fe(t) {
        var e = Oe();
        return Ne(e, t), e
    }

    function We(t) {
        return t > TM || -TM > t
    }

    function He(t) {
        this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1
    }

    function Ze(t) {
        return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
    }

    function Ue(t) {
        return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
    }

    function Xe(t) {
        return 0 > t ? 0 : t > 1 ? 1 : t
    }

    function Ye(t) {
        return Ze(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10))
    }

    function je(t) {
        return Xe(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t))
    }

    function qe(t, e, i) {
        return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
    }

    function Ke(t, e, i) {
        return t + (e - t) * i
    }

    function $e(t, e, i, n, o) {
        return t[0] = e, t[1] = i, t[2] = n, t[3] = o, t
    }

    function Je(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function Qe(t, e) {
        GM && Je(GM, e), GM = VM.put(t, GM || e.slice())
    }

    function ti(t, e) {
        if (t) {
            e = e || [];
            var i = VM.get(t);
            if (i) return Je(e, i);
            t += "";
            var n = t.replace(/ /g, "").toLowerCase();
            if (n in BM) return Je(e, BM[n]), Qe(t, e), e;
            if ("#" !== n.charAt(0)) {
                var o = n.indexOf("("), a = n.indexOf(")");
                if (-1 !== o && a + 1 === n.length) {
                    var r = n.substr(0, o), s = n.substr(o + 1, a - (o + 1)).split(","), l = 1;
                    switch (r) {
                        case"rgba":
                            if (4 !== s.length) return void $e(e, 0, 0, 0, 1);
                            l = je(s.pop());
                        case"rgb":
                            return 3 !== s.length ? void $e(e, 0, 0, 0, 1) : ($e(e, Ye(s[0]), Ye(s[1]), Ye(s[2]), l), Qe(t, e), e);
                        case"hsla":
                            return 4 !== s.length ? void $e(e, 0, 0, 0, 1) : (s[3] = je(s[3]), ei(s, e), Qe(t, e), e);
                        case"hsl":
                            return 3 !== s.length ? void $e(e, 0, 0, 0, 1) : (ei(s, e), Qe(t, e), e);
                        default:
                            return
                    }
                }
                $e(e, 0, 0, 0, 1)
            } else {
                if (4 === n.length) {
                    var u = parseInt(n.substr(1), 16);
                    return u >= 0 && 4095 >= u ? ($e(e, (3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1), Qe(t, e), e) : void $e(e, 0, 0, 0, 1)
                }
                if (7 === n.length) {
                    var u = parseInt(n.substr(1), 16);
                    return u >= 0 && 16777215 >= u ? ($e(e, (16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1), Qe(t, e), e) : void $e(e, 0, 0, 0, 1)
                }
            }
        }
    }

    function ei(t, e) {
        var i = (parseFloat(t[0]) % 360 + 360) % 360 / 360, n = je(t[1]), o = je(t[2]),
            a = .5 >= o ? o * (n + 1) : o + n - o * n, r = 2 * o - a;
        return e = e || [], $e(e, Ze(255 * qe(r, a, i + 1 / 3)), Ze(255 * qe(r, a, i)), Ze(255 * qe(r, a, i - 1 / 3)), 1), 4 === t.length && (e[3] = t[3]), e
    }

    function ii(t) {
        if (t) {
            var e, i, n = t[0] / 255, o = t[1] / 255, a = t[2] / 255, r = Math.min(n, o, a), s = Math.max(n, o, a),
                l = s - r, u = (s + r) / 2;
            if (0 === l) e = 0, i = 0; else {
                i = .5 > u ? l / (s + r) : l / (2 - s - r);
                var h = ((s - n) / 6 + l / 2) / l, c = ((s - o) / 6 + l / 2) / l, d = ((s - a) / 6 + l / 2) / l;
                n === s ? e = d - c : o === s ? e = 1 / 3 + h - d : a === s && (e = 2 / 3 + c - h), 0 > e && (e += 1), e > 1 && (e -= 1)
            }
            var f = [360 * e, i, u];
            return null != t[3] && f.push(t[3]), f
        }
    }

    function ni(t, e) {
        var i = ti(t);
        if (i) {
            for (var n = 0; 3 > n; n++) i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0, i[n] > 255 ? i[n] = 255 : t[n] < 0 && (i[n] = 0);
            return ui(i, 4 === i.length ? "rgba" : "rgb")
        }
    }

    function oi(t) {
        var e = ti(t);
        return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0
    }

    function ai(t, e, i) {
        if (e && e.length && t >= 0 && 1 >= t) {
            i = i || [];
            var n = t * (e.length - 1), o = Math.floor(n), a = Math.ceil(n), r = e[o], s = e[a], l = n - o;
            return i[0] = Ze(Ke(r[0], s[0], l)), i[1] = Ze(Ke(r[1], s[1], l)), i[2] = Ze(Ke(r[2], s[2], l)), i[3] = Xe(Ke(r[3], s[3], l)), i
        }
    }

    function ri(t, e, i) {
        if (e && e.length && t >= 0 && 1 >= t) {
            var n = t * (e.length - 1), o = Math.floor(n), a = Math.ceil(n), r = ti(e[o]), s = ti(e[a]), l = n - o,
                u = ui([Ze(Ke(r[0], s[0], l)), Ze(Ke(r[1], s[1], l)), Ze(Ke(r[2], s[2], l)), Xe(Ke(r[3], s[3], l))], "rgba");
            return i ? {color: u, leftIndex: o, rightIndex: a, value: n} : u
        }
    }

    function si(t, e, i, n) {
        return t = ti(t), t ? (t = ii(t), null != e && (t[0] = Ue(e)), null != i && (t[1] = je(i)), null != n && (t[2] = je(n)), ui(ei(t), "rgba")) : void 0
    }

    function li(t, e) {
        return t = ti(t), t && null != e ? (t[3] = Xe(e), ui(t, "rgba")) : void 0
    }

    function ui(t, e) {
        if (t && t.length) {
            var i = t[0] + "," + t[1] + "," + t[2];
            return ("rgba" === e || "hsva" === e || "hsla" === e) && (i += "," + t[3]), e + "(" + i + ")"
        }
    }

    function hi(t, e) {
        return t[e]
    }

    function ci(t, e, i) {
        t[e] = i
    }

    function di(t, e, i) {
        return (e - t) * i + t
    }

    function fi(t, e, i) {
        return i > .5 ? e : t
    }

    function pi(t, e, i, n, o) {
        var a = t.length;
        if (1 === o) for (var r = 0; a > r; r++) n[r] = di(t[r], e[r], i); else for (var s = a && t[0].length, r = 0; a > r; r++) for (var l = 0; s > l; l++) n[r][l] = di(t[r][l], e[r][l], i)
    }

    function gi(t, e, i) {
        var n = t.length, o = e.length;
        if (n !== o) {
            var a = n > o;
            if (a) t.length = o; else for (var r = n; o > r; r++) t.push(1 === i ? e[r] : ZM.call(e[r]))
        }
        for (var s = t[0] && t[0].length, r = 0; r < t.length; r++) if (1 === i) isNaN(t[r]) && (t[r] = e[r]); else for (var l = 0; s > l; l++) isNaN(t[r][l]) && (t[r][l] = e[r][l])
    }

    function mi(t, e, i) {
        if (t === e) return !0;
        var n = t.length;
        if (n !== e.length) return !1;
        if (1 === i) {
            for (var o = 0; n > o; o++) if (t[o] !== e[o]) return !1
        } else for (var a = t[0].length, o = 0; n > o; o++) for (var r = 0; a > r; r++) if (t[o][r] !== e[o][r]) return !1;
        return !0
    }

    function vi(t, e, i, n, o, a, r, s, l) {
        var u = t.length;
        if (1 === l) for (var h = 0; u > h; h++) s[h] = yi(t[h], e[h], i[h], n[h], o, a, r); else for (var c = t[0].length, h = 0; u > h; h++) for (var d = 0; c > d; d++) s[h][d] = yi(t[h][d], e[h][d], i[h][d], n[h][d], o, a, r)
    }

    function yi(t, e, i, n, o, a, r) {
        var s = .5 * (i - t), l = .5 * (n - e);
        return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * a + s * o + e
    }

    function xi(t) {
        if (d(t)) {
            var e = t.length;
            if (d(t[0])) {
                for (var i = [], n = 0; e > n; n++) i.push(ZM.call(t[n]));
                return i
            }
            return ZM.call(t)
        }
        return t
    }

    function _i(t) {
        return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
    }

    function wi(t) {
        var e = t[t.length - 1].value;
        return d(e && e[0]) ? 2 : 1
    }

    function bi(t, e, i, n, o, a) {
        var r = t._getter, s = t._setter, l = "spline" === e, u = n.length;
        if (u) {
            var h, c = n[0].value, f = d(c), p = !1, g = !1, m = f ? wi(n) : 0;
            n.sort(function (t, e) {
                return t.time - e.time
            }), h = n[u - 1].time;
            for (var v = [], y = [], x = n[0].value, _ = !0, w = 0; u > w; w++) {
                v.push(n[w].time / h);
                var b = n[w].value;
                if (f && mi(b, x, m) || !f && b === x || (_ = !1), x = b, "string" == typeof b) {
                    var S = ti(b);
                    S ? (b = S, p = !0) : g = !0
                }
                y.push(b)
            }
            if (a || !_) {
                for (var M = y[u - 1], w = 0; u - 1 > w; w++) f ? gi(y[w], M, m) : !isNaN(y[w]) || isNaN(M) || g || p || (y[w] = M);
                f && gi(r(t._target, o), M, m);
                var I, T, A, D, C, L, k = 0, P = 0;
                if (p) var O = [0, 0, 0, 0];
                var E = function (t, e) {
                    var i;
                    if (0 > e) i = 0; else if (P > e) {
                        for (I = Math.min(k + 1, u - 1), i = I; i >= 0 && !(v[i] <= e); i--) ;
                        i = Math.min(i, u - 2)
                    } else {
                        for (i = k; u > i && !(v[i] > e); i++) ;
                        i = Math.min(i - 1, u - 2)
                    }
                    k = i, P = e;
                    var n = v[i + 1] - v[i];
                    if (0 !== n) if (T = (e - v[i]) / n, l) if (D = y[i], A = y[0 === i ? i : i - 1], C = y[i > u - 2 ? u - 1 : i + 1], L = y[i > u - 3 ? u - 1 : i + 2], f) vi(A, D, C, L, T, T * T, T * T * T, r(t, o), m); else {
                        var a;
                        if (p) a = vi(A, D, C, L, T, T * T, T * T * T, O, 1), a = _i(O); else {
                            if (g) return fi(D, C, T);
                            a = yi(A, D, C, L, T, T * T, T * T * T)
                        }
                        s(t, o, a)
                    } else if (f) pi(y[i], y[i + 1], T, r(t, o), m); else {
                        var a;
                        if (p) pi(y[i], y[i + 1], T, O, 1), a = _i(O); else {
                            if (g) return fi(y[i], y[i + 1], T);
                            a = di(y[i], y[i + 1], T)
                        }
                        s(t, o, a)
                    }
                }, N = new He({target: t._target, life: h, loop: t._loop, delay: t._delay, onframe: E, ondestroy: i});
                return e && "spline" !== e && (N.easing = e), N
            }
        }
    }

    function Si(t, e, i, n, o, a, r, s) {
        function l() {
            h--, h || a && a()
        }

        b(n) ? (a = o, o = n, n = 0) : w(o) ? (a = o, o = "linear", n = 0) : w(n) ? (a = n, n = 0) : w(i) ? (a = i, i = 500) : i || (i = 500), t.stopAnimation(), Mi(t, "", t, e, i, n, s);
        var u = t.animators.slice(), h = u.length;
        h || a && a();
        for (var c = 0; c < u.length; c++) u[c].done(l).start(o, r)
    }

    function Mi(t, e, i, n, o, a, r) {
        var s = {}, l = 0;
        for (var u in n) n.hasOwnProperty(u) && (null != i[u] ? S(n[u]) && !d(n[u]) ? Mi(t, e ? e + "." + u : u, i[u], n[u], o, a, r) : (r ? (s[u] = i[u], Ii(t, e, u, n[u])) : s[u] = n[u], l++) : null == n[u] || r || Ii(t, e, u, n[u]));
        l > 0 && t.animate(e, !1).when(null == o ? 500 : o, s).delay(a || 0)
    }

    function Ii(t, e, i, n) {
        if (e) {
            var o = {};
            o[e] = {}, o[e][i] = n, t.attr(o)
        } else t.attr(i, n)
    }

    function Ti(t, e, i, n) {
        0 > i && (t += i, i = -i), 0 > n && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n
    }

    function Ai(t) {
        for (var e = 0; t >= nI;) e |= 1 & t, t >>= 1;
        return t + e
    }

    function Di(t, e, i, n) {
        var o = e + 1;
        if (o === i) return 1;
        if (n(t[o++], t[e]) < 0) {
            for (; i > o && n(t[o], t[o - 1]) < 0;) o++;
            Ci(t, e, o)
        } else for (; i > o && n(t[o], t[o - 1]) >= 0;) o++;
        return o - e
    }

    function Ci(t, e, i) {
        for (i--; i > e;) {
            var n = t[e];
            t[e++] = t[i], t[i--] = n
        }
    }

    function Li(t, e, i, n, o) {
        for (n === e && n++; i > n; n++) {
            for (var a, r = t[n], s = e, l = n; l > s;) a = s + l >>> 1, o(r, t[a]) < 0 ? l = a : s = a + 1;
            var u = n - s;
            switch (u) {
                case 3:
                    t[s + 3] = t[s + 2];
                case 2:
                    t[s + 2] = t[s + 1];
                case 1:
                    t[s + 1] = t[s];
                    break;
                default:
                    for (; u > 0;) t[s + u] = t[s + u - 1], u--
            }
            t[s] = r
        }
    }

    function ki(t, e, i, n, o, a) {
        var r = 0, s = 0, l = 1;
        if (a(t, e[i + o]) > 0) {
            for (s = n - o; s > l && a(t, e[i + o + l]) > 0;) r = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s), r += o, l += o
        } else {
            for (s = o + 1; s > l && a(t, e[i + o - l]) <= 0;) r = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s);
            var u = r;
            r = o - l, l = o - u
        }
        for (r++; l > r;) {
            var h = r + (l - r >>> 1);
            a(t, e[i + h]) > 0 ? r = h + 1 : l = h
        }
        return l
    }

    function Pi(t, e, i, n, o, a) {
        var r = 0, s = 0, l = 1;
        if (a(t, e[i + o]) < 0) {
            for (s = o + 1; s > l && a(t, e[i + o - l]) < 0;) r = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s);
            var u = r;
            r = o - l, l = o - u
        } else {
            for (s = n - o; s > l && a(t, e[i + o + l]) >= 0;) r = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s), r += o, l += o
        }
        for (r++; l > r;) {
            var h = r + (l - r >>> 1);
            a(t, e[i + h]) < 0 ? l = h : r = h + 1
        }
        return l
    }

    function Oi(t, e) {
        function i(t, e) {
            l[c] = t, u[c] = e, c += 1
        }

        function n() {
            for (; c > 1;) {
                var t = c - 2;
                if (t >= 1 && u[t - 1] <= u[t] + u[t + 1] || t >= 2 && u[t - 2] <= u[t] + u[t - 1]) u[t - 1] < u[t + 1] && t--; else if (u[t] > u[t + 1]) break;
                a(t)
            }
        }

        function o() {
            for (; c > 1;) {
                var t = c - 2;
                t > 0 && u[t - 1] < u[t + 1] && t--, a(t)
            }
        }

        function a(i) {
            var n = l[i], o = u[i], a = l[i + 1], h = u[i + 1];
            u[i] = o + h, i === c - 3 && (l[i + 1] = l[i + 2], u[i + 1] = u[i + 2]), c--;
            var d = Pi(t[a], t, n, o, 0, e);
            n += d, o -= d, 0 !== o && (h = ki(t[n + o - 1], t, a, h, h - 1, e), 0 !== h && (h >= o ? r(n, o, a, h) : s(n, o, a, h)))
        }

        function r(i, n, o, a) {
            var r = 0;
            for (r = 0; n > r; r++) d[r] = t[i + r];
            var s = 0, l = o, u = i;
            if (t[u++] = t[l++], 0 !== --a) {
                if (1 === n) {
                    for (r = 0; a > r; r++) t[u + r] = t[l + r];
                    return void (t[u + a] = d[s])
                }
                for (var c, f, p, g = h; ;) {
                    c = 0, f = 0, p = !1;
                    do if (e(t[l], d[s]) < 0) {
                        if (t[u++] = t[l++], f++, c = 0, 0 === --a) {
                            p = !0;
                            break
                        }
                    } else if (t[u++] = d[s++], c++, f = 0, 1 === --n) {
                        p = !0;
                        break
                    } while (g > (c | f));
                    if (p) break;
                    do {
                        if (c = Pi(t[l], d, s, n, 0, e), 0 !== c) {
                            for (r = 0; c > r; r++) t[u + r] = d[s + r];
                            if (u += c, s += c, n -= c, 1 >= n) {
                                p = !0;
                                break
                            }
                        }
                        if (t[u++] = t[l++], 0 === --a) {
                            p = !0;
                            break
                        }
                        if (f = ki(d[s], t, l, a, 0, e), 0 !== f) {
                            for (r = 0; f > r; r++) t[u + r] = t[l + r];
                            if (u += f, l += f, a -= f, 0 === a) {
                                p = !0;
                                break
                            }
                        }
                        if (t[u++] = d[s++], 1 === --n) {
                            p = !0;
                            break
                        }
                        g--
                    } while (c >= oI || f >= oI);
                    if (p) break;
                    0 > g && (g = 0), g += 2
                }
                if (h = g, 1 > h && (h = 1), 1 === n) {
                    for (r = 0; a > r; r++) t[u + r] = t[l + r];
                    t[u + a] = d[s]
                } else {
                    if (0 === n) throw new Error;
                    for (r = 0; n > r; r++) t[u + r] = d[s + r]
                }
            } else for (r = 0; n > r; r++) t[u + r] = d[s + r]
        }

        function s(i, n, o, a) {
            var r = 0;
            for (r = 0; a > r; r++) d[r] = t[o + r];
            var s = i + n - 1, l = a - 1, u = o + a - 1, c = 0, f = 0;
            if (t[u--] = t[s--], 0 !== --n) {
                if (1 === a) {
                    for (u -= n, s -= n, f = u + 1, c = s + 1, r = n - 1; r >= 0; r--) t[f + r] = t[c + r];
                    return void (t[u] = d[l])
                }
                for (var p = h; ;) {
                    var g = 0, m = 0, v = !1;
                    do if (e(d[l], t[s]) < 0) {
                        if (t[u--] = t[s--], g++, m = 0, 0 === --n) {
                            v = !0;
                            break
                        }
                    } else if (t[u--] = d[l--], m++, g = 0, 1 === --a) {
                        v = !0;
                        break
                    } while (p > (g | m));
                    if (v) break;
                    do {
                        if (g = n - Pi(d[l], t, i, n, n - 1, e), 0 !== g) {
                            for (u -= g, s -= g, n -= g, f = u + 1, c = s + 1, r = g - 1; r >= 0; r--) t[f + r] = t[c + r];
                            if (0 === n) {
                                v = !0;
                                break
                            }
                        }
                        if (t[u--] = d[l--], 1 === --a) {
                            v = !0;
                            break
                        }
                        if (m = a - ki(t[s], d, 0, a, a - 1, e), 0 !== m) {
                            for (u -= m, l -= m, a -= m, f = u + 1, c = l + 1, r = 0; m > r; r++) t[f + r] = d[c + r];
                            if (1 >= a) {
                                v = !0;
                                break
                            }
                        }
                        if (t[u--] = t[s--], 0 === --n) {
                            v = !0;
                            break
                        }
                        p--
                    } while (g >= oI || m >= oI);
                    if (v) break;
                    0 > p && (p = 0), p += 2
                }
                if (h = p, 1 > h && (h = 1), 1 === a) {
                    for (u -= n, s -= n, f = u + 1, c = s + 1, r = n - 1; r >= 0; r--) t[f + r] = t[c + r];
                    t[u] = d[l]
                } else {
                    if (0 === a) throw new Error;
                    for (c = u - (a - 1), r = 0; a > r; r++) t[c + r] = d[r]
                }
            } else for (c = u - (a - 1), r = 0; a > r; r++) t[c + r] = d[r]
        }

        var l, u, h = oI, c = 0, d = [];
        l = [], u = [], this.mergeRuns = n, this.forceMergeRuns = o, this.pushRun = i
    }

    function Ei(t, e, i, n) {
        i || (i = 0), n || (n = t.length);
        var o = n - i;
        if (!(2 > o)) {
            var a = 0;
            if (nI > o) return a = Di(t, i, n, e), void Li(t, i, n, i + a, e);
            var r = new Oi(t, e), s = Ai(o);
            do {
                if (a = Di(t, i, n, e), s > a) {
                    var l = o;
                    l > s && (l = s), Li(t, i, i + l, i + a, e), a = l
                }
                r.pushRun(i, a), r.mergeRuns(), o -= a, i += a
            } while (0 !== o);
            r.forceMergeRuns()
        }
    }

    function Ni(t, e) {
        return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
    }

    function Ri(t, e, i) {
        var n = null == e.x ? 0 : e.x, o = null == e.x2 ? 1 : e.x2, a = null == e.y ? 0 : e.y,
            r = null == e.y2 ? 0 : e.y2;
        e.global || (n = n * i.width + i.x, o = o * i.width + i.x, a = a * i.height + i.y, r = r * i.height + i.y), n = isNaN(n) ? 0 : n, o = isNaN(o) ? 1 : o, a = isNaN(a) ? 0 : a, r = isNaN(r) ? 0 : r;
        var s = t.createLinearGradient(n, a, o, r);
        return s
    }

    function zi(t, e, i) {
        var n = i.width, o = i.height, a = Math.min(n, o), r = null == e.x ? .5 : e.x, s = null == e.y ? .5 : e.y,
            l = null == e.r ? .5 : e.r;
        e.global || (r = r * n + i.x, s = s * o + i.y, l *= a);
        var u = t.createRadialGradient(r, s, 0, r, s, l);
        return u
    }

    function Bi() {
        return !1
    }

    function Vi(t, e, i) {
        var n = QS(), o = e.getWidth(), a = e.getHeight(), r = n.style;
        return r && (r.position = "absolute", r.left = 0, r.top = 0, r.width = o + "px", r.height = a + "px", n.setAttribute("data-zr-dom-id", t)), n.width = o * i, n.height = a * i, n
    }

    function Gi(t) {
        if ("string" == typeof t) {
            var e = yI.get(t);
            return e && e.image
        }
        return t
    }

    function Fi(t, e, i, n, o) {
        if (t) {
            if ("string" == typeof t) {
                if (e && e.__zrImageSrc === t || !i) return e;
                var a = yI.get(t), r = {hostEl: i, cb: n, cbPayload: o};
                return a ? (e = a.image, !Hi(e) && a.pending.push(r)) : (e = new Image, e.onload = e.onerror = Wi, yI.put(t, e.__cachedImgObj = {
                    image: e,
                    pending: [r]
                }), e.src = e.__zrImageSrc = t), e
            }
            return t
        }
        return e
    }

    function Wi() {
        var t = this.__cachedImgObj;
        this.onload = this.onerror = this.__cachedImgObj = null;
        for (var e = 0; e < t.pending.length; e++) {
            var i = t.pending[e], n = i.cb;
            n && n(this, i.cbPayload), i.hostEl.dirty()
        }
        t.pending.length = 0
    }

    function Hi(t) {
        return t && t.width && t.height
    }

    function Zi(t, e) {
        MI[t] = e
    }

    function Ui(t, e) {
        e = e || SI;
        var i = t + ":" + e;
        if (xI[i]) return xI[i];
        for (var n = (t + "").split("\n"), o = 0, a = 0, r = n.length; r > a; a++) o = Math.max(on(n[a], e).width, o);
        return _I > wI && (_I = 0, xI = {}), _I++, xI[i] = o, o
    }

    function Xi(t, e, i, n, o, a, r, s) {
        return r ? ji(t, e, i, n, o, a, r, s) : Yi(t, e, i, n, o, a, s)
    }

    function Yi(t, e, i, n, o, a, r) {
        var s = an(t, e, o, a, r), l = Ui(t, e);
        o && (l += o[1] + o[3]);
        var u = s.outerHeight, h = qi(0, l, i), c = Ki(0, u, n), d = new Ti(h, c, l, u);
        return d.lineHeight = s.lineHeight, d
    }

    function ji(t, e, i, n, o, a, r, s) {
        var l = rn(t, {rich: r, truncate: s, font: e, textAlign: i, textPadding: o, textLineHeight: a}),
            u = l.outerWidth, h = l.outerHeight, c = qi(0, u, i), d = Ki(0, h, n);
        return new Ti(c, d, u, h)
    }

    function qi(t, e, i) {
        return "right" === i ? t -= e : "center" === i && (t -= e / 2), t
    }

    function Ki(t, e, i) {
        return "middle" === i ? t -= e / 2 : "bottom" === i && (t -= e), t
    }

    function $i(t, e, i) {
        var n = e.textPosition, o = e.textDistance, a = i.x, r = i.y;
        o = o || 0;
        var s = i.height, l = i.width, u = s / 2, h = "left", c = "top";
        switch (n) {
            case"left":
                a -= o, r += u, h = "right", c = "middle";
                break;
            case"right":
                a += o + l, r += u, c = "middle";
                break;
            case"top":
                a += l / 2, r -= o, h = "center", c = "bottom";
                break;
            case"bottom":
                a += l / 2, r += s + o, h = "center";
                break;
            case"inside":
                a += l / 2, r += u, h = "center", c = "middle";
                break;
            case"insideLeft":
                a += o, r += u, c = "middle";
                break;
            case"insideRight":
                a += l - o, r += u, h = "right", c = "middle";
                break;
            case"insideTop":
                a += l / 2, r += o, h = "center";
                break;
            case"insideBottom":
                a += l / 2, r += s - o, h = "center", c = "bottom";
                break;
            case"insideTopLeft":
                a += o, r += o;
                break;
            case"insideTopRight":
                a += l - o, r += o, h = "right";
                break;
            case"insideBottomLeft":
                a += o, r += s - o, c = "bottom";
                break;
            case"insideBottomRight":
                a += l - o, r += s - o, h = "right", c = "bottom"
        }
        return t = t || {}, t.x = a, t.y = r, t.textAlign = h, t.textVerticalAlign = c, t
    }

    function Ji(t, e, i, n, o) {
        if (!e) return "";
        var a = (t + "").split("\n");
        o = Qi(e, i, n, o);
        for (var r = 0, s = a.length; s > r; r++) a[r] = tn(a[r], o);
        return a.join("\n")
    }

    function Qi(t, e, i, n) {
        n = r({}, n), n.font = e;
        var i = C(i, "...");
        n.maxIterations = C(n.maxIterations, 2);
        var o = n.minChar = C(n.minChar, 0);
        n.cnCharWidth = Ui("国", e);
        var a = n.ascCharWidth = Ui("a", e);
        n.placeholder = C(n.placeholder, "");
        for (var s = t = Math.max(0, t - 1), l = 0; o > l && s >= a; l++) s -= a;
        var u = Ui(i, e);
        return u > s && (i = "", u = 0), s = t - u, n.ellipsis = i, n.ellipsisWidth = u, n.contentWidth = s, n.containerWidth = t, n
    }

    function tn(t, e) {
        var i = e.containerWidth, n = e.font, o = e.contentWidth;
        if (!i) return "";
        var a = Ui(t, n);
        if (i >= a) return t;
        for (var r = 0; ; r++) {
            if (o >= a || r >= e.maxIterations) {
                t += e.ellipsis;
                break
            }
            var s = 0 === r ? en(t, o, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(t.length * o / a) : 0;
            t = t.substr(0, s), a = Ui(t, n)
        }
        return "" === t && (t = e.placeholder), t
    }

    function en(t, e, i, n) {
        for (var o = 0, a = 0, r = t.length; r > a && e > o; a++) {
            var s = t.charCodeAt(a);
            o += s >= 0 && 127 >= s ? i : n
        }
        return a
    }

    function nn(t) {
        return Ui("国", t)
    }

    function on(t, e) {
        return MI.measureText(t, e)
    }

    function an(t, e, i, n, o) {
        null != t && (t += "");
        var a = C(n, nn(e)), r = t ? t.split("\n") : [], s = r.length * a, l = s, u = !0;
        if (i && (l += i[0] + i[2]), t && o) {
            u = !1;
            var h = o.outerHeight, c = o.outerWidth;
            if (null != h && l > h) t = "", r = []; else if (null != c) for (var d = Qi(c - (i ? i[1] + i[3] : 0), e, o.ellipsis, {
                minChar: o.minChar,
                placeholder: o.placeholder
            }), f = 0, p = r.length; p > f; f++) r[f] = tn(r[f], d)
        }
        return {lines: r, height: s, outerHeight: l, lineHeight: a, canCacheByTextString: u}
    }

    function rn(t, e) {
        var i = {lines: [], width: 0, height: 0};
        if (null != t && (t += ""), !t) return i;
        for (var n, o = bI.lastIndex = 0; null != (n = bI.exec(t));) {
            var a = n.index;
            a > o && sn(i, t.substring(o, a)), sn(i, n[2], n[1]), o = bI.lastIndex
        }
        o < t.length && sn(i, t.substring(o, t.length));
        var r = i.lines, s = 0, l = 0, u = [], h = e.textPadding, c = e.truncate, d = c && c.outerWidth,
            f = c && c.outerHeight;
        h && (null != d && (d -= h[1] + h[3]), null != f && (f -= h[0] + h[2]));
        for (var p = 0; p < r.length; p++) {
            for (var g = r[p], m = 0, v = 0, y = 0; y < g.tokens.length; y++) {
                var x = g.tokens[y], _ = x.styleName && e.rich[x.styleName] || {}, w = x.textPadding = _.textPadding,
                    b = x.font = _.font || e.font, S = x.textHeight = C(_.textHeight, nn(b));
                if (w && (S += w[0] + w[2]), x.height = S, x.lineHeight = L(_.textLineHeight, e.textLineHeight, S), x.textAlign = _ && _.textAlign || e.textAlign, x.textVerticalAlign = _ && _.textVerticalAlign || "middle", null != f && s + x.lineHeight > f) return {
                    lines: [],
                    width: 0,
                    height: 0
                };
                x.textWidth = Ui(x.text, b);
                var M = _.textWidth, I = null == M || "auto" === M;
                if ("string" == typeof M && "%" === M.charAt(M.length - 1)) x.percentWidth = M, u.push(x), M = 0; else {
                    if (I) {
                        M = x.textWidth;
                        var T = _.textBackgroundColor, A = T && T.image;
                        A && (A = Gi(A), Hi(A) && (M = Math.max(M, A.width * S / A.height)))
                    }
                    var D = w ? w[1] + w[3] : 0;
                    M += D;
                    var k = null != d ? d - v : null;
                    null != k && M > k && (!I || D > k ? (x.text = "", x.textWidth = M = 0) : (x.text = Ji(x.text, k - D, b, c.ellipsis, {minChar: c.minChar}), x.textWidth = Ui(x.text, b), M = x.textWidth + D))
                }
                v += x.width = M, _ && (m = Math.max(m, x.lineHeight))
            }
            g.width = v, g.lineHeight = m, s += m, l = Math.max(l, v)
        }
        i.outerWidth = i.width = C(e.textWidth, l), i.outerHeight = i.height = C(e.textHeight, s), h && (i.outerWidth += h[1] + h[3], i.outerHeight += h[0] + h[2]);
        for (var p = 0; p < u.length; p++) {
            var x = u[p], P = x.percentWidth;
            x.width = parseInt(P, 10) / 100 * l
        }
        return i
    }

    function sn(t, e, i) {
        for (var n = "" === e, o = e.split("\n"), a = t.lines, r = 0; r < o.length; r++) {
            var s = o[r], l = {styleName: i, text: s, isLineHolder: !s && !n};
            if (r) a.push({tokens: [l]}); else {
                var u = (a[a.length - 1] || (a[0] = {tokens: []})).tokens, h = u.length;
                1 === h && u[0].isLineHolder ? u[0] = l : (s || !h || n) && u.push(l)
            }
        }
    }

    function ln(t) {
        var e = (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, (t.fontSize || 12) + "px", t.fontFamily || "sans-serif"].join(" ");
        return e && E(e) || t.textFont || t.font
    }

    function un(t, e) {
        var i, n, o, a, r = e.x, s = e.y, l = e.width, u = e.height, h = e.r;
        0 > l && (r += l, l = -l), 0 > u && (s += u, u = -u), "number" == typeof h ? i = n = o = a = h : h instanceof Array ? 1 === h.length ? i = n = o = a = h[0] : 2 === h.length ? (i = o = h[0], n = a = h[1]) : 3 === h.length ? (i = h[0], n = a = h[1], o = h[2]) : (i = h[0], n = h[1], o = h[2], a = h[3]) : i = n = o = a = 0;
        var c;
        i + n > l && (c = i + n, i *= l / c, n *= l / c), o + a > l && (c = o + a, o *= l / c, a *= l / c), n + o > u && (c = n + o, n *= u / c, o *= u / c), i + a > u && (c = i + a, i *= u / c, a *= u / c), t.moveTo(r + i, s), t.lineTo(r + l - n, s), 0 !== n && t.arc(r + l - n, s + n, n, -Math.PI / 2, 0), t.lineTo(r + l, s + u - o), 0 !== o && t.arc(r + l - o, s + u - o, o, 0, Math.PI / 2), t.lineTo(r + a, s + u), 0 !== a && t.arc(r + a, s + u - a, a, Math.PI / 2, Math.PI), t.lineTo(r, s + i), 0 !== i && t.arc(r + i, s + i, i, Math.PI, 1.5 * Math.PI)
    }

    function hn(t) {
        return cn(t), f(t.rich, cn), t
    }

    function cn(t) {
        if (t) {
            t.font = ln(t);
            var e = t.textAlign;
            "middle" === e && (e = "center"), t.textAlign = null == e || TI[e] ? e : "left";
            var i = t.textVerticalAlign || t.textBaseline;
            "center" === i && (i = "middle"), t.textVerticalAlign = null == i || AI[i] ? i : "top";
            var n = t.textPadding;
            n && (t.textPadding = P(t.textPadding))
        }
    }

    function dn(t, e, i, n, o, a) {
        n.rich ? pn(t, e, i, n, o, a) : fn(t, e, i, n, o, a)
    }

    function fn(t, e, i, n, o, a) {
        var r, s = yn(n), l = !1, u = e.__attrCachedBy === lI.PLAIN_TEXT;
        a !== uI ? (a && (r = a.style, l = !s && u && r), e.__attrCachedBy = s ? lI.NONE : lI.PLAIN_TEXT) : u && (e.__attrCachedBy = lI.NONE);
        var h = n.font || II;
        l && h === (r.font || II) || (e.font = h);
        var c = t.__computedFont;
        t.__styleFont !== h && (t.__styleFont = h, c = t.__computedFont = e.font);
        var d = n.textPadding, f = n.textLineHeight, p = t.__textCotentBlock;
        (!p || t.__dirtyText) && (p = t.__textCotentBlock = an(i, c, d, f, n.truncate));
        var g = p.outerHeight, m = p.lines, v = p.lineHeight, y = wn(LI, t, n, o), x = y.baseX, _ = y.baseY,
            w = y.textAlign || "left", b = y.textVerticalAlign;
        mn(e, n, o, x, _);
        var S = Ki(_, g, b), M = x, I = S;
        if (s || d) {
            var T = Ui(i, c), A = T;
            d && (A += d[1] + d[3]);
            var D = qi(x, A, w);
            s && xn(t, e, n, D, S, A, g), d && (M = Tn(x, w, d), I += d[0])
        }
        e.textAlign = w, e.textBaseline = "middle", e.globalAlpha = n.opacity || 1;
        for (var C = 0; C < DI.length; C++) {
            var L = DI[C], k = L[0], P = L[1], O = n[k];
            l && O === r[k] || (e[P] = sI(e, P, O || L[2]))
        }
        I += v / 2;
        var E = n.textStrokeWidth, N = l ? r.textStrokeWidth : null, R = !l || E !== N,
            z = !l || R || n.textStroke !== r.textStroke, B = Sn(n.textStroke, E), V = Mn(n.textFill);
        if (B && (R && (e.lineWidth = E), z && (e.strokeStyle = B)), V && (l && n.textFill === r.textFill || (e.fillStyle = V)), 1 === m.length) B && e.strokeText(m[0], M, I), V && e.fillText(m[0], M, I); else for (var C = 0; C < m.length; C++) B && e.strokeText(m[C], M, I), V && e.fillText(m[C], M, I), I += v
    }

    function pn(t, e, i, n, o, a) {
        a !== uI && (e.__attrCachedBy = lI.NONE);
        var r = t.__textCotentBlock;
        (!r || t.__dirtyText) && (r = t.__textCotentBlock = rn(i, n)), gn(t, e, r, n, o)
    }

    function gn(t, e, i, n, o) {
        var a = i.width, r = i.outerWidth, s = i.outerHeight, l = n.textPadding, u = wn(LI, t, n, o), h = u.baseX,
            c = u.baseY, d = u.textAlign, f = u.textVerticalAlign;
        mn(e, n, o, h, c);
        var p = qi(h, r, d), g = Ki(c, s, f), m = p, v = g;
        l && (m += l[3], v += l[0]);
        var y = m + a;
        yn(n) && xn(t, e, n, p, g, r, s);
        for (var x = 0; x < i.lines.length; x++) {
            for (var _, w = i.lines[x], b = w.tokens, S = b.length, M = w.lineHeight, I = w.width, T = 0, A = m, D = y, C = S - 1; S > T && (_ = b[T], !_.textAlign || "left" === _.textAlign);) vn(t, e, _, n, M, v, A, "left"), I -= _.width, A += _.width, T++;
            for (; C >= 0 && (_ = b[C], "right" === _.textAlign);) vn(t, e, _, n, M, v, D, "right"), I -= _.width, D -= _.width, C--;
            for (A += (a - (A - m) - (y - D) - I) / 2; C >= T;) _ = b[T], vn(t, e, _, n, M, v, A + _.width / 2, "center"), A += _.width, T++;
            v += M
        }
    }

    function mn(t, e, i, n, o) {
        if (i && e.textRotation) {
            var a = e.textOrigin;
            "center" === a ? (n = i.width / 2 + i.x, o = i.height / 2 + i.y) : a && (n = a[0] + i.x, o = a[1] + i.y), t.translate(n, o), t.rotate(-e.textRotation), t.translate(-n, -o)
        }
    }

    function vn(t, e, i, n, o, a, r, s) {
        var l = n.rich[i.styleName] || {};
        l.text = i.text;
        var u = i.textVerticalAlign, h = a + o / 2;
        "top" === u ? h = a + i.height / 2 : "bottom" === u && (h = a + o - i.height / 2), !i.isLineHolder && yn(l) && xn(t, e, l, "right" === s ? r - i.width : "center" === s ? r - i.width / 2 : r, h - i.height / 2, i.width, i.height);
        var c = i.textPadding;
        c && (r = Tn(r, s, c), h -= i.height / 2 - c[2] - i.textHeight / 2), bn(e, "shadowBlur", L(l.textShadowBlur, n.textShadowBlur, 0)), bn(e, "shadowColor", l.textShadowColor || n.textShadowColor || "transparent"), bn(e, "shadowOffsetX", L(l.textShadowOffsetX, n.textShadowOffsetX, 0)), bn(e, "shadowOffsetY", L(l.textShadowOffsetY, n.textShadowOffsetY, 0)), bn(e, "textAlign", s), bn(e, "textBaseline", "middle"), bn(e, "font", i.font || II);
        var d = Sn(l.textStroke || n.textStroke, p), f = Mn(l.textFill || n.textFill),
            p = C(l.textStrokeWidth, n.textStrokeWidth);
        d && (bn(e, "lineWidth", p), bn(e, "strokeStyle", d), e.strokeText(i.text, r, h)), f && (bn(e, "fillStyle", f), e.fillText(i.text, r, h))
    }

    function yn(t) {
        return !!(t.textBackgroundColor || t.textBorderWidth && t.textBorderColor)
    }

    function xn(t, e, i, n, o, a, r) {
        var s = i.textBackgroundColor, l = i.textBorderWidth, u = i.textBorderColor, h = b(s);
        if (bn(e, "shadowBlur", i.textBoxShadowBlur || 0), bn(e, "shadowColor", i.textBoxShadowColor || "transparent"), bn(e, "shadowOffsetX", i.textBoxShadowOffsetX || 0), bn(e, "shadowOffsetY", i.textBoxShadowOffsetY || 0), h || l && u) {
            e.beginPath();
            var c = i.textBorderRadius;
            c ? un(e, {x: n, y: o, width: a, height: r, r: c}) : e.rect(n, o, a, r), e.closePath()
        }
        if (h) if (bn(e, "fillStyle", s), null != i.fillOpacity) {
            var d = e.globalAlpha;
            e.globalAlpha = i.fillOpacity * i.opacity, e.fill(), e.globalAlpha = d
        } else e.fill(); else if (S(s)) {
            var f = s.image;
            f = Fi(f, null, t, _n, s), f && Hi(f) && e.drawImage(f, n, o, a, r)
        }
        if (l && u) if (bn(e, "lineWidth", l), bn(e, "strokeStyle", u), null != i.strokeOpacity) {
            var d = e.globalAlpha;
            e.globalAlpha = i.strokeOpacity * i.opacity, e.stroke(), e.globalAlpha = d
        } else e.stroke()
    }

    function _n(t, e) {
        e.image = t
    }

    function wn(t, e, i, n) {
        var o = i.x || 0, a = i.y || 0, r = i.textAlign, s = i.textVerticalAlign;
        if (n) {
            var l = i.textPosition;
            if (l instanceof Array) o = n.x + In(l[0], n.width), a = n.y + In(l[1], n.height); else {
                var u = e && e.calculateTextPosition ? e.calculateTextPosition(CI, i, n) : $i(CI, i, n);
                o = u.x, a = u.y, r = r || u.textAlign, s = s || u.textVerticalAlign
            }
            var h = i.textOffset;
            h && (o += h[0], a += h[1])
        }
        return t = t || {}, t.baseX = o, t.baseY = a, t.textAlign = r, t.textVerticalAlign = s, t
    }

    function bn(t, e, i) {
        return t[e] = sI(t, e, i), t[e]
    }

    function Sn(t, e) {
        return null == t || 0 >= e || "transparent" === t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
    }

    function Mn(t) {
        return null == t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
    }

    function In(t, e) {
        return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
    }

    function Tn(t, e, i) {
        return "right" === e ? t - i[1] : "center" === e ? t + i[3] / 2 - i[1] / 2 : t + i[3]
    }

    function An(t, e) {
        return null != t && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding)
    }

    function Dn(t) {
        t = t || {}, JM.call(this, t);
        for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
        this.style = new cI(t.style, this), this._rect = null, this.__clipPaths = null
    }

    function Cn(t) {
        Dn.call(this, t)
    }

    function Ln(t) {
        return parseInt(t, 10)
    }

    function kn(t) {
        return t ? t.__builtin__ ? !0 : "function" != typeof t.resize || "function" != typeof t.refresh ? !1 : !0 : !1
    }

    function Pn(t, e, i) {
        return zI.copy(t.getBoundingRect()), t.transform && zI.applyTransform(t.transform), BI.width = e, BI.height = i, !zI.intersect(BI)
    }

    function On(t, e) {
        if (t === e) return !1;
        if (!t || !e || t.length !== e.length) return !0;
        for (var i = 0; i < t.length; i++) if (t[i] !== e[i]) return !0;
        return !1
    }

    function En(t, e) {
        for (var i = 0; i < t.length; i++) {
            var n = t[i];
            n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e)
        }
    }

    function Nn(t, e) {
        var i = document.createElement("div");
        return i.style.cssText = ["position:relative", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", i
    }

    function Rn(t) {
        return "mousewheel" === t && WS.browser.firefox ? "DOMMouseScroll" : t
    }

    function zn(t) {
        var e = t.pointerType;
        return "pen" === e || "touch" === e
    }

    function Bn(t) {
        t.touching = !0, null != t.touchTimer && (clearTimeout(t.touchTimer), t.touchTimer = null), t.touchTimer = setTimeout(function () {
            t.touching = !1, t.touchTimer = null
        }, 700)
    }

    function Vn(t) {
        t && (t.zrByTouch = !0)
    }

    function Gn(t, e) {
        return be(t.dom, new Wn(t, e), !0)
    }

    function Fn(t, e) {
        for (var i = e, n = !1; i && 9 !== i.nodeType && !(n = i.domBelongToZr || i !== e && i === t.painterRoot);) i = i.parentNode;
        return n
    }

    function Wn(t, e) {
        this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY
    }

    function Hn(t, e) {
        var i = e.domHandlers;
        WS.pointerEventsSupported ? f(HI.pointer, function (n) {
            Un(e, n, function (e) {
                i[n].call(t, e)
            })
        }) : (WS.touchEventsSupported && f(HI.touch, function (n) {
            Un(e, n, function (o) {
                i[n].call(t, o), Bn(e)
            })
        }), f(HI.mouse, function (n) {
            Un(e, n, function (o) {
                o = we(o), e.touching || i[n].call(t, o)
            })
        }))
    }

    function Zn(t, e) {
        function i(i) {
            function n(n) {
                n = we(n), Fn(t, n.target) || (n = Gn(t, n), e.domHandlers[i].call(t, n))
            }

            Un(e, i, n, {capture: !0})
        }

        WS.pointerEventsSupported ? f(ZI.pointer, i) : WS.touchEventsSupported || f(ZI.mouse, i)
    }

    function Un(t, e, i, n) {
        t.mounted[e] = i, t.listenerOpts[e] = n, Se(t.domTarget, Rn(e), i, n)
    }

    function Xn(t) {
        var e = t.mounted;
        for (var i in e) e.hasOwnProperty(i) && Me(t.domTarget, Rn(i), e[i], t.listenerOpts[i]);
        t.mounted = {}
    }

    function Yn(t, e) {
        if (t._mayPointerCapture = null, WI && t._pointerCapturing ^ e) {
            t._pointerCapturing = e;
            var i = t._globalHandlerScope;
            e ? Zn(t, i) : Xn(i)
        }
    }

    function jn(t, e) {
        this.domTarget = t, this.domHandlers = e, this.mounted = {}, this.listenerOpts = {}, this.touchTimer = null, this.touching = !1
    }

    function qn(t, e) {
        hM.call(this), this.dom = t, this.painterRoot = e, this._localHandlerScope = new jn(t, XI), WI && (this._globalHandlerScope = new jn(document, YI)), this._pointerCapturing = !1, this._mayPointerCapture = null, Hn(this, this._localHandlerScope)
    }

    function Kn(t, e) {
        var i = new QI(GS(), t, e);
        return $I[i.id] = i, i
    }

    function $n(t) {
        if (t) t.dispose(); else {
            for (var e in $I) $I.hasOwnProperty(e) && $I[e].dispose();
            $I = {}
        }
        return this
    }

    function Jn(t) {
        return $I[t]
    }

    function Qn(t, e) {
        KI[t] = e
    }

    function to(t) {
        delete $I[t]
    }

    function eo(t) {
        return t instanceof Array ? t : null == t ? [] : [t]
    }

    function io(t, e, i) {
        if (t) {
            t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {};
            for (var n = 0, o = i.length; o > n; n++) {
                var a = i[n];
                !t.emphasis[e].hasOwnProperty(a) && t[e].hasOwnProperty(a) && (t.emphasis[e][a] = t[e][a])
            }
        }
    }

    function no(t) {
        return !iT(t) || nT(t) || t instanceof Date ? t : t.value
    }

    function oo(t) {
        return iT(t) && !(t instanceof Array)
    }

    function ao(t, e) {
        e = (e || []).slice();
        var i = p(t || [], function (t) {
            return {exist: t}
        });
        return eT(e, function (t, n) {
            if (iT(t)) {
                for (var o = 0; o < i.length; o++) if (!i[o].option && null != t.id && i[o].exist.id === t.id + "") return i[o].option = t, void (e[n] = null);
                for (var o = 0; o < i.length; o++) {
                    var a = i[o].exist;
                    if (!(i[o].option || null != a.id && null != t.id || null == t.name || lo(t) || lo(a) || a.name !== t.name + "")) return i[o].option = t, void (e[n] = null)
                }
            }
        }), eT(e, function (t) {
            if (iT(t)) {
                for (var e = 0; e < i.length; e++) {
                    var n = i[e].exist;
                    if (!i[e].option && !lo(n) && null == t.id) {
                        i[e].option = t;
                        break
                    }
                }
                e >= i.length && i.push({option: t})
            }
        }), i
    }

    function ro(t) {
        var e = B();
        eT(t, function (t) {
            var i = t.exist;
            i && e.set(i.id, t)
        }), eT(t, function (t) {
            var i = t.option;
            O(!i || null == i.id || !e.get(i.id) || e.get(i.id) === t, "id duplicates: " + (i && i.id)), i && null != i.id && e.set(i.id, t), !t.keyInfo && (t.keyInfo = {})
        }), eT(t, function (t, i) {
            var n = t.exist, o = t.option, a = t.keyInfo;
            if (iT(o)) {
                if (a.name = null != o.name ? o.name + "" : n ? n.name : oT + i, n) a.id = n.id; else if (null != o.id) a.id = o.id + ""; else {
                    var r = 0;
                    do a.id = "\x00" + a.name + "\x00" + r++; while (e.get(a.id))
                }
                e.set(a.id, t)
            }
        })
    }

    function so(t) {
        var e = t.name;
        return !(!e || !e.indexOf(oT))
    }

    function lo(t) {
        return iT(t) && t.id && 0 === (t.id + "").indexOf("\x00_ec_\x00")
    }

    function uo(t, e) {
        function i(t, e, i) {
            for (var n = 0, o = t.length; o > n; n++) for (var a = t[n].seriesId, r = eo(t[n].dataIndex), s = i && i[a], l = 0, u = r.length; u > l; l++) {
                var h = r[l];
                s && s[h] ? s[h] = null : (e[a] || (e[a] = {}))[h] = 1
            }
        }

        function n(t, e) {
            var i = [];
            for (var o in t) if (t.hasOwnProperty(o) && null != t[o]) if (e) i.push(+o); else {
                var a = n(t[o], !0);
                a.length && i.push({seriesId: o, dataIndex: a})
            }
            return i
        }

        var o = {}, a = {};
        return i(t || [], o), i(e || [], a, o), [n(o), n(a)]
    }

    function ho(t, e) {
        return null != e.dataIndexInside ? e.dataIndexInside : null != e.dataIndex ? _(e.dataIndex) ? p(e.dataIndex, function (e) {
            return t.indexOfRawIndex(e)
        }) : t.indexOfRawIndex(e.dataIndex) : null != e.name ? _(e.name) ? p(e.name, function (e) {
            return t.indexOfName(e)
        }) : t.indexOfName(e.name) : void 0
    }

    function co() {
        var t = "__\x00ec_inner_" + rT++ + "_" + Math.random().toFixed(5);
        return function (e) {
            return e[t] || (e[t] = {})
        }
    }

    function fo(t, e, i) {
        if (b(e)) {
            var n = {};
            n[e + "Index"] = 0, e = n
        }
        var o = i && i.defaultMainType;
        !o || po(e, o + "Index") || po(e, o + "Id") || po(e, o + "Name") || (e[o + "Index"] = 0);
        var a = {};
        return eT(e, function (n, o) {
            var n = e[o];
            if ("dataIndex" === o || "dataIndexInside" === o) return void (a[o] = n);
            var r = o.match(/^(\w+)(Index|Id|Name)$/) || [], s = r[1], l = (r[2] || "").toLowerCase();
            if (!(!s || !l || null == n || "index" === l && "none" === n || i && i.includeMainTypes && u(i.includeMainTypes, s) < 0)) {
                var h = {mainType: s};
                ("index" !== l || "all" !== n) && (h[l] = n);
                var c = t.queryComponents(h);
                a[s + "Models"] = c, a[s + "Model"] = c[0]
            }
        }), a
    }

    function po(t, e) {
        return t && t.hasOwnProperty(e)
    }

    function go(t, e, i) {
        t.setAttribute ? t.setAttribute(e, i) : t[e] = i
    }

    function mo(t, e) {
        return t.getAttribute ? t.getAttribute(e) : t[e]
    }

    function vo(t) {
        return "auto" === t ? WS.domSupported ? "html" : "richText" : t || "html"
    }

    function yo(t, e) {
        var i = B(), n = [];
        return f(t, function (t) {
            var o = e(t);
            (i.get(o) || (n.push(o), i.set(o, []))).push(t)
        }), {keys: n, buckets: i}
    }

    function xo(t) {
        var e = {main: "", sub: ""};
        return t && (t = t.split(sT), e.main = t[0] || "", e.sub = t[1] || ""), e
    }

    function _o(t) {
        O(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal')
    }

    function wo(t, e) {
        t.$constructor = t, t.extend = function (t) {
            BS && f(e, function (e) {
                t[e] || console.warn("Method `" + e + "` should be implemented" + (t.type ? " in " + t.type : "") + ".")
            });
            var i = this, n = function () {
                t.$constructor ? t.$constructor.apply(this, arguments) : i.apply(this, arguments)
            };
            return r(n.prototype, t), n.extend = this.extend, n.superCall = So, n.superApply = Mo, h(n, this), n.superClass = i, n
        }
    }

    function bo(t) {
        var e = ["__\x00is_clz", uT++, Math.random().toFixed(3)].join("_");
        t.prototype[e] = !0, BS && O(!t.isInstance, 'The method "is" can not be defined.'), t.isInstance = function (t) {
            return !(!t || !t[e])
        }
    }

    function So(t, e) {
        var i = k(arguments, 2);
        return this.superClass.prototype[e].apply(t, i)
    }

    function Mo(t, e, i) {
        return this.superClass.prototype[e].apply(t, i)
    }

    function Io(t, e) {
        function i(t) {
            var e = n[t.main];
            return e && e[lT] || (e = n[t.main] = {}, e[lT] = !0), e
        }

        e = e || {};
        var n = {};
        if (t.registerClass = function (t, e) {
            if (e) if (_o(e), e = xo(e), e.sub) {
                if (e.sub !== lT) {
                    var o = i(e);
                    o[e.sub] = t
                }
            } else BS && n[e.main] && console.warn(e.main + " exists."), n[e.main] = t;
            return t
        }, t.getClass = function (t, e, i) {
            var o = n[t];
            if (o && o[lT] && (o = e ? o[e] : null), i && !o) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified.");
            return o
        }, t.getClassesByMainType = function (t) {
            t = xo(t);
            var e = [], i = n[t.main];
            return i && i[lT] ? f(i, function (t, i) {
                i !== lT && e.push(t)
            }) : e.push(i), e
        }, t.hasClass = function (t) {
            return t = xo(t), !!n[t.main]
        }, t.getAllClassMainTypes = function () {
            var t = [];
            return f(n, function (e, i) {
                t.push(i)
            }), t
        }, t.hasSubTypes = function (t) {
            t = xo(t);
            var e = n[t.main];
            return e && e[lT]
        }, t.parseClassType = xo, e.registerWhenExtend) {
            var o = t.extend;
            o && (t.extend = function (e) {
                var i = o.call(this, e);
                return t.registerClass(i, e.type)
            })
        }
        return t
    }

    function To(t) {
        return t > -vT && vT > t
    }

    function Ao(t) {
        return t > vT || -vT > t
    }

    function Do(t, e, i, n, o) {
        var a = 1 - o;
        return a * a * (a * t + 3 * o * e) + o * o * (o * n + 3 * a * i)
    }

    function Co(t, e, i, n, o) {
        var a = 1 - o;
        return 3 * (((e - t) * a + 2 * (i - e) * o) * a + (n - i) * o * o)
    }

    function Lo(t, e, i, n, o, a) {
        var r = n + 3 * (e - i) - t, s = 3 * (i - 2 * e + t), l = 3 * (e - t), u = t - o, h = s * s - 3 * r * l,
            c = s * l - 9 * r * u, d = l * l - 3 * s * u, f = 0;
        if (To(h) && To(c)) if (To(s)) a[0] = 0; else {
            var p = -l / s;
            p >= 0 && 1 >= p && (a[f++] = p)
        } else {
            var g = c * c - 4 * h * d;
            if (To(g)) {
                var m = c / h, p = -s / r + m, v = -m / 2;
                p >= 0 && 1 >= p && (a[f++] = p), v >= 0 && 1 >= v && (a[f++] = v)
            } else if (g > 0) {
                var y = mT(g), x = h * s + 1.5 * r * (-c + y), _ = h * s + 1.5 * r * (-c - y);
                x = 0 > x ? -gT(-x, _T) : gT(x, _T), _ = 0 > _ ? -gT(-_, _T) : gT(_, _T);
                var p = (-s - (x + _)) / (3 * r);
                p >= 0 && 1 >= p && (a[f++] = p)
            } else {
                var w = (2 * h * s - 3 * r * c) / (2 * mT(h * h * h)), b = Math.acos(w) / 3, S = mT(h), M = Math.cos(b),
                    p = (-s - 2 * S * M) / (3 * r), v = (-s + S * (M + xT * Math.sin(b))) / (3 * r),
                    I = (-s + S * (M - xT * Math.sin(b))) / (3 * r);
                p >= 0 && 1 >= p && (a[f++] = p), v >= 0 && 1 >= v && (a[f++] = v), I >= 0 && 1 >= I && (a[f++] = I)
            }
        }
        return f
    }

    function ko(t, e, i, n, o) {
        var a = 6 * i - 12 * e + 6 * t, r = 9 * e + 3 * n - 3 * t - 9 * i, s = 3 * e - 3 * t, l = 0;
        if (To(r)) {
            if (Ao(a)) {
                var u = -s / a;
                u >= 0 && 1 >= u && (o[l++] = u)
            }
        } else {
            var h = a * a - 4 * r * s;
            if (To(h)) o[0] = -a / (2 * r); else if (h > 0) {
                var c = mT(h), u = (-a + c) / (2 * r), d = (-a - c) / (2 * r);
                u >= 0 && 1 >= u && (o[l++] = u), d >= 0 && 1 >= d && (o[l++] = d)
            }
        }
        return l
    }

    function Po(t, e, i, n, o, a) {
        var r = (e - t) * o + t, s = (i - e) * o + e, l = (n - i) * o + i, u = (s - r) * o + r, h = (l - s) * o + s,
            c = (h - u) * o + u;
        a[0] = t, a[1] = r, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = n
    }

    function Oo(t, e, i, n, o, a, r, s, l, u, h) {
        var c, d, f, p, g, m = .005, v = 1 / 0;
        wT[0] = l, wT[1] = u;
        for (var y = 0; 1 > y; y += .05) bT[0] = Do(t, i, o, r, y), bT[1] = Do(e, n, a, s, y), p = sM(wT, bT), v > p && (c = y, v = p);
        v = 1 / 0;
        for (var x = 0; 32 > x && !(yT > m); x++) d = c - m, f = c + m, bT[0] = Do(t, i, o, r, d), bT[1] = Do(e, n, a, s, d), p = sM(bT, wT), d >= 0 && v > p ? (c = d, v = p) : (ST[0] = Do(t, i, o, r, f), ST[1] = Do(e, n, a, s, f), g = sM(ST, wT), 1 >= f && v > g ? (c = f, v = g) : m *= .5);
        return h && (h[0] = Do(t, i, o, r, c), h[1] = Do(e, n, a, s, c)), mT(v)
    }

    function Eo(t, e, i, n) {
        var o = 1 - n;
        return o * (o * t + 2 * n * e) + n * n * i
    }

    function No(t, e, i, n) {
        return 2 * ((1 - n) * (e - t) + n * (i - e))
    }

    function Ro(t, e, i, n, o) {
        var a = t - 2 * e + i, r = 2 * (e - t), s = t - n, l = 0;
        if (To(a)) {
            if (Ao(r)) {
                var u = -s / r;
                u >= 0 && 1 >= u && (o[l++] = u)
            }
        } else {
            var h = r * r - 4 * a * s;
            if (To(h)) {
                var u = -r / (2 * a);
                u >= 0 && 1 >= u && (o[l++] = u)
            } else if (h > 0) {
                var c = mT(h), u = (-r + c) / (2 * a), d = (-r - c) / (2 * a);
                u >= 0 && 1 >= u && (o[l++] = u), d >= 0 && 1 >= d && (o[l++] = d)
            }
        }
        return l
    }

    function zo(t, e, i) {
        var n = t + i - 2 * e;
        return 0 === n ? .5 : (t - e) / n
    }

    function Bo(t, e, i, n, o) {
        var a = (e - t) * n + t, r = (i - e) * n + e, s = (r - a) * n + a;
        o[0] = t, o[1] = a, o[2] = s, o[3] = s, o[4] = r, o[5] = i
    }

    function Vo(t, e, i, n, o, a, r, s, l) {
        var u, h = .005, c = 1 / 0;
        wT[0] = r, wT[1] = s;
        for (var d = 0; 1 > d; d += .05) {
            bT[0] = Eo(t, i, o, d), bT[1] = Eo(e, n, a, d);
            var f = sM(wT, bT);
            c > f && (u = d, c = f)
        }
        c = 1 / 0;
        for (var p = 0; 32 > p && !(yT > h); p++) {
            var g = u - h, m = u + h;
            bT[0] = Eo(t, i, o, g), bT[1] = Eo(e, n, a, g);
            var f = sM(bT, wT);
            if (g >= 0 && c > f) u = g, c = f; else {
                ST[0] = Eo(t, i, o, m), ST[1] = Eo(e, n, a, m);
                var v = sM(ST, wT);
                1 >= m && c > v ? (u = m, c = v) : h *= .5
            }
        }
        return l && (l[0] = Eo(t, i, o, u), l[1] = Eo(e, n, a, u)), mT(c)
    }

    function Go(t, e, i) {
        if (0 !== t.length) {
            var n, o = t[0], a = o[0], r = o[0], s = o[1], l = o[1];
            for (n = 1; n < t.length; n++) o = t[n], a = MT(a, o[0]), r = IT(r, o[0]), s = MT(s, o[1]), l = IT(l, o[1]);
            e[0] = a, e[1] = s, i[0] = r, i[1] = l
        }
    }

    function Fo(t, e, i, n, o, a) {
        o[0] = MT(t, i), o[1] = MT(e, n), a[0] = IT(t, i), a[1] = IT(e, n)
    }

    function Wo(t, e, i, n, o, a, r, s, l, u) {
        var h, c = ko, d = Do, f = c(t, i, o, r, PT);
        for (l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0, h = 0; f > h; h++) {
            var p = d(t, i, o, r, PT[h]);
            l[0] = MT(p, l[0]), u[0] = IT(p, u[0])
        }
        for (f = c(e, n, a, s, OT), h = 0; f > h; h++) {
            var g = d(e, n, a, s, OT[h]);
            l[1] = MT(g, l[1]), u[1] = IT(g, u[1])
        }
        l[0] = MT(t, l[0]), u[0] = IT(t, u[0]), l[0] = MT(r, l[0]), u[0] = IT(r, u[0]), l[1] = MT(e, l[1]), u[1] = IT(e, u[1]), l[1] = MT(s, l[1]), u[1] = IT(s, u[1])
    }

    function Ho(t, e, i, n, o, a, r, s) {
        var l = zo, u = Eo, h = IT(MT(l(t, i, o), 1), 0), c = IT(MT(l(e, n, a), 1), 0), d = u(t, i, o, h),
            f = u(e, n, a, c);
        r[0] = MT(t, o, d), r[1] = MT(e, a, f), s[0] = IT(t, o, d), s[1] = IT(e, a, f)
    }

    function Zo(t, e, i, n, o, a, r, s, l) {
        var u = re, h = se, c = Math.abs(o - a);
        if (1e-4 > c % DT && c > 1e-4) return s[0] = t - i, s[1] = e - n, l[0] = t + i, void (l[1] = e + n);
        if (CT[0] = AT(o) * i + t, CT[1] = TT(o) * n + e, LT[0] = AT(a) * i + t, LT[1] = TT(a) * n + e, u(s, CT, LT), h(l, CT, LT), o %= DT, 0 > o && (o += DT), a %= DT, 0 > a && (a += DT), o > a && !r ? a += DT : a > o && r && (o += DT), r) {
            var d = a;
            a = o, o = d
        }
        for (var f = 0; a > f; f += Math.PI / 2) f > o && (kT[0] = AT(f) * i + t, kT[1] = TT(f) * n + e, u(s, kT, s), h(l, kT, l))
    }

    function Uo(t, e, i, n, o, a, r) {
        if (0 === o) return !1;
        var s = o, l = 0, u = t;
        if (r > e + s && r > n + s || e - s > r && n - s > r || a > t + s && a > i + s || t - s > a && i - s > a) return !1;
        if (t === i) return Math.abs(a - t) <= s / 2;
        l = (e - n) / (t - i), u = (t * n - i * e) / (t - i);
        var h = l * a - r + u, c = h * h / (l * l + 1);
        return s / 2 * s / 2 >= c
    }

    function Xo(t, e, i, n, o, a, r, s, l, u, h) {
        if (0 === l) return !1;
        var c = l;
        if (h > e + c && h > n + c && h > a + c && h > s + c || e - c > h && n - c > h && a - c > h && s - c > h || u > t + c && u > i + c && u > o + c && u > r + c || t - c > u && i - c > u && o - c > u && r - c > u) return !1;
        var d = Oo(t, e, i, n, o, a, r, s, u, h, null);
        return c / 2 >= d
    }

    function Yo(t, e, i, n, o, a, r, s, l) {
        if (0 === r) return !1;
        var u = r;
        if (l > e + u && l > n + u && l > a + u || e - u > l && n - u > l && a - u > l || s > t + u && s > i + u && s > o + u || t - u > s && i - u > s && o - u > s) return !1;
        var h = Vo(t, e, i, n, o, a, s, l, null);
        return u / 2 >= h
    }

    function jo(t) {
        return t %= YT, 0 > t && (t += YT), t
    }

    function qo(t, e, i, n, o, a, r, s, l) {
        if (0 === r) return !1;
        var u = r;
        s -= t, l -= e;
        var h = Math.sqrt(s * s + l * l);
        if (h - u > i || i > h + u) return !1;
        if (Math.abs(n - o) % jT < 1e-4) return !0;
        if (a) {
            var c = n;
            n = jo(o), o = jo(c)
        } else n = jo(n), o = jo(o);
        n > o && (o += jT);
        var d = Math.atan2(l, s);
        return 0 > d && (d += jT), d >= n && o >= d || d + jT >= n && o >= d + jT
    }

    function Ko(t, e, i, n, o, a) {
        if (a > e && a > n || e > a && n > a) return 0;
        if (n === e) return 0;
        var r = e > n ? 1 : -1, s = (a - e) / (n - e);
        (1 === s || 0 === s) && (r = e > n ? .5 : -.5);
        var l = s * (i - t) + t;
        return l === o ? 1 / 0 : l > o ? r : 0
    }

    function $o(t, e) {
        return Math.abs(t - e) < $T
    }

    function Jo() {
        var t = QT[0];
        QT[0] = QT[1], QT[1] = t
    }

    function Qo(t, e, i, n, o, a, r, s, l, u) {
        if (u > e && u > n && u > a && u > s || e > u && n > u && a > u && s > u) return 0;
        var h = Lo(e, n, a, s, u, JT);
        if (0 === h) return 0;
        for (var c, d, f = 0, p = -1, g = 0; h > g; g++) {
            var m = JT[g], v = 0 === m || 1 === m ? .5 : 1, y = Do(t, i, o, r, m);
            l > y || (0 > p && (p = ko(e, n, a, s, QT), QT[1] < QT[0] && p > 1 && Jo(), c = Do(e, n, a, s, QT[0]), p > 1 && (d = Do(e, n, a, s, QT[1]))), f += 2 === p ? m < QT[0] ? e > c ? v : -v : m < QT[1] ? c > d ? v : -v : d > s ? v : -v : m < QT[0] ? e > c ? v : -v : c > s ? v : -v)
        }
        return f
    }

    function ta(t, e, i, n, o, a, r, s) {
        if (s > e && s > n && s > a || e > s && n > s && a > s) return 0;
        var l = Ro(e, n, a, s, JT);
        if (0 === l) return 0;
        var u = zo(e, n, a);
        if (u >= 0 && 1 >= u) {
            for (var h = 0, c = Eo(e, n, a, u), d = 0; l > d; d++) {
                var f = 0 === JT[d] || 1 === JT[d] ? .5 : 1, p = Eo(t, i, o, JT[d]);
                r > p || (h += JT[d] < u ? e > c ? f : -f : c > a ? f : -f)
            }
            return h
        }
        var f = 0 === JT[0] || 1 === JT[0] ? .5 : 1, p = Eo(t, i, o, JT[0]);
        return r > p ? 0 : e > a ? f : -f
    }

    function ea(t, e, i, n, o, a, r, s) {
        if (s -= e, s > i || -i > s) return 0;
        var l = Math.sqrt(i * i - s * s);
        JT[0] = -l, JT[1] = l;
        var u = Math.abs(n - o);
        if (1e-4 > u) return 0;
        if (1e-4 > u % KT) {
            n = 0, o = KT;
            var h = a ? 1 : -1;
            return r >= JT[0] + t && r <= JT[1] + t ? h : 0
        }
        if (a) {
            var l = n;
            n = jo(o), o = jo(l)
        } else n = jo(n), o = jo(o);
        n > o && (o += KT);
        for (var c = 0, d = 0; 2 > d; d++) {
            var f = JT[d];
            if (f + t > r) {
                var p = Math.atan2(s, f), h = a ? 1 : -1;
                0 > p && (p = KT + p), (p >= n && o >= p || p + KT >= n && o >= p + KT) && (p > Math.PI / 2 && p < 1.5 * Math.PI && (h = -h), c += h)
            }
        }
        return c
    }

    function ia(t, e, i, n, o) {
        for (var a = 0, r = 0, s = 0, l = 0, u = 0, h = 0; h < t.length;) {
            var c = t[h++];
            switch (c === qT.M && h > 1 && (i || (a += Ko(r, s, l, u, n, o))), 1 === h && (r = t[h], s = t[h + 1], l = r, u = s), c) {
                case qT.M:
                    l = t[h++], u = t[h++], r = l, s = u;
                    break;
                case qT.L:
                    if (i) {
                        if (Uo(r, s, t[h], t[h + 1], e, n, o)) return !0
                    } else a += Ko(r, s, t[h], t[h + 1], n, o) || 0;
                    r = t[h++], s = t[h++];
                    break;
                case qT.C:
                    if (i) {
                        if (Xo(r, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], e, n, o)) return !0
                    } else a += Qo(r, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], n, o) || 0;
                    r = t[h++], s = t[h++];
                    break;
                case qT.Q:
                    if (i) {
                        if (Yo(r, s, t[h++], t[h++], t[h], t[h + 1], e, n, o)) return !0
                    } else a += ta(r, s, t[h++], t[h++], t[h], t[h + 1], n, o) || 0;
                    r = t[h++], s = t[h++];
                    break;
                case qT.A:
                    var d = t[h++], f = t[h++], p = t[h++], g = t[h++], m = t[h++], v = t[h++];
                    h += 1;
                    var y = 1 - t[h++], x = Math.cos(m) * p + d, _ = Math.sin(m) * g + f;
                    h > 1 ? a += Ko(r, s, x, _, n, o) : (l = x, u = _);
                    var w = (n - d) * g / p + d;
                    if (i) {
                        if (qo(d, f, g, m, m + v, y, e, w, o)) return !0
                    } else a += ea(d, f, g, m, m + v, y, w, o);
                    r = Math.cos(m + v) * p + d, s = Math.sin(m + v) * g + f;
                    break;
                case qT.R:
                    l = r = t[h++], u = s = t[h++];
                    var b = t[h++], S = t[h++], x = l + b, _ = u + S;
                    if (i) {
                        if (Uo(l, u, x, u, e, n, o) || Uo(x, u, x, _, e, n, o) || Uo(x, _, l, _, e, n, o) || Uo(l, _, l, u, e, n, o)) return !0
                    } else a += Ko(x, u, x, _, n, o), a += Ko(l, _, l, u, n, o);
                    break;
                case qT.Z:
                    if (i) {
                        if (Uo(r, s, l, u, e, n, o)) return !0
                    } else a += Ko(r, s, l, u, n, o);
                    r = l, s = u
            }
        }
        return i || $o(s, u) || (a += Ko(r, s, l, u, n, o) || 0), 0 !== a
    }

    function na(t, e, i) {
        return ia(t, 0, !1, e, i)
    }

    function oa(t, e, i, n) {
        return ia(t, e, !0, i, n)
    }

    function aa(t) {
        Dn.call(this, t), this.path = null
    }

    function ra(t, e, i, n, o, a, r, s, l, u, h) {
        var c = l * (cA / 180), d = hA(c) * (t - i) / 2 + uA(c) * (e - n) / 2,
            f = -1 * uA(c) * (t - i) / 2 + hA(c) * (e - n) / 2, p = d * d / (r * r) + f * f / (s * s);
        p > 1 && (r *= lA(p), s *= lA(p));
        var g = (o === a ? -1 : 1) * lA((r * r * s * s - r * r * f * f - s * s * d * d) / (r * r * f * f + s * s * d * d)) || 0,
            m = g * r * f / s, v = g * -s * d / r, y = (t + i) / 2 + hA(c) * m - uA(c) * v,
            x = (e + n) / 2 + uA(c) * m + hA(c) * v, _ = pA([1, 0], [(d - m) / r, (f - v) / s]),
            w = [(d - m) / r, (f - v) / s], b = [(-1 * d - m) / r, (-1 * f - v) / s], S = pA(w, b);
        fA(w, b) <= -1 && (S = cA), fA(w, b) >= 1 && (S = 0), 0 === a && S > 0 && (S -= 2 * cA), 1 === a && 0 > S && (S += 2 * cA), h.addData(u, y, x, r, s, _, S, c, a)
    }

    function sa(t) {
        if (!t) return new XT;
        for (var e, i = 0, n = 0, o = i, a = n, r = new XT, s = XT.CMD, l = t.match(gA), u = 0; u < l.length; u++) {
            for (var h, c = l[u], d = c.charAt(0), f = c.match(mA) || [], p = f.length, g = 0; p > g; g++) f[g] = parseFloat(f[g]);
            for (var m = 0; p > m;) {
                var v, y, x, _, w, b, S, M = i, I = n;
                switch (d) {
                    case"l":
                        i += f[m++], n += f[m++], h = s.L, r.addData(h, i, n);
                        break;
                    case"L":
                        i = f[m++], n = f[m++], h = s.L, r.addData(h, i, n);
                        break;
                    case"m":
                        i += f[m++], n += f[m++], h = s.M, r.addData(h, i, n), o = i, a = n, d = "l";
                        break;
                    case"M":
                        i = f[m++], n = f[m++], h = s.M, r.addData(h, i, n), o = i, a = n, d = "L";
                        break;
                    case"h":
                        i += f[m++], h = s.L, r.addData(h, i, n);
                        break;
                    case"H":
                        i = f[m++], h = s.L, r.addData(h, i, n);
                        break;
                    case"v":
                        n += f[m++], h = s.L, r.addData(h, i, n);
                        break;
                    case"V":
                        n = f[m++], h = s.L, r.addData(h, i, n);
                        break;
                    case"C":
                        h = s.C, r.addData(h, f[m++], f[m++], f[m++], f[m++], f[m++], f[m++]), i = f[m - 2], n = f[m - 1];
                        break;
                    case"c":
                        h = s.C, r.addData(h, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n), i += f[m - 2], n += f[m - 1];
                        break;
                    case"S":
                        v = i, y = n;
                        var T = r.len(), A = r.data;
                        e === s.C && (v += i - A[T - 4], y += n - A[T - 3]), h = s.C, M = f[m++], I = f[m++], i = f[m++], n = f[m++], r.addData(h, v, y, M, I, i, n);
                        break;
                    case"s":
                        v = i, y = n;
                        var T = r.len(), A = r.data;
                        e === s.C && (v += i - A[T - 4], y += n - A[T - 3]), h = s.C, M = i + f[m++], I = n + f[m++], i += f[m++], n += f[m++], r.addData(h, v, y, M, I, i, n);
                        break;
                    case"Q":
                        M = f[m++], I = f[m++], i = f[m++], n = f[m++], h = s.Q, r.addData(h, M, I, i, n);
                        break;
                    case"q":
                        M = f[m++] + i, I = f[m++] + n, i += f[m++], n += f[m++], h = s.Q, r.addData(h, M, I, i, n);
                        break;
                    case"T":
                        v = i, y = n;
                        var T = r.len(), A = r.data;
                        e === s.Q && (v += i - A[T - 4], y += n - A[T - 3]), i = f[m++], n = f[m++], h = s.Q, r.addData(h, v, y, i, n);
                        break;
                    case"t":
                        v = i, y = n;
                        var T = r.len(), A = r.data;
                        e === s.Q && (v += i - A[T - 4], y += n - A[T - 3]), i += f[m++], n += f[m++], h = s.Q, r.addData(h, v, y, i, n);
                        break;
                    case"A":
                        x = f[m++], _ = f[m++], w = f[m++], b = f[m++], S = f[m++], M = i, I = n, i = f[m++], n = f[m++], h = s.A, ra(M, I, i, n, b, S, x, _, w, h, r);
                        break;
                    case"a":
                        x = f[m++], _ = f[m++], w = f[m++], b = f[m++], S = f[m++], M = i, I = n, i += f[m++], n += f[m++], h = s.A, ra(M, I, i, n, b, S, x, _, w, h, r)
                }
            }
            ("z" === d || "Z" === d) && (h = s.Z, r.addData(h), i = o, n = a), e = h
        }
        return r.toStatic(), r
    }

    function la(t, e) {
        var i = sa(t);
        return e = e || {}, e.buildPath = function (t) {
            if (t.setData) {
                t.setData(i.data);
                var e = t.getContext();
                e && t.rebuildPath(e)
            } else {
                var e = t;
                i.rebuildPath(e)
            }
        }, e.applyTransform = function (t) {
            sA(i, t), this.dirty(!0)
        }, e
    }

    function ua(t, e) {
        return new aa(la(t, e))
    }

    function ha(t, e) {
        return aa.extend(la(t, e))
    }

    function ca(t, e) {
        for (var i = [], n = t.length, o = 0; n > o; o++) {
            var a = t[o];
            a.path || a.createPathProxy(), a.__dirtyPath && a.buildPath(a.path, a.shape, !0), i.push(a.path)
        }
        var r = new aa(e);
        return r.createPathProxy(), r.buildPath = function (t) {
            t.appendPath(i);
            var e = t.getContext();
            e && t.rebuildPath(e)
        }, r
    }

    function da(t, e, i, n, o, a, r) {
        var s = .5 * (i - t), l = .5 * (n - e);
        return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * a + s * o + e
    }

    function fa(t, e, i) {
        var n = e.points, o = e.smooth;
        if (n && n.length >= 2) {
            if (o && "spline" !== o) {
                var a = MA(n, o, i, e.smoothConstraint);
                t.moveTo(n[0][0], n[0][1]);
                for (var r = n.length, s = 0; (i ? r : r - 1) > s; s++) {
                    var l = a[2 * s], u = a[2 * s + 1], h = n[(s + 1) % r];
                    t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1])
                }
            } else {
                "spline" === o && (n = SA(n, i)), t.moveTo(n[0][0], n[0][1]);
                for (var s = 1, c = n.length; c > s; s++) t.lineTo(n[s][0], n[s][1])
            }
            i && t.closePath()
        }
    }

    function pa(t, e, i) {
        if (e) {
            var n = e.x1, o = e.x2, a = e.y1, r = e.y2;
            t.x1 = n, t.x2 = o, t.y1 = a, t.y2 = r;
            var s = i && i.lineWidth;
            s && (AA(2 * n) === AA(2 * o) && (t.x1 = t.x2 = ma(n, s, !0)), AA(2 * a) === AA(2 * r) && (t.y1 = t.y2 = ma(a, s, !0)))
        }
    }

    function ga(t, e, i) {
        if (e) {
            var n = e.x, o = e.y, a = e.width, r = e.height;
            t.x = n, t.y = o, t.width = a, t.height = r;
            var s = i && i.lineWidth;
            s && (t.x = ma(n, s, !0), t.y = ma(o, s, !0), t.width = Math.max(ma(n + a, s, !1) - t.x, 0 === a ? 0 : 1), t.height = Math.max(ma(o + r, s, !1) - t.y, 0 === r ? 0 : 1))
        }
    }

    function ma(t, e, i) {
        if (!e) return t;
        var n = AA(2 * t);
        return (n + AA(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
    }

    function va(t, e, i) {
        var n = t.cpx2, o = t.cpy2;
        return null === n || null === o ? [(i ? Co : Do)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? Co : Do)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? No : Eo)(t.x1, t.cpx1, t.x2, e), (i ? No : Eo)(t.y1, t.cpy1, t.y2, e)]
    }

    function ya(t) {
        Dn.call(this, t), this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.notClear = !0
    }

    function xa(t) {
        return aa.extend(t)
    }

    function _a(t, e) {
        return ha(t, e)
    }

    function wa(t, e) {
        qA[t] = e
    }

    function ba(t) {
        return qA.hasOwnProperty(t) ? qA[t] : void 0
    }

    function Sa(t, e, i, n) {
        var o = ua(t, e);
        return i && ("center" === n && (i = Ia(i, o.getBoundingRect())), Ta(o, i)), o
    }

    function Ma(t, e, i) {
        var n = new Cn({
            style: {image: t, x: e.x, y: e.y, width: e.width, height: e.height}, onload: function (t) {
                if ("center" === i) {
                    var o = {width: t.width, height: t.height};
                    n.setStyle(Ia(e, o))
                }
            }
        });
        return n
    }

    function Ia(t, e) {
        var i, n = e.width / e.height, o = t.height * n;
        o <= t.width ? i = t.height : (o = t.width, i = o / n);
        var a = t.x + t.width / 2, r = t.y + t.height / 2;
        return {x: a - o / 2, y: r - i / 2, width: o, height: i}
    }

    function Ta(t, e) {
        if (t.applyTransform) {
            var i = t.getBoundingRect(), n = i.calculateTransform(e);
            t.applyTransform(n)
        }
    }

    function Aa(t) {
        return pa(t.shape, t.shape, t.style), t
    }

    function Da(t) {
        return ga(t.shape, t.shape, t.style), t
    }

    function Ca(t) {
        return null != t && "none" !== t
    }

    function La(t) {
        if ("string" != typeof t) return t;
        var e = JA.get(t);
        return e || (e = ni(t, -.1), 1e4 > QA && (JA.set(t, e), QA++)), e
    }

    function ka(t) {
        if (t.__hoverStlDirty) {
            t.__hoverStlDirty = !1;
            var e = t.__hoverStl;
            if (!e) return void (t.__cachedNormalStl = t.__cachedNormalZ2 = null);
            var i = t.__cachedNormalStl = {};
            t.__cachedNormalZ2 = t.z2;
            var n = t.style;
            for (var o in e) null != e[o] && (i[o] = n[o]);
            i.fill = n.fill, i.stroke = n.stroke
        }
    }

    function Pa(t) {
        var e = t.__hoverStl;
        if (e && !t.__highlighted) {
            var i = t.__zr, n = t.useHoverLayer && i && "canvas" === i.painter.type;
            if (t.__highlighted = n ? "layer" : "plain", !(t.isGroup || !i && t.useHoverLayer)) {
                var o = t, a = t.style;
                n && (o = i.addHover(t), a = o.style), er(a), n || ka(o), a.extendFrom(e), Oa(a, e, "fill"), Oa(a, e, "stroke"), tr(a), n || (t.dirty(!1), t.z2 += HA)
            }
        }
    }

    function Oa(t, e, i) {
        !Ca(e[i]) && Ca(t[i]) && (t[i] = La(t[i]))
    }

    function Ea(t) {
        var e = t.__highlighted;
        if (e && (t.__highlighted = !1, !t.isGroup)) if ("layer" === e) t.__zr && t.__zr.removeHover(t); else {
            var i = t.style, n = t.__cachedNormalStl;
            n && (er(i), t.setStyle(n), tr(i));
            var o = t.__cachedNormalZ2;
            null != o && t.z2 - o === HA && (t.z2 = o)
        }
    }

    function Na(t, e, i) {
        var n, o = XA, a = XA;
        t.__highlighted && (o = UA, n = !0), e(t, i), t.__highlighted && (a = UA, n = !0), t.isGroup && t.traverse(function (t) {
            !t.isGroup && e(t, i)
        }), n && t.__highDownOnUpdate && t.__highDownOnUpdate(o, a)
    }

    function Ra(t, e) {
        e = t.__hoverStl = e !== !1 && (t.hoverStyle || e || {}), t.__hoverStlDirty = !0, t.__highlighted && (t.__cachedNormalStl = null, Ea(t), Pa(t))
    }

    function za(t) {
        !Fa(this, t) && !this.__highByOuter && Na(this, Pa)
    }

    function Ba(t) {
        !Fa(this, t) && !this.__highByOuter && Na(this, Ea)
    }

    function Va(t) {
        this.__highByOuter |= 1 << (t || 0), Na(this, Pa)
    }

    function Ga(t) {
        !(this.__highByOuter &= ~(1 << (t || 0))) && Na(this, Ea)
    }

    function Fa(t, e) {
        return t.__highDownSilentOnTouch && e.zrByTouch
    }

    function Wa(t, e) {
        Ha(t, !0), Na(t, Ra, e)
    }

    function Ha(t, e) {
        var i = e === !1;
        if (t.__highDownSilentOnTouch = t.highDownSilentOnTouch, t.__highDownOnUpdate = t.highDownOnUpdate, !i || t.__highDownDispatcher) {
            var n = i ? "off" : "on";
            t[n]("mouseover", za)[n]("mouseout", Ba), t[n]("emphasis", Va)[n]("normal", Ga), t.__highByOuter = t.__highByOuter || 0, t.__highDownDispatcher = !i
        }
    }

    function Za(t) {
        return !(!t || !t.__highDownDispatcher)
    }

    function Ua(t) {
        var e = jA[t];
        return null == e && 32 >= YA && (e = jA[t] = YA++), e
    }

    function Xa(t, e, i, n, o, a, r) {
        o = o || WA;
        var s, l = o.labelFetcher, u = o.labelDataIndex, h = o.labelDimIndex, c = o.labelProp, d = i.getShallow("show"),
            f = n.getShallow("show");
        (d || f) && (l && (s = l.getFormattedLabel(u, "normal", null, h, c)), null == s && (s = w(o.defaultText) ? o.defaultText(u, o) : o.defaultText));
        var p = d ? s : null, g = f ? C(l ? l.getFormattedLabel(u, "emphasis", null, h, c) : null, s) : null;
        (null != p || null != g) && (ja(t, i, a, o), ja(e, n, r, o, !0)), t.text = p, e.text = g
    }

    function Ya(t, e, i) {
        var n = t.style;
        e && (er(n), t.setStyle(e), tr(n)), n = t.__hoverStl, i && n && (er(n), r(n, i), tr(n))
    }

    function ja(t, e, i, n, o) {
        return Ka(t, e, n, o), i && r(t, i), t
    }

    function qa(t, e, i) {
        var n, o = {isRectText: !0};
        i === !1 ? n = !0 : o.autoColor = i, Ka(t, e, o, n)
    }

    function Ka(t, e, i, n) {
        if (i = i || WA, i.isRectText) {
            var o;
            i.getTextPosition ? o = i.getTextPosition(e, n) : (o = e.getShallow("position") || (n ? null : "inside"), "outside" === o && (o = "top")), t.textPosition = o, t.textOffset = e.getShallow("offset");
            var a = e.getShallow("rotate");
            null != a && (a *= Math.PI / 180), t.textRotation = a, t.textDistance = C(e.getShallow("distance"), n ? null : 5)
        }
        var r, s = e.ecModel, l = s && s.option.textStyle, u = $a(e);
        if (u) {
            r = {};
            for (var h in u) if (u.hasOwnProperty(h)) {
                var c = e.getModel(["rich", h]);
                Ja(r[h] = {}, c, l, i, n)
            }
        }
        return t.rich = r, Ja(t, e, l, i, n, !0), i.forceRich && !i.textStyle && (i.textStyle = {}), t
    }

    function $a(t) {
        for (var e; t && t !== t.ecModel;) {
            var i = (t.option || WA).rich;
            if (i) {
                e = e || {};
                for (var n in i) i.hasOwnProperty(n) && (e[n] = 1)
            }
            t = t.parentModel
        }
        return e
    }

    function Ja(t, e, i, n, o, a) {
        i = !o && i || WA, t.textFill = Qa(e.getShallow("color"), n) || i.color, t.textStroke = Qa(e.getShallow("textBorderColor"), n) || i.textBorderColor, t.textStrokeWidth = C(e.getShallow("textBorderWidth"), i.textBorderWidth), o || (a && (t.insideRollbackOpt = n, tr(t)), null == t.textFill && (t.textFill = n.autoColor)), t.fontStyle = e.getShallow("fontStyle") || i.fontStyle, t.fontWeight = e.getShallow("fontWeight") || i.fontWeight, t.fontSize = e.getShallow("fontSize") || i.fontSize, t.fontFamily = e.getShallow("fontFamily") || i.fontFamily, t.textAlign = e.getShallow("align"), t.textVerticalAlign = e.getShallow("verticalAlign") || e.getShallow("baseline"), t.textLineHeight = e.getShallow("lineHeight"), t.textWidth = e.getShallow("width"), t.textHeight = e.getShallow("height"), t.textTag = e.getShallow("tag"), a && n.disableBox || (t.textBackgroundColor = Qa(e.getShallow("backgroundColor"), n), t.textPadding = e.getShallow("padding"), t.textBorderColor = Qa(e.getShallow("borderColor"), n), t.textBorderWidth = e.getShallow("borderWidth"), t.textBorderRadius = e.getShallow("borderRadius"), t.textBoxShadowColor = e.getShallow("shadowColor"), t.textBoxShadowBlur = e.getShallow("shadowBlur"), t.textBoxShadowOffsetX = e.getShallow("shadowOffsetX"), t.textBoxShadowOffsetY = e.getShallow("shadowOffsetY")), t.textShadowColor = e.getShallow("textShadowColor") || i.textShadowColor, t.textShadowBlur = e.getShallow("textShadowBlur") || i.textShadowBlur, t.textShadowOffsetX = e.getShallow("textShadowOffsetX") || i.textShadowOffsetX, t.textShadowOffsetY = e.getShallow("textShadowOffsetY") || i.textShadowOffsetY
    }

    function Qa(t, e) {
        return "auto" !== t ? t : e && e.autoColor ? e.autoColor : null
    }

    function tr(t) {
        var e, i = t.textPosition, n = t.insideRollbackOpt;
        if (n && null == t.textFill) {
            var o = n.autoColor, a = n.isRectText, r = n.useInsideStyle,
                s = r !== !1 && (r === !0 || a && i && "string" == typeof i && i.indexOf("inside") >= 0),
                l = !s && null != o;
            (s || l) && (e = {
                textFill: t.textFill,
                textStroke: t.textStroke,
                textStrokeWidth: t.textStrokeWidth
            }), s && (t.textFill = "#fff", null == t.textStroke && (t.textStroke = o, null == t.textStrokeWidth && (t.textStrokeWidth = 2))), l && (t.textFill = o)
        }
        t.insideRollback = e
    }

    function er(t) {
        var e = t.insideRollback;
        e && (t.textFill = e.textFill, t.textStroke = e.textStroke, t.textStrokeWidth = e.textStrokeWidth, t.insideRollback = null)
    }

    function ir(t, e) {
        var i = e && e.getModel("textStyle");
        return E([t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", (t.fontSize || i && i.getShallow("fontSize") || 12) + "px", t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"].join(" "))
    }

    function nr(t, e, i, n, o, a) {
        "function" == typeof o && (a = o, o = null);
        var r = n && n.isAnimationEnabled();
        if (r) {
            var s = t ? "Update" : "", l = n.getShallow("animationDuration" + s),
                u = n.getShallow("animationEasing" + s), h = n.getShallow("animationDelay" + s);
            "function" == typeof h && (h = h(o, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, o) : null)), "function" == typeof l && (l = l(o)), l > 0 ? e.animateTo(i, l, h || 0, u, a, !!a) : (e.stopAnimation(), e.attr(i), a && a())
        } else e.stopAnimation(), e.attr(i), a && a()
    }

    function or(t, e, i, n, o) {
        nr(!0, t, e, i, n, o)
    }

    function ar(t, e, i, n, o) {
        nr(!1, t, e, i, n, o)
    }

    function rr(t, e) {
        for (var i = Ee([]); t && t !== e;) Re(i, t.getLocalTransform(), i), t = t.parent;
        return i
    }

    function sr(t, e, i) {
        return e && !d(e) && (e = AM.getLocalTransform(e)), i && (e = Ge([], e)), ae([], t, e)
    }

    function lr(t, e, i) {
        var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
            o = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
            a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -o : "bottom" === t ? o : 0];
        return a = sr(a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top"
    }

    function ur(t, e, i) {
        function n(t) {
            var e = {};
            return t.traverse(function (t) {
                !t.isGroup && t.anid && (e[t.anid] = t)
            }), e
        }

        function o(t) {
            var e = {position: H(t.position), rotation: t.rotation};
            return t.shape && (e.shape = r({}, t.shape)), e
        }

        if (t && e) {
            var a = n(t);
            e.traverse(function (t) {
                if (!t.isGroup && t.anid) {
                    var e = a[t.anid];
                    if (e) {
                        var n = o(t);
                        t.attr(o(e)), or(t, n, i, t.dataIndex)
                    }
                }
            })
        }
    }

    function hr(t, e) {
        return p(t, function (t) {
            var i = t[0];
            i = GA(i, e.x), i = FA(i, e.x + e.width);
            var n = t[1];
            return n = GA(n, e.y), n = FA(n, e.y + e.height), [i, n]
        })
    }

    function cr(t, e) {
        var i = GA(t.x, e.x), n = FA(t.x + t.width, e.x + e.width), o = GA(t.y, e.y),
            a = FA(t.y + t.height, e.y + e.height);
        return n >= i && a >= o ? {x: i, y: o, width: n - i, height: a - o} : void 0
    }

    function dr(t, e, i) {
        e = r({rectHover: !0}, e);
        var n = e.style = {strokeNoScale: !0};
        return i = i || {
            x: -1,
            y: -1,
            width: 2,
            height: 2
        }, t ? 0 === t.indexOf("image://") ? (n.image = t.slice(8), s(n, i), new Cn(e)) : Sa(t.replace("path://", ""), e, i, "center") : void 0
    }

    function fr(t, e, i, n, o) {
        for (var a = 0, r = o[o.length - 1]; a < o.length; a++) {
            var s = o[a];
            if (pr(t, e, i, n, s[0], s[1], r[0], r[1])) return !0;
            r = s
        }
    }

    function pr(t, e, i, n, o, a, r, s) {
        var l = i - t, u = n - e, h = r - o, c = s - a, d = gr(h, c, l, u);
        if (mr(d)) return !1;
        var f = t - o, p = e - a, g = gr(f, p, l, u) / d;
        if (0 > g || g > 1) return !1;
        var m = gr(f, p, h, c) / d;
        return 0 > m || m > 1 ? !1 : !0
    }

    function gr(t, e, i, n) {
        return t * n - i * e
    }

    function mr(t) {
        return 1e-6 >= t && t >= -1e-6
    }

    function vr(t, e, i) {
        this.parentModel = e, this.ecModel = i, this.option = t
    }

    function yr(t, e, i) {
        for (var n = 0; n < e.length && (!e[n] || (t = t && "object" == typeof t ? t[e[n]] : null, null != t)); n++) ;
        return null == t && i && (t = i.get(e)), t
    }

    function xr(t, e) {
        var i = rD(t).getParent;
        return i ? i.call(t, e) : t.parentModel
    }

    function _r(t) {
        return [t || "", sD++, Math.random().toFixed(5)].join("_")
    }

    function wr(t) {
        var e = {};
        return t.registerSubTypeDefaulter = function (t, i) {
            t = xo(t), e[t.main] = i
        }, t.determineSubType = function (i, n) {
            var o = n.type;
            if (!o) {
                var a = xo(i).main;
                t.hasSubTypes(i) && e[a] && (o = e[a](n))
            }
            return o
        }, t
    }

    function br(t, e) {
        function i(t) {
            var i = {}, a = [];
            return f(t, function (r) {
                var s = n(i, r), l = s.originalDeps = e(r), h = o(l, t);
                s.entryCount = h.length, 0 === s.entryCount && a.push(r), f(h, function (t) {
                    u(s.predecessor, t) < 0 && s.predecessor.push(t);
                    var e = n(i, t);
                    u(e.successor, t) < 0 && e.successor.push(r)
                })
            }), {graph: i, noEntryList: a}
        }

        function n(t, e) {
            return t[e] || (t[e] = {predecessor: [], successor: []}), t[e]
        }

        function o(t, e) {
            var i = [];
            return f(t, function (t) {
                u(e, t) >= 0 && i.push(t)
            }), i
        }

        t.topologicalTravel = function (t, e, n, o) {
            function a(t) {
                l[t].entryCount--, 0 === l[t].entryCount && u.push(t)
            }

            function r(t) {
                h[t] = !0, a(t)
            }

            if (t.length) {
                var s = i(e), l = s.graph, u = s.noEntryList, h = {};
                for (f(t, function (t) {
                    h[t] = !0
                }); u.length;) {
                    var c = u.pop(), d = l[c], p = !!h[c];
                    p && (n.call(o, c, d.originalDeps.slice()), delete h[c]), f(d.successor, p ? r : a)
                }
                f(h, function () {
                    throw new Error("Circle dependency may exists")
                })
            }
        }
    }

    function Sr(t) {
        return t.replace(/^\s+|\s+$/g, "")
    }

    function Mr(t, e, i, n) {
        var o = e[1] - e[0], a = i[1] - i[0];
        if (0 === o) return 0 === a ? i[0] : (i[0] + i[1]) / 2;
        if (n) if (o > 0) {
            if (t <= e[0]) return i[0];
            if (t >= e[1]) return i[1]
        } else {
            if (t >= e[0]) return i[0];
            if (t <= e[1]) return i[1]
        } else {
            if (t === e[0]) return i[0];
            if (t === e[1]) return i[1]
        }
        return (t - e[0]) / o * a + i[0]
    }

    function Ir(t, e) {
        switch (t) {
            case"center":
            case"middle":
                t = "50%";
                break;
            case"left":
            case"top":
                t = "0%";
                break;
            case"right":
            case"bottom":
                t = "100%"
        }
        return "string" == typeof t ? Sr(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? 0 / 0 : +t
    }

    function Tr(t, e, i) {
        return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), i ? t : +t
    }

    function Ar(t) {
        return t.sort(function (t, e) {
            return t - e
        }), t
    }

    function Dr(t) {
        if (t = +t, isNaN(t)) return 0;
        for (var e = 1, i = 0; Math.round(t * e) / e !== t;) e *= 10, i++;
        return i
    }

    function Cr(t) {
        var e = t.toString(), i = e.indexOf("e");
        if (i > 0) {
            var n = +e.slice(i + 1);
            return 0 > n ? -n : 0
        }
        var o = e.indexOf(".");
        return 0 > o ? 0 : e.length - 1 - o
    }

    function Lr(t, e) {
        var i = Math.log, n = Math.LN10, o = Math.floor(i(t[1] - t[0]) / n),
            a = Math.round(i(Math.abs(e[1] - e[0])) / n), r = Math.min(Math.max(-o + a, 0), 20);
        return isFinite(r) ? r : 20
    }

    function kr(t, e, i) {
        if (!t[e]) return 0;
        var n = g(t, function (t, e) {
            return t + (isNaN(e) ? 0 : e)
        }, 0);
        if (0 === n) return 0;
        for (var o = Math.pow(10, i), a = p(t, function (t) {
            return (isNaN(t) ? 0 : t) / n * o * 100
        }), r = 100 * o, s = p(a, function (t) {
            return Math.floor(t)
        }), l = g(s, function (t, e) {
            return t + e
        }, 0), u = p(a, function (t, e) {
            return t - s[e]
        }); r > l;) {
            for (var h = Number.NEGATIVE_INFINITY, c = null, d = 0, f = u.length; f > d; ++d) u[d] > h && (h = u[d], c = d);
            ++s[c], u[c] = 0, ++l
        }
        return s[e] / o
    }

    function Pr(t) {
        var e = 2 * Math.PI;
        return (t % e + e) % e
    }

    function Or(t) {
        return t > -lD && lD > t
    }

    function Er(t) {
        if (t instanceof Date) return t;
        if ("string" == typeof t) {
            var e = hD.exec(t);
            if (!e) return new Date(0 / 0);
            if (e[8]) {
                var i = +e[4] || 0;
                return "Z" !== e[8].toUpperCase() && (i -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, +e[7] || 0))
            }
            return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0)
        }
        return new Date(null == t ? 0 / 0 : Math.round(t))
    }

    function Nr(t) {
        return Math.pow(10, Rr(t))
    }

    function Rr(t) {
        if (0 === t) return 0;
        var e = Math.floor(Math.log(t) / Math.LN10);
        return t / Math.pow(10, e) >= 10 && e++, e
    }

    function zr(t, e) {
        var i, n = Rr(t), o = Math.pow(10, n), a = t / o;
        return i = e ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, t = i * o, n >= -20 ? +t.toFixed(0 > n ? -n : 0) : t
    }

    function Br(t, e) {
        var i = (t.length - 1) * e + 1, n = Math.floor(i), o = +t[n - 1], a = i - n;
        return a ? o + a * (t[n] - o) : o
    }

    function Vr(t) {
        function e(t, i, n) {
            return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] === (n ? -1 : 1) || !n && e(t, i, 1))
        }

        t.sort(function (t, i) {
            return e(t, i, 0) ? -1 : 1
        });
        for (var i = -1 / 0, n = 1, o = 0; o < t.length;) {
            for (var a = t[o].interval, r = t[o].close, s = 0; 2 > s; s++) a[s] <= i && (a[s] = i, r[s] = s ? 1 : 1 - n), i = a[s], n = r[s];
            a[0] === a[1] && r[0] * r[1] !== 1 ? t.splice(o, 1) : o++
        }
        return t
    }

    function Gr(t) {
        return t - parseFloat(t) >= 0
    }

    function Fr(t) {
        return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : ""))
    }

    function Wr(t, e) {
        return t = (t || "").toLowerCase().replace(/-(.)/g, function (t, e) {
            return e.toUpperCase()
        }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t
    }

    function Hr(t) {
        return null == t ? "" : (t + "").replace(fD, function (t, e) {
            return pD[e]
        })
    }

    function Zr(t, e, i) {
        _(e) || (e = [e]);
        var n = e.length;
        if (!n) return "";
        for (var o = e[0].$vars || [], a = 0; a < o.length; a++) {
            var r = gD[a];
            t = t.replace(mD(r), mD(r, 0))
        }
        for (var s = 0; n > s; s++) for (var l = 0; l < o.length; l++) {
            var u = e[s][o[l]];
            t = t.replace(mD(gD[l], s), i ? Hr(u) : u)
        }
        return t
    }

    function Ur(t, e, i) {
        return f(e, function (e, n) {
            t = t.replace("{" + n + "}", i ? Hr(e) : e)
        }), t
    }

    function Xr(t, e) {
        t = b(t) ? {color: t, extraCssText: e} : t || {};
        var i = t.color, n = t.type, e = t.extraCssText, o = t.renderMode || "html", a = t.markerId || "X";
        return i ? "html" === o ? "subItem" === n ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Hr(i) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + Hr(i) + ";" + (e || "") + '"></span>' : {
            renderMode: o,
            content: "{marker" + a + "|}  ",
            style: {color: i}
        } : ""
    }

    function Yr(t, e) {
        return t += "", "0000".substr(0, e - t.length) + t
    }

    function jr(t, e, i) {
        ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
        var n = Er(e), o = i ? "UTC" : "", a = n["get" + o + "FullYear"](), r = n["get" + o + "Month"]() + 1,
            s = n["get" + o + "Date"](), l = n["get" + o + "Hours"](), u = n["get" + o + "Minutes"](),
            h = n["get" + o + "Seconds"](), c = n["get" + o + "Milliseconds"]();
        return t = t.replace("MM", Yr(r, 2)).replace("M", r).replace("yyyy", a).replace("yy", a % 100).replace("dd", Yr(s, 2)).replace("d", s).replace("hh", Yr(l, 2)).replace("h", l).replace("mm", Yr(u, 2)).replace("m", u).replace("ss", Yr(h, 2)).replace("s", h).replace("SSS", Yr(c, 3))
    }

    function qr(t) {
        return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
    }

    function Kr(t) {
        return Xi(t.text, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich, t.truncate)
    }

    function $r(t, e, i, n, o, a, r, s) {
        return Xi(t, e, i, n, o, s, a, r)
    }

    function Jr(t, e) {
        if ("_blank" === e || "blank" === e) {
            var i = window.open();
            i.opener = null, i.location = t
        } else window.open(t, e)
    }

    function Qr(t, e, i, n, o) {
        var a = 0, r = 0;
        null == n && (n = 1 / 0), null == o && (o = 1 / 0);
        var s = 0;
        e.eachChild(function (l, u) {
            var h, c, d = l.position, f = l.getBoundingRect(), p = e.childAt(u + 1), g = p && p.getBoundingRect();
            if ("horizontal" === t) {
                var m = f.width + (g ? -g.x + f.x : 0);
                h = a + m, h > n || l.newline ? (a = 0, h = m, r += s + i, s = f.height) : s = Math.max(s, f.height)
            } else {
                var v = f.height + (g ? -g.y + f.y : 0);
                c = r + v, c > o || l.newline ? (a += s + i, r = 0, c = v, s = f.width) : s = Math.max(s, f.width)
            }
            l.newline || (d[0] = a, d[1] = r, "horizontal" === t ? a = h + i : r = c + i)
        })
    }

    function ts(t, e, i) {
        var n = e.width, o = e.height, a = Ir(t.x, n), r = Ir(t.y, o), s = Ir(t.x2, n), l = Ir(t.y2, o);
        return (isNaN(a) || isNaN(parseFloat(t.x))) && (a = 0), (isNaN(s) || isNaN(parseFloat(t.x2))) && (s = n), (isNaN(r) || isNaN(parseFloat(t.y))) && (r = 0), (isNaN(l) || isNaN(parseFloat(t.y2))) && (l = o), i = dD(i || 0), {
            width: Math.max(s - a - i[1] - i[3], 0),
            height: Math.max(l - r - i[0] - i[2], 0)
        }
    }

    function es(t, e, i) {
        i = dD(i || 0);
        var n = e.width, o = e.height, a = Ir(t.left, n), r = Ir(t.top, o), s = Ir(t.right, n), l = Ir(t.bottom, o),
            u = Ir(t.width, n), h = Ir(t.height, o), c = i[2] + i[0], d = i[1] + i[3], f = t.aspect;
        switch (isNaN(u) && (u = n - s - d - a), isNaN(h) && (h = o - l - c - r), null != f && (isNaN(u) && isNaN(h) && (f > n / o ? u = .8 * n : h = .8 * o), isNaN(u) && (u = f * h), isNaN(h) && (h = u / f)), isNaN(a) && (a = n - s - u - d), isNaN(r) && (r = o - l - h - c), t.left || t.right) {
            case"center":
                a = n / 2 - u / 2 - i[3];
                break;
            case"right":
                a = n - u - d
        }
        switch (t.top || t.bottom) {
            case"middle":
            case"center":
                r = o / 2 - h / 2 - i[0];
                break;
            case"bottom":
                r = o - h - c
        }
        a = a || 0, r = r || 0, isNaN(u) && (u = n - d - a - (s || 0)), isNaN(h) && (h = o - c - r - (l || 0));
        var p = new Ti(a + i[3], r + i[0], u, h);
        return p.margin = i, p
    }

    function is(t, e, i, n, o) {
        var a = !o || !o.hv || o.hv[0], r = !o || !o.hv || o.hv[1], l = o && o.boundingMode || "all";
        if (a || r) {
            var u;
            if ("raw" === l) u = "group" === t.type ? new Ti(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect(); else if (u = t.getBoundingRect(), t.needLocalTransform()) {
                var h = t.getLocalTransform();
                u = u.clone(), u.applyTransform(h)
            }
            e = es(s({width: u.width, height: u.height}, e), i, n);
            var c = t.position, d = a ? e.x - u.x : 0, f = r ? e.y - u.y : 0;
            t.attr("position", "raw" === l ? [d, f] : [c[0] + d, c[1] + f])
        }
    }

    function ns(t, e) {
        return null != t[wD[e][0]] || null != t[wD[e][1]] && null != t[wD[e][2]]
    }

    function os(t, e, i) {
        function n(i, n) {
            var r = {}, l = 0, u = {}, h = 0, c = 2;
            if (xD(i, function (e) {
                u[e] = t[e]
            }), xD(i, function (t) {
                o(e, t) && (r[t] = u[t] = e[t]), a(r, t) && l++, a(u, t) && h++
            }), s[n]) return a(e, i[1]) ? u[i[2]] = null : a(e, i[2]) && (u[i[1]] = null), u;
            if (h !== c && l) {
                if (l >= c) return r;
                for (var d = 0; d < i.length; d++) {
                    var f = i[d];
                    if (!o(r, f) && o(t, f)) {
                        r[f] = t[f];
                        break
                    }
                }
                return r
            }
            return u
        }

        function o(t, e) {
            return t.hasOwnProperty(e)
        }

        function a(t, e) {
            return null != t[e] && "auto" !== t[e]
        }

        function r(t, e, i) {
            xD(t, function (t) {
                e[t] = i[t]
            })
        }

        !S(i) && (i = {});
        var s = i.ignoreSize;
        !_(s) && (s = [s, s]);
        var l = n(wD[0], 0), u = n(wD[1], 1);
        r(wD[0], t, l), r(wD[1], t, u)
    }

    function as(t) {
        return rs({}, t)
    }

    function rs(t, e) {
        return e && t && xD(_D, function (i) {
            e.hasOwnProperty(i) && (t[i] = e[i])
        }), t
    }

    function ss(t) {
        var e = [];
        return f(ID.getClassesByMainType(t), function (t) {
            e = e.concat(t.prototype.dependencies || [])
        }), e = p(e, function (t) {
            return xo(t).main
        }), "dataset" !== t && u(e, "dataset") <= 0 && e.unshift("dataset"), e
    }

    function ls(t, e) {
        for (var i = t.length, n = 0; i > n; n++) if (t[n].length > e) return t[n];
        return t[i - 1]
    }

    function us(t) {
        this.fromDataset = t.fromDataset, this.data = t.data || (t.sourceFormat === OD ? {} : []), this.sourceFormat = t.sourceFormat || ED, this.seriesLayoutBy = t.seriesLayoutBy || RD, this.dimensionsDefine = t.dimensionsDefine, this.encodeDefine = t.encodeDefine && B(t.encodeDefine), this.startIndex = t.startIndex || 0, this.dimensionsDetectCount = t.dimensionsDetectCount
    }

    function hs(t) {
        var e = t.option.source, i = ED;
        if (I(e)) i = ND; else if (_(e)) {
            0 === e.length && (i = kD);
            for (var n = 0, o = e.length; o > n; n++) {
                var a = e[n];
                if (null != a) {
                    if (_(a)) {
                        i = kD;
                        break
                    }
                    if (S(a)) {
                        i = PD;
                        break
                    }
                }
            }
        } else if (S(e)) {
            for (var r in e) if (e.hasOwnProperty(r) && d(e[r])) {
                i = OD;
                break
            }
        } else if (null != e) throw new Error("Invalid data");
        VD(t).sourceFormat = i
    }

    function cs(t) {
        return VD(t).source
    }

    function ds(t) {
        VD(t).datasetMap = B()
    }

    function fs(t) {
        var e = t.option, i = e.data, n = I(i) ? ND : LD, o = !1, a = e.seriesLayoutBy, r = e.sourceHeader,
            s = e.dimensions, l = _s(t);
        if (l) {
            var u = l.option;
            i = u.source, n = VD(l).sourceFormat, o = !0, a = a || u.seriesLayoutBy, null == r && (r = u.sourceHeader), s = s || u.dimensions
        }
        var h = ps(i, n, a, r, s);
        VD(t).source = new us({
            data: i,
            fromDataset: o,
            seriesLayoutBy: a,
            sourceFormat: n,
            dimensionsDefine: h.dimensionsDefine,
            startIndex: h.startIndex,
            dimensionsDetectCount: h.dimensionsDetectCount,
            encodeDefine: e.encode
        })
    }

    function ps(t, e, i, n, o) {
        if (!t) return {dimensionsDefine: gs(o)};
        var a, r;
        if (e === kD) "auto" === n || null == n ? ms(function (t) {
            null != t && "-" !== t && (b(t) ? null == r && (r = 1) : r = 0)
        }, i, t, 10) : r = n ? 1 : 0, o || 1 !== r || (o = [], ms(function (t, e) {
            o[e] = null != t ? t : ""
        }, i, t)), a = o ? o.length : i === zD ? t.length : t[0] ? t[0].length : null; else if (e === PD) o || (o = vs(t)); else if (e === OD) o || (o = [], f(t, function (t, e) {
            o.push(e)
        })); else if (e === LD) {
            var s = no(t[0]);
            a = _(s) && s.length || 1
        } else e === ND && BS && O(!!o, "dimensions must be given if data is TypedArray.");
        return {startIndex: r, dimensionsDefine: gs(o), dimensionsDetectCount: a}
    }

    function gs(t) {
        if (t) {
            var e = B();
            return p(t, function (t) {
                if (t = r({}, S(t) ? t : {name: t}), null == t.name) return t;
                t.name += "", null == t.displayName && (t.displayName = t.name);
                var i = e.get(t.name);
                return i ? t.name += "-" + i.count++ : e.set(t.name, {count: 1}), t
            })
        }
    }

    function ms(t, e, i, n) {
        if (null == n && (n = 1 / 0), e === zD) for (var o = 0; o < i.length && n > o; o++) t(i[o] ? i[o][0] : null, o); else for (var a = i[0] || [], o = 0; o < a.length && n > o; o++) t(a[o], o)
    }

    function vs(t) {
        for (var e, i = 0; i < t.length && !(e = t[i++]);) ;
        if (e) {
            var n = [];
            return f(e, function (t, e) {
                n.push(e)
            }), n
        }
    }

    function ys(t, e, i) {
        function n(t, e, i) {
            for (var n = 0; i > n; n++) t.push(e + n)
        }

        function o(t) {
            var e = t.dimsDef;
            return e ? e.length : 1
        }

        var a = {}, r = _s(e);
        if (!r || !t) return a;
        var s, l, u = [], h = [], c = e.ecModel, d = VD(c).datasetMap, p = r.uid + "_" + i.seriesLayoutBy;
        t = t.slice(), f(t, function (e, i) {
            !S(e) && (t[i] = {name: e}), "ordinal" === e.type && null == s && (s = i, l = o(t[i])), a[e.name] = []
        });
        var g = d.get(p) || d.set(p, {categoryWayDim: l, valueWayDim: 0});
        return f(t, function (t, e) {
            var i = t.name, r = o(t);
            if (null == s) {
                var l = g.valueWayDim;
                n(a[i], l, r), n(h, l, r), g.valueWayDim += r
            } else if (s === e) n(a[i], 0, r), n(u, 0, r); else {
                var l = g.categoryWayDim;
                n(a[i], l, r), n(h, l, r), g.categoryWayDim += r
            }
        }), u.length && (a.itemName = u), h.length && (a.seriesName = h), a
    }

    function xs(t, e, i) {
        var n = {}, o = _s(t);
        if (!o) return n;
        var a, r = e.sourceFormat, s = e.dimensionsDefine;
        (r === PD || r === OD) && f(s, function (t, e) {
            "name" === (S(t) ? t.name : t) && (a = e)
        });
        var l = function () {
            function t(t) {
                return null != t.v && null != t.n
            }

            for (var n = {}, o = {}, l = [], u = 0, h = Math.min(5, i); h > u; u++) {
                var c = bs(e.data, r, e.seriesLayoutBy, s, e.startIndex, u);
                l.push(c);
                var d = c === BD.Not;
                if (d && null == n.v && u !== a && (n.v = u), (null == n.n || n.n === n.v || !d && l[n.n] === BD.Not) && (n.n = u), t(n) && l[n.n] !== BD.Not) return n;
                d || (c === BD.Might && null == o.v && u !== a && (o.v = u), (null == o.n || o.n === o.v) && (o.n = u))
            }
            return t(n) ? n : t(o) ? o : null
        }();
        if (l) {
            n.value = l.v;
            var u = null != a ? a : l.n;
            n.itemName = [u], n.seriesName = [u]
        }
        return n
    }

    function _s(t) {
        var e = t.option, i = e.data;
        return i ? void 0 : t.ecModel.getComponent("dataset", e.datasetIndex || 0)
    }

    function ws(t, e) {
        return bs(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e)
    }

    function bs(t, e, i, n, o, a) {
        function r(t) {
            var e = b(t);
            return null != t && isFinite(t) && "" !== t ? e ? BD.Might : BD.Not : e && "-" !== t ? BD.Must : void 0
        }

        var s, l = 5;
        if (I(t)) return BD.Not;
        var u, h;
        if (n) {
            var c = n[a];
            S(c) ? (u = c.name, h = c.type) : b(c) && (u = c)
        }
        if (null != h) return "ordinal" === h ? BD.Must : BD.Not;
        if (e === kD) if (i === zD) {
            for (var d = t[a], f = 0; f < (d || []).length && l > f; f++) if (null != (s = r(d[o + f]))) return s
        } else for (var f = 0; f < t.length && l > f; f++) {
            var p = t[o + f];
            if (p && null != (s = r(p[a]))) return s
        } else if (e === PD) {
            if (!u) return BD.Not;
            for (var f = 0; f < t.length && l > f; f++) {
                var g = t[f];
                if (g && null != (s = r(g[u]))) return s
            }
        } else if (e === OD) {
            if (!u) return BD.Not;
            var d = t[u];
            if (!d || I(d)) return BD.Not;
            for (var f = 0; f < d.length && l > f; f++) if (null != (s = r(d[f]))) return s
        } else if (e === LD) for (var f = 0; f < t.length && l > f; f++) {
            var g = t[f], m = no(g);
            if (!_(m)) return BD.Not;
            if (null != (s = r(m[a]))) return s
        }
        return BD.Not
    }

    function Ss(t, e) {
        if (e) {
            var i = e.seiresIndex, n = e.seriesId, o = e.seriesName;
            return null != i && t.componentIndex !== i || null != n && t.id !== n || null != o && t.name !== o
        }
    }

    function Ms(t, e) {
        var i = t.color && !t.colorLayer;
        f(e, function (e, a) {
            "colorLayer" === a && i || ID.hasClass(a) || ("object" == typeof e ? t[a] = t[a] ? o(t[a], e, !1) : n(e) : null == t[a] && (t[a] = e))
        })
    }

    function Is(t) {
        t = t, this.option = {}, this.option[GD] = 1, this._componentsMap = B({series: []}), this._seriesIndices, this._seriesIndicesMap, Ms(t, this._theme.option), o(t, AD, !1), this.mergeOption(t)
    }

    function Ts(t, e) {
        _(e) || (e = e ? [e] : []);
        var i = {};
        return f(e, function (e) {
            i[e] = (t.get(e) || []).slice()
        }), i
    }

    function As(t, e, i) {
        var n = e.type ? e.type : i ? i.subType : ID.determineSubType(t, e);
        return n
    }

    function Ds(t, e) {
        t._seriesIndicesMap = B(t._seriesIndices = p(e, function (t) {
            return t.componentIndex
        }) || [])
    }

    function Cs(t, e) {
        return e.hasOwnProperty("subType") ? m(t, function (t) {
            return t.subType === e.subType
        }) : t
    }

    function Ls(t) {
        if (BS && !t._seriesIndices) throw new Error("Option should contains series.")
    }

    function ks(t) {
        f(WD, function (e) {
            this[e] = y(t[e], t)
        }, this)
    }

    function Ps() {
        this._coordinateSystems = []
    }

    function Os(t) {
        this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption
    }

    function Es(t, e, i) {
        var n, o, a = [], r = [], s = t.timeline;
        if (t.baseOption && (o = t.baseOption), (s || t.options) && (o = o || {}, a = (t.options || []).slice()), t.media) {
            o = o || {};
            var l = t.media;
            ZD(l, function (t) {
                t && t.option && (t.query ? r.push(t) : n || (n = t))
            })
        }
        return o || (o = t), o.timeline || (o.timeline = s), ZD([o].concat(a).concat(p(r, function (t) {
            return t.option
        })), function (t) {
            ZD(e, function (e) {
                e(t, i)
            })
        }), {baseOption: o, timelineOptions: a, mediaDefault: n, mediaList: r}
    }

    function Ns(t, e, i) {
        var n = {width: e, height: i, aspectratio: e / i}, o = !0;
        return f(t, function (t, e) {
            var i = e.match(jD);
            if (i && i[1] && i[2]) {
                var a = i[1], r = i[2].toLowerCase();
                Rs(n[r], t, a) || (o = !1)
            }
        }), o
    }

    function Rs(t, e, i) {
        return "min" === i ? t >= e : "max" === i ? e >= t : t === e
    }

    function zs(t, e) {
        return t.join(",") === e.join(",")
    }

    function Bs(t, e) {
        e = e || {}, ZD(e, function (e, i) {
            if (null != e) {
                var n = t[i];
                if (ID.hasClass(i)) {
                    e = eo(e), n = eo(n);
                    var o = ao(n, e);
                    t[i] = XD(o, function (t) {
                        return t.option && t.exist ? YD(t.exist, t.option, !0) : t.exist || t.option
                    })
                } else t[i] = YD(n, e, !0)
            }
        })
    }

    function Vs(t) {
        var e = t && t.itemStyle;
        if (e) for (var i = 0, n = $D.length; n > i; i++) {
            var a = $D[i], r = e.normal, s = e.emphasis;
            r && r[a] && (t[a] = t[a] || {}, t[a].normal ? o(t[a].normal, r[a]) : t[a].normal = r[a], r[a] = null), s && s[a] && (t[a] = t[a] || {}, t[a].emphasis ? o(t[a].emphasis, s[a]) : t[a].emphasis = s[a], s[a] = null)
        }
    }

    function Gs(t, e, i) {
        if (t && t[e] && (t[e].normal || t[e].emphasis)) {
            var n = t[e].normal, o = t[e].emphasis;
            n && (i ? (t[e].normal = t[e].emphasis = null, s(t[e], n)) : t[e] = n), o && (t.emphasis = t.emphasis || {}, t.emphasis[e] = o)
        }
    }

    function Fs(t) {
        Gs(t, "itemStyle"), Gs(t, "lineStyle"), Gs(t, "areaStyle"), Gs(t, "label"), Gs(t, "labelLine"), Gs(t, "upperLabel"), Gs(t, "edgeLabel")
    }

    function Ws(t, e) {
        var i = KD(t) && t[e], n = KD(i) && i.textStyle;
        if (n) for (var o = 0, a = aT.length; a > o; o++) {
            var e = aT[o];
            n.hasOwnProperty(e) && (i[e] = n[e])
        }
    }

    function Hs(t) {
        t && (Fs(t), Ws(t, "label"), t.emphasis && Ws(t.emphasis, "label"))
    }

    function Zs(t) {
        if (KD(t)) {
            Vs(t), Fs(t), Ws(t, "label"), Ws(t, "upperLabel"), Ws(t, "edgeLabel"), t.emphasis && (Ws(t.emphasis, "label"), Ws(t.emphasis, "upperLabel"), Ws(t.emphasis, "edgeLabel"));
            var e = t.markPoint;
            e && (Vs(e), Hs(e));
            var i = t.markLine;
            i && (Vs(i), Hs(i));
            var n = t.markArea;
            n && Hs(n);
            var o = t.data;
            if ("graph" === t.type) {
                o = o || t.nodes;
                var a = t.links || t.edges;
                if (a && !I(a)) for (var r = 0; r < a.length; r++) Hs(a[r]);
                f(t.categories, function (t) {
                    Fs(t)
                })
            }
            if (o && !I(o)) for (var r = 0; r < o.length; r++) Hs(o[r]);
            var e = t.markPoint;
            if (e && e.data) for (var s = e.data, r = 0; r < s.length; r++) Hs(s[r]);
            var i = t.markLine;
            if (i && i.data) for (var l = i.data, r = 0; r < l.length; r++) _(l[r]) ? (Hs(l[r][0]), Hs(l[r][1])) : Hs(l[r]);
            "gauge" === t.type ? (Ws(t, "axisLabel"), Ws(t, "title"), Ws(t, "detail")) : "treemap" === t.type ? (Gs(t.breadcrumb, "itemStyle"), f(t.levels, function (t) {
                Fs(t)
            })) : "tree" === t.type && Fs(t.leaves)
        }
    }

    function Us(t) {
        return _(t) ? t : t ? [t] : []
    }

    function Xs(t) {
        return (_(t) ? t[0] : t) || {}
    }

    function Ys(t, e) {
        e = e.split(",");
        for (var i = t, n = 0; n < e.length && (i = i && i[e[n]], null != i); n++) ;
        return i
    }

    function js(t, e, i, n) {
        e = e.split(",");
        for (var o, a = t, r = 0; r < e.length - 1; r++) o = e[r], null == a[o] && (a[o] = {}), a = a[o];
        (n || null == a[e[r]]) && (a[e[r]] = i)
    }

    function qs(t) {
        f(QD, function (e) {
            e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]])
        })
    }

    function Ks(t) {
        f(t, function (e, i) {
            var n = [], o = [0 / 0, 0 / 0], a = [e.stackResultDimension, e.stackedOverDimension], r = e.data,
                s = e.isStackedByIndex, l = r.map(a, function (a, l, u) {
                    var h = r.get(e.stackedDimension, u);
                    if (isNaN(h)) return o;
                    var c, d;
                    s ? d = r.getRawIndex(u) : c = r.get(e.stackedByDimension, u);
                    for (var f = 0 / 0, p = i - 1; p >= 0; p--) {
                        var g = t[p];
                        if (s || (d = g.data.rawIndexOf(g.stackedByDimension, c)), d >= 0) {
                            var m = g.data.getByRawIndex(g.stackResultDimension, d);
                            if (h >= 0 && m > 0 || 0 >= h && 0 > m) {
                                h += m, f = m;
                                break
                            }
                        }
                    }
                    return n[0] = h, n[1] = f, n
                });
            r.hostModel.setData(l), e.data = l
        })
    }

    function $s(t, e) {
        us.isInstance(t) || (t = us.seriesDataToSource(t)), this._source = t;
        var i = this._data = t.data, n = t.sourceFormat;
        if (n === ND) {
            if (BS && null == e) throw new Error("Typed array data must specify dimension size");
            this._offset = 0, this._dimSize = e, this._data = i
        }
        var o = oC[n === kD ? n + "_" + t.seriesLayoutBy : n];
        BS && O(o, "Invalide sourceFormat: " + n), r(this, o)
    }

    function Js() {
        return this._data.length
    }

    function Qs(t) {
        return this._data[t]
    }

    function tl(t) {
        for (var e = 0; e < t.length; e++) this._data.push(t[e])
    }

    function el(t, e, i) {
        return null != i ? t[i] : t
    }

    function il(t, e, i, n) {
        return nl(t[n], this._dimensionInfos[e])
    }

    function nl(t, e) {
        var i = e && e.type;
        if ("ordinal" === i) {
            var n = e && e.ordinalMeta;
            return n ? n.parseAndCollect(t) : t
        }
        return "time" === i && "number" != typeof t && null != t && "-" !== t && (t = +Er(t)), null == t || "" === t ? 0 / 0 : +t
    }

    function ol(t, e, i) {
        if (t) {
            var n = t.getRawDataItem(e);
            if (null != n) {
                var o, a, r = t.getProvider().getSource().sourceFormat, s = t.getDimensionInfo(i);
                return s && (o = s.name, a = s.index), aC[r](n, e, a, o)
            }
        }
    }

    function al(t, e, i) {
        if (t) {
            var n = t.getProvider().getSource().sourceFormat;
            if (n === LD || n === PD) {
                var o = t.getRawDataItem(e);
                return n !== LD || S(o) || (o = null), o ? o[i] : void 0
            }
        }
    }

    function rl(t) {
        return new sl(t)
    }

    function sl(t) {
        t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0, this.context
    }

    function ll(t, e, i, n, o, a) {
        hC.reset(i, n, o, a), t._callingProgress = e, t._callingProgress({
            start: i,
            end: n,
            count: n - i,
            next: hC.next
        }, t.context)
    }

    function ul(t, e) {
        t._dueIndex = t._outputDueEnd = t._dueEnd = 0, t._settedOutputEnd = null;
        var i, n;
        !e && t._reset && (i = t._reset(t.context), i && i.progress && (n = i.forceFirstProgress, i = i.progress), _(i) && !i.length && (i = null)), t._progress = i, t._modBy = t._modDataCount = null;
        var o = t._downstream;
        return o && o.dirty(), n
    }

    function hl(t) {
        var e = t.name;
        so(t) || (t.name = cl(t) || e)
    }

    function cl(t) {
        var e = t.getRawData(), i = e.mapDimension("seriesName", !0), n = [];
        return f(i, function (t) {
            var i = e.getDimensionInfo(t);
            i.displayName && n.push(i.displayName)
        }), n.join(" ")
    }

    function dl(t) {
        return t.model.getRawData().count()
    }

    function fl(t) {
        var e = t.model;
        return e.setData(e.getRawData().cloneShallow()), pl
    }

    function pl(t, e) {
        e.outputData && t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData)
    }

    function gl(t, e) {
        f(t.CHANGABLE_METHODS, function (i) {
            t.wrapMethod(i, x(ml, e))
        })
    }

    function ml(t) {
        var e = vl(t);
        e && e.setOutputEnd(this.count())
    }

    function vl(t) {
        var e = (t.ecModel || {}).scheduler, i = e && e.getPipeline(t.uid);
        if (i) {
            var n = i.currentTask;
            if (n) {
                var o = n.agentStubMap;
                o && (n = o.get(t.uid))
            }
            return n
        }
    }

    function yl() {
        this.group = new iI, this.uid = _r("viewChart"), this.renderTask = rl({
            plan: wl,
            reset: bl
        }), this.renderTask.context = {view: this}
    }

    function xl(t, e, i) {
        if (t && (t.trigger(e, i), t.isGroup && !Za(t))) for (var n = 0, o = t.childCount(); o > n; n++) xl(t.childAt(n), e, i)
    }

    function _l(t, e, i) {
        var n = ho(t, e), o = e && null != e.highlightKey ? Ua(e.highlightKey) : null;
        null != n ? f(eo(n), function (e) {
            xl(t.getItemGraphicEl(e), i, o)
        }) : t.eachItemGraphicEl(function (t) {
            xl(t, i, o)
        })
    }

    function wl(t) {
        return vC(t.model)
    }

    function bl(t) {
        var e = t.model, i = t.ecModel, n = t.api, o = t.payload, a = e.pipelineContext.progressiveRender, r = t.view,
            s = o && mC(o).updateMethod, l = a ? "incrementalPrepareRender" : s && r[s] ? s : "render";
        return "render" !== l && r[l](e, i, n, o), xC[l]
    }

    function Sl(t, e, i) {
        function n() {
            h = (new Date).getTime(), c = null, t.apply(r, s || [])
        }

        var o, a, r, s, l, u = 0, h = 0, c = null;
        e = e || 0;
        var d = function () {
            o = (new Date).getTime(), r = this, s = arguments;
            var t = l || e, d = l || i;
            l = null, a = o - (d ? u : h) - t, clearTimeout(c), d ? c = setTimeout(n, t) : a >= 0 ? n() : c = setTimeout(n, -a), u = o
        };
        return d.clear = function () {
            c && (clearTimeout(c), c = null)
        }, d.debounceNextCall = function (t) {
            l = t
        }, d
    }

    function Ml(t, e, i, n) {
        var o = t[e];
        if (o) {
            var a = o[_C] || o, r = o[bC], s = o[wC];
            if (s !== i || r !== n) {
                if (null == i || !n) return t[e] = a;
                o = t[e] = Sl(a, i, "debounce" === n), o[_C] = a, o[bC] = n, o[wC] = i
            }
            return o
        }
    }

    function Il(t, e) {
        var i = t[e];
        i && i[_C] && (t[e] = i[_C])
    }

    function Tl(t, e, i, n) {
        this.ecInstance = t, this.api = e, this.unfinished;
        var i = this._dataProcessorHandlers = i.slice(), n = this._visualHandlers = n.slice();
        this._allHandlers = i.concat(n), this._stageTaskMap = B()
    }

    function Al(t, e, i, n, o) {
        function a(t, e) {
            return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id))
        }

        o = o || {};
        var r;
        f(e, function (e) {
            if (!o.visualType || o.visualType === e.visualType) {
                var s = t._stageTaskMap.get(e.uid), l = s.seriesTaskMap, u = s.overallTask;
                if (u) {
                    var h, c = u.agentStubMap;
                    c.each(function (t) {
                        a(o, t) && (t.dirty(), h = !0)
                    }), h && u.dirty(), CC(u, n);
                    var d = t.getPerformArgs(u, o.block);
                    c.each(function (t) {
                        t.perform(d)
                    }), r |= u.perform(d)
                } else l && l.each(function (s) {
                    a(o, s) && s.dirty();
                    var l = t.getPerformArgs(s, o.block);
                    l.skip = !e.performRawSeries && i.isSeriesFiltered(s.context.model), CC(s, n), r |= s.perform(l)
                })
            }
        }), t.unfinished |= r
    }

    function Dl(t, e, i, n, o) {
        function a(i) {
            var a = i.uid, s = r.get(a) || r.set(a, rl({plan: El, reset: Nl, count: zl}));
            s.context = {
                model: i,
                ecModel: n,
                api: o,
                useClearVisual: e.isVisual && !e.isLayout,
                plan: e.plan,
                reset: e.reset,
                scheduler: t
            }, Bl(t, i, s)
        }

        var r = i.seriesTaskMap || (i.seriesTaskMap = B()), s = e.seriesType, l = e.getTargetSeries;
        e.createOnAllSeries ? n.eachRawSeries(a) : s ? n.eachRawSeriesByType(s, a) : l && l(n, o).each(a);
        var u = t._pipelineMap;
        r.each(function (t, e) {
            u.get(e) || (t.dispose(), r.removeKey(e))
        })
    }

    function Cl(t, e, i, n, o) {
        function a(e) {
            var i = e.uid, n = s.get(i);
            n || (n = s.set(i, rl({reset: kl, onDirty: Ol})), r.dirty()), n.context = {
                model: e,
                overallProgress: h,
                modifyOutputEnd: c
            }, n.agent = r, n.__block = h, Bl(t, e, n)
        }

        var r = i.overallTask = i.overallTask || rl({reset: Ll});
        r.context = {ecModel: n, api: o, overallReset: e.overallReset, scheduler: t};
        var s = r.agentStubMap = r.agentStubMap || B(), l = e.seriesType, u = e.getTargetSeries, h = !0,
            c = e.modifyOutputEnd;
        l ? n.eachRawSeriesByType(l, a) : u ? u(n, o).each(a) : (h = !1, f(n.getSeries(), a));
        var d = t._pipelineMap;
        s.each(function (t, e) {
            d.get(e) || (t.dispose(), r.dirty(), s.removeKey(e))
        })
    }

    function Ll(t) {
        t.overallReset(t.ecModel, t.api, t.payload)
    }

    function kl(t) {
        return t.overallProgress && Pl
    }

    function Pl() {
        this.agent.dirty(), this.getDownstream().dirty()
    }

    function Ol() {
        this.agent && this.agent.dirty()
    }

    function El(t) {
        return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload)
    }

    function Nl(t) {
        t.useClearVisual && t.data.clearAllVisual();
        var e = t.resetDefines = eo(t.reset(t.model, t.ecModel, t.api, t.payload));
        return e.length > 1 ? p(e, function (t, e) {
            return Rl(e)
        }) : LC
    }

    function Rl(t) {
        return function (e, i) {
            var n = i.data, o = i.resetDefines[t];
            if (o && o.dataEach) for (var a = e.start; a < e.end; a++) o.dataEach(n, a); else o && o.progress && o.progress(e, n)
        }
    }

    function zl(t) {
        return t.data.count()
    }

    function Bl(t, e, i) {
        var n = e.uid, o = t._pipelineMap.get(n);
        !o.head && (o.head = i), o.tail && o.tail.pipe(i), o.tail = i, i.__idxInPipeline = o.count++, i.__pipeline = o
    }

    function Vl(t) {
        kC = null;
        try {
            t(PC, OC)
        } catch (e) {
        }
        return kC
    }

    function Gl(t, e) {
        for (var i in e.prototype) t[i] = G
    }

    function Fl(t) {
        if (b(t)) {
            var e = new DOMParser;
            t = e.parseFromString(t, "text/xml")
        }
        for (9 === t.nodeType && (t = t.firstChild); "svg" !== t.nodeName.toLowerCase() || 1 !== t.nodeType;) t = t.nextSibling;
        return t
    }

    function Wl() {
        this._defs = {}, this._root = null, this._isDefine = !1, this._isText = !1
    }

    function Hl(t, e) {
        for (var i = t.firstChild; i;) {
            if (1 === i.nodeType) {
                var n = i.getAttribute("offset");
                n = n.indexOf("%") > 0 ? parseInt(n, 10) / 100 : n ? parseFloat(n) : 0;
                var o = i.getAttribute("stop-color") || "#000000";
                e.addColorStop(n, o)
            }
            i = i.nextSibling
        }
    }

    function Zl(t, e) {
        t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), s(e.__inheritedStyle, t.__inheritedStyle))
    }

    function Ul(t) {
        for (var e = E(t).split(FC), i = [], n = 0; n < e.length; n += 2) {
            var o = parseFloat(e[n]), a = parseFloat(e[n + 1]);
            i.push([o, a])
        }
        return i
    }

    function Xl(t, e, i, n) {
        var o = e.__inheritedStyle || {}, a = "text" === e.type;
        if (1 === t.nodeType && (jl(t, e), r(o, ql(t)), !n)) for (var s in ZC) if (ZC.hasOwnProperty(s)) {
            var l = t.getAttribute(s);
            null != l && (o[ZC[s]] = l)
        }
        var u = a ? "textFill" : "fill", h = a ? "textStroke" : "stroke";
        e.style = e.style || new cI;
        var c = e.style;
        null != o.fill && c.set(u, Yl(o.fill, i)), null != o.stroke && c.set(h, Yl(o.stroke, i)), f(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function (t) {
            var e = "lineWidth" === t && a ? "textStrokeWidth" : t;
            null != o[t] && c.set(e, parseFloat(o[t]))
        }), o.textBaseline && "auto" !== o.textBaseline || (o.textBaseline = "alphabetic"), "alphabetic" === o.textBaseline && (o.textBaseline = "bottom"), "start" === o.textAlign && (o.textAlign = "left"), "end" === o.textAlign && (o.textAlign = "right"), f(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function (t) {
            null != o[t] && c.set(t, o[t])
        }), o.lineDash && (e.style.lineDash = E(o.lineDash).split(FC)), c[h] && "none" !== c[h] && (e[h] = !0), e.__inheritedStyle = o
    }

    function Yl(t, e) {
        var i = e && t && t.match(UC);
        if (i) {
            var n = E(i[1]), o = e[n];
            return o
        }
        return t
    }

    function jl(t, e) {
        var i = t.getAttribute("transform");
        if (i) {
            i = i.replace(/,/g, " ");
            var n = null, o = [];
            i.replace(XC, function (t, e, i) {
                o.push(e, i)
            });
            for (var a = o.length - 1; a > 0; a -= 2) {
                var r = o[a], s = o[a - 1];
                switch (n = n || Oe(), s) {
                    case"translate":
                        r = E(r).split(FC), ze(n, n, [parseFloat(r[0]), parseFloat(r[1] || 0)]);
                        break;
                    case"scale":
                        r = E(r).split(FC), Ve(n, n, [parseFloat(r[0]), parseFloat(r[1] || r[0])]);
                        break;
                    case"rotate":
                        r = E(r).split(FC), Be(n, n, parseFloat(r[0]));
                        break;
                    case"skew":
                        r = E(r).split(FC), console.warn("Skew transform is not supported yet");
                        break;
                    case"matrix":
                        var r = E(r).split(FC);
                        n[0] = parseFloat(r[0]), n[1] = parseFloat(r[1]), n[2] = parseFloat(r[2]), n[3] = parseFloat(r[3]), n[4] = parseFloat(r[4]), n[5] = parseFloat(r[5])
                }
            }
            e.setLocalTransform(n)
        }
    }

    function ql(t) {
        var e = t.getAttribute("style"), i = {};
        if (!e) return i;
        var n = {};
        YC.lastIndex = 0;
        for (var o; null != (o = YC.exec(e));) n[o[1]] = o[2];
        for (var a in ZC) ZC.hasOwnProperty(a) && null != n[a] && (i[ZC[a]] = n[a]);
        return i
    }

    function Kl(t, e, i) {
        var n = e / t.width, o = i / t.height, a = Math.min(n, o), r = [a, a],
            s = [-(t.x + t.width / 2) * a + e / 2, -(t.y + t.height / 2) * a + i / 2];
        return {scale: r, position: s}
    }

    function $l(t, e) {
        var i = new Wl;
        return i.parse(t, e)
    }

    function Jl(t, e) {
        return function (i, n, o) {
            return !e && this._disposed ? void gu(this.id) : (i = i && i.toLowerCase(), void hM.prototype[t].call(this, i, n, o))
        }
    }

    function Ql() {
        hM.call(this)
    }

    function tu(t, e, i) {
        function o(t, e) {
            return t.__prio - e.__prio
        }

        i = i || {}, "string" == typeof e && (e = CL[e]), this.id, this.group, this._dom = t;
        var a = "canvas";
        BS && (a = ("undefined" == typeof window ? global : window).__ECHARTS__DEFAULT__RENDERER__ || a);
        var r = this._zr = Kn(t, {
            renderer: i.renderer || a,
            devicePixelRatio: i.devicePixelRatio,
            width: i.width,
            height: i.height
        });
        this._throttledZrFlush = Sl(y(r.flush, r), 17);
        var e = n(e);
        e && eC(e, !0), this._theme = e, this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new Ps;
        var s = this._api = xu(this);
        Ei(DL, o), Ei(IL, o), this._scheduler = new Tl(this, s, IL, DL), hM.call(this, this._ecEventProcessor = new _u), this._messageCenter = new Ql, this._initEvents(), this.resize = y(this.resize, this), this._pendingActions = [], r.animation.on("frame", this._onframe, this), lu(r, this), N(this)
    }

    function eu(t, e, i) {
        if (this._disposed) return void gu(this.id);
        var n, o = this._model, a = this._coordSysMgr.getCoordinateSystems();
        e = fo(o, e);
        for (var r = 0; r < a.length; r++) {
            var s = a[r];
            if (s[t] && null != (n = s[t](o, e, i))) return n
        }
        BS && console.warn("No coordinate system that supports " + t + " found by the given finder.")
    }

    function iu(t) {
        var e = t._model, i = t._scheduler;
        i.restorePipelines(e), i.prepareStageTasks(), uu(t, "component", e, i), uu(t, "chart", e, i), i.plan()
    }

    function nu(t, e, i, n, o) {
        function a(n) {
            n && n.__alive && n[e] && n[e](n.__model, r, t._api, i)
        }

        var r = t._model;
        if (!n) return void JC(t._componentsViews.concat(t._chartsViews), a);
        var s = {};
        s[n + "Id"] = i[n + "Id"], s[n + "Index"] = i[n + "Index"], s[n + "Name"] = i[n + "Name"];
        var l = {mainType: n, query: s};
        o && (l.subType = o);
        var u = i.excludeSeriesId;
        null != u && (u = B(eo(u))), r && r.eachComponent(l, function (e) {
            u && null != u.get(e.id) || a(t["series" === n ? "_chartsMap" : "_componentsMap"][e.__viewId])
        }, t)
    }

    function ou(t, e) {
        var i = t._chartsMap, n = t._scheduler;
        e.eachSeries(function (t) {
            n.updateStreamModes(t, i[t.__viewId])
        })
    }

    function au(t, e) {
        var i = t.type, n = t.escapeConnect, o = SL[i], a = o.actionInfo, l = (a.update || "update").split(":"),
            u = l.pop();
        l = null != l[0] && eL(l[0]), this[vL] = !0;
        var h = [t], c = !1;
        t.batch && (c = !0, h = p(t.batch, function (e) {
            return e = s(r({}, e), t), e.batch = null, e
        }));
        var d, f = [], g = "highlight" === i || "downplay" === i;
        JC(h, function (t) {
            d = o.action(t, this._model, this._api), d = d || r({}, t), d.type = a.event || d.type, f.push(d), g ? nu(this, u, t, "series") : l && nu(this, u, t, l.main, l.sub)
        }, this), "none" === u || g || l || (this[yL] ? (iu(this), wL.update.call(this, t), this[yL] = !1) : wL[u].call(this, t)), d = c ? {
            type: a.event || i,
            escapeConnect: n,
            batch: f
        } : f[0], this[vL] = !1, !e && this._messageCenter.trigger(d.type, d)
    }

    function ru(t) {
        for (var e = this._pendingActions; e.length;) {
            var i = e.shift();
            au.call(this, i, t)
        }
    }

    function su(t) {
        !t && this.trigger("updated")
    }

    function lu(t, e) {
        t.on("rendered", function () {
            e.trigger("rendered"), !t.animation.isFinished() || e[yL] || e._scheduler.unfinished || e._pendingActions.length || e.trigger("finished")
        })
    }

    function uu(t, e, i, n) {
        function o(t) {
            var e = "_ec_" + t.id + "_" + t.type, o = s[e];
            if (!o) {
                var h = eL(t.type), c = a ? fC.getClass(h.main, h.sub) : yl.getClass(h.sub);
                BS && $C(c, h.sub + " does not exist."), o = new c, o.init(i, u), s[e] = o, r.push(o), l.add(o.group)
            }
            t.__viewId = o.__id = e, o.__alive = !0, o.__model = t, o.group.__ecComponentInfo = {
                mainType: t.mainType,
                index: t.componentIndex
            }, !a && n.prepareView(o, t, i, u)
        }

        for (var a = "component" === e, r = a ? t._componentsViews : t._chartsViews, s = a ? t._componentsMap : t._chartsMap, l = t._zr, u = t._api, h = 0; h < r.length; h++) r[h].__alive = !1;
        a ? i.eachComponent(function (t, e) {
            "series" !== t && o(e)
        }) : i.eachSeries(o);
        for (var h = 0; h < r.length;) {
            var c = r[h];
            c.__alive ? h++ : (!a && c.renderTask.dispose(), l.remove(c.group), c.dispose(i, u), r.splice(h, 1), delete s[c.__id], c.__id = c.group.__ecComponentInfo = null)
        }
    }

    function hu(t) {
        t.clearColorPalette(), t.eachSeries(function (t) {
            t.clearColorPalette()
        })
    }

    function cu(t, e, i, n) {
        du(t, e, i, n), JC(t._chartsViews, function (t) {
            t.__alive = !1
        }), fu(t, e, i, n), JC(t._chartsViews, function (t) {
            t.__alive || t.remove(e, i)
        })
    }

    function du(t, e, i, n, o) {
        JC(o || t._componentsViews, function (t) {
            var o = t.__model;
            t.render(o, e, i, n), yu(o, t)
        })
    }

    function fu(t, e, i, n, o) {
        var a, r = t._scheduler;
        e.eachSeries(function (e) {
            var i = t._chartsMap[e.__viewId];
            i.__alive = !0;
            var s = i.renderTask;
            r.updatePayload(s, n), o && o.get(e.uid) && s.dirty(), a |= s.perform(r.getPerformArgs(s)), i.group.silent = !!e.get("silent"), yu(e, i), vu(e, i)
        }), r.unfinished |= a, mu(t, e), IC(t._zr.dom, e)
    }

    function pu(t, e) {
        JC(AL, function (i) {
            i(t, e)
        })
    }

    function gu(t) {
        BS && console.warn("Instance " + t + " has been disposed")
    }

    function mu(t, e) {
        var i = t._zr, n = i.storage, o = 0;
        n.traverse(function () {
            o++
        }), o > e.get("hoverLayerThreshold") && !WS.node && e.eachSeries(function (e) {
            if (!e.preventUsingHoverLayer) {
                var i = t._chartsMap[e.__viewId];
                i.__alive && i.group.traverse(function (t) {
                    t.useHoverLayer = !0
                })
            }
        })
    }

    function vu(t, e) {
        var i = t.get("blendMode") || null;
        BS && !WS.canvasSupported && i && "source-over" !== i && console.warn("Only canvas support blendMode"), e.group.traverse(function (t) {
            t.isGroup || t.style.blend !== i && t.setStyle("blend", i), t.eachPendingDisplayable && t.eachPendingDisplayable(function (t) {
                t.setStyle("blend", i)
            })
        })
    }

    function yu(t, e) {
        var i = t.get("z"), n = t.get("zlevel");
        e.group.traverse(function (t) {
            "group" !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n))
        })
    }

    function xu(t) {
        var e = t._coordSysMgr;
        return r(new ks(t), {
            getCoordinateSystems: y(e.getCoordinateSystems, e), getComponentByElement: function (e) {
                for (; e;) {
                    var i = e.__ecComponentInfo;
                    if (null != i) return t._model.getComponent(i.mainType, i.index);
                    e = e.parent
                }
            }
        })
    }

    function _u() {
        this.eventInfo
    }

    function wu(t) {
        function e(t, e) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i];
                n[a] = e
            }
        }

        var i = 0, n = 1, o = 2, a = "__connectUpdateStatus";
        JC(ML, function (r, s) {
            t._messageCenter.on(s, function (r) {
                if (PL[t.group] && t[a] !== i) {
                    if (r && r.escapeConnect) return;
                    var s = t.makeActionFromEvent(r), l = [];
                    JC(kL, function (e) {
                        e !== t && e.group === t.group && l.push(e)
                    }), e(l, i), JC(l, function (t) {
                        t[a] !== n && t.dispatchAction(s)
                    }), e(l, o)
                }
            })
        })
    }

    function bu(t, e, i) {
        if (BS) {
            if (JI.replace(".", "") - 0 < nL.zrender.replace(".", "") - 0) throw new Error("zrender/src " + JI + " is too old for ECharts " + iL + ". Current version need ZRender " + nL.zrender + "+");
            if (!t) throw new Error("Initialize failed: invalid dom.")
        }
        var n = Tu(t);
        if (n) return BS && console.warn("There is a chart instance already initialized on the dom."), n;
        BS && (!T(t) || "CANVAS" === t.nodeName.toUpperCase() || (t.clientWidth || i && null != i.width) && (t.clientHeight || i && null != i.height) || console.warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload."));
        var o = new tu(t, e, i);
        return o.id = "ec_" + OL++, kL[o.id] = o, go(t, NL, o.id), wu(o), o
    }

    function Su(t) {
        if (_(t)) {
            var e = t;
            t = null, JC(e, function (e) {
                null != e.group && (t = e.group)
            }), t = t || "g_" + EL++, JC(e, function (e) {
                e.group = t
            })
        }
        return PL[t] = !0, t
    }

    function Mu(t) {
        PL[t] = !1
    }

    function Iu(t) {
        "string" == typeof t ? t = kL[t] : t instanceof tu || (t = Tu(t)), t instanceof tu && !t.isDisposed() && t.dispose()
    }

    function Tu(t) {
        return kL[mo(t, NL)]
    }

    function Au(t) {
        return kL[t]
    }

    function Du(t, e) {
        CL[t] = e
    }

    function Cu(t) {
        TL.push(t)
    }

    function Lu(t, e) {
        zu(IL, t, e, aL)
    }

    function ku(t) {
        AL.push(t)
    }

    function Pu(t, e, i) {
        "function" == typeof e && (i = e, e = "");
        var n = tL(t) ? t.type : [t, t = {event: e}][0];
        t.event = (t.event || n).toLowerCase(), e = t.event, $C(xL.test(n) && xL.test(e)), SL[n] || (SL[n] = {
            action: i,
            actionInfo: t
        }), ML[e] = n
    }

    function Ou(t, e) {
        Ps.register(t, e)
    }

    function Eu(t) {
        var e = Ps.get(t);
        return e ? e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice() : void 0
    }

    function Nu(t, e) {
        zu(DL, t, e, uL, "layout")
    }

    function Ru(t, e) {
        zu(DL, t, e, dL, "visual")
    }

    function zu(t, e, i, n, o) {
        if ((QC(e) || tL(e)) && (i = e, e = n), BS) {
            if (isNaN(e) || null == e) throw new Error("Illegal priority");
            JC(t, function (t) {
                $C(t.__raw !== i)
            })
        }
        var a = Tl.wrapStageHandler(i, o);
        return a.__prio = e, a.__raw = i, t.push(a), a
    }

    function Bu(t, e) {
        LL[t] = e
    }

    function Vu(t) {
        return ID.extend(t)
    }

    function Gu(t) {
        return fC.extend(t)
    }

    function Fu(t) {
        return dC.extend(t)
    }

    function Wu(t) {
        return yl.extend(t)
    }

    function Hu(t) {
        i("createCanvas", t)
    }

    function Zu(t, e, i) {
        qC.registerMap(t, e, i)
    }

    function Uu(t) {
        var e = qC.retrieveMap(t);
        return e && e[0] && {geoJson: e[0].geoJSON, specialAreas: e[0].specialAreas}
    }

    function Xu(t) {
        return t
    }

    function Yu(t, e, i, n, o) {
        this._old = t, this._new = e, this._oldKeyGetter = i || Xu, this._newKeyGetter = n || Xu, this.context = o
    }

    function ju(t, e, i, n, o) {
        for (var a = 0; a < t.length; a++) {
            var r = "_ec_" + o[n](t[a], a), s = e[r];
            null == s ? (i.push(r), e[r] = a) : (s.length || (e[r] = s = [s]), s.push(a))
        }
    }

    function qu(t) {
        var e = {}, i = e.encode = {}, n = B(), o = [], a = [],
            r = e.userOutput = {dimensionNames: t.dimensions.slice(), encode: {}};
        f(t.dimensions, function (e) {
            var s = t.getDimensionInfo(e), l = s.coordDim;
            if (l) {
                BS && O(null == BL.get(l));
                var u = s.coordDimIndex;
                Ku(i, l)[u] = e, s.isExtraCoord || (n.set(l, 1), Ju(s.type) && (o[0] = e), Ku(r.encode, l)[u] = s.index), s.defaultTooltip && a.push(e)
            }
            BL.each(function (t, e) {
                var n = Ku(i, e), o = s.otherDims[e];
                null != o && o !== !1 && (n[o] = s.name)
            })
        });
        var s = [], l = {};
        n.each(function (t, e) {
            var n = i[e];
            l[e] = n[0], s = s.concat(n)
        }), e.dataDimsOnCoord = s, e.encodeFirstDimNotExtra = l;
        var u = i.label;
        u && u.length && (o = u.slice());
        var h = i.tooltip;
        return h && h.length ? a = h.slice() : a.length || (a = o.slice()), i.defaultedLabel = o, i.defaultedTooltip = a, e
    }

    function Ku(t, e) {
        return t.hasOwnProperty(e) || (t[e] = []), t[e]
    }

    function $u(t) {
        return "category" === t ? "ordinal" : "time" === t ? "time" : "float"
    }

    function Ju(t) {
        return !("ordinal" === t || "time" === t)
    }

    function Qu(t) {
        null != t && r(this, t), this.otherDims = {}
    }

    function th(t) {
        return t._rawCount > 65535 ? ZL : XL
    }

    function eh(t) {
        var e = t.constructor;
        return e === Array ? t.slice() : new e(t)
    }

    function ih(t, e) {
        f(YL.concat(e.__wrappedMethods || []), function (i) {
            e.hasOwnProperty(i) && (t[i] = e[i])
        }), t.__wrappedMethods = e.__wrappedMethods, f(jL, function (i) {
            t[i] = n(e[i])
        }), t._calculationInfo = r(e._calculationInfo)
    }

    function nh(t, e, i, n, o) {
        var a = HL[e.type], r = n - 1, s = e.name, l = t[s][r];
        if (l && l.length < i) {
            for (var u = new a(Math.min(o - r * i, i)), h = 0; h < l.length; h++) u[h] = l[h];
            t[s][r] = u
        }
        for (var c = n * i; o > c; c += i) t[s].push(new a(Math.min(o - c, i)))
    }

    function oh(t) {
        var e = t._invertedIndicesMap;
        f(e, function (i, n) {
            var o = t._dimensionInfos[n], a = o.ordinalMeta;
            if (a) {
                i = e[n] = new UL(a.categories.length);
                for (var r = 0; r < i.length; r++) i[r] = FL;
                for (var r = 0; r < t._count; r++) i[t.get(n, r)] = r
            }
        })
    }

    function ah(t, e, i) {
        var n;
        if (null != e) {
            var o = t._chunkSize, a = Math.floor(i / o), r = i % o, s = t.dimensions[e], l = t._storage[s][a];
            if (l) {
                n = l[r];
                var u = t._dimensionInfos[s].ordinalMeta;
                u && u.categories.length && (n = u.categories[n])
            }
        }
        return n
    }

    function rh(t) {
        return t
    }

    function sh(t) {
        return t < this._count && t >= 0 ? this._indices[t] : -1
    }

    function lh(t, e) {
        var i = t._idList[e];
        return null == i && (i = ah(t, t._idDimIdx, e)), null == i && (i = WL + e), i
    }

    function uh(t) {
        return _(t) || (t = [t]), t
    }

    function hh(t, e) {
        for (var i = 0; i < e.length; i++) t._dimensionInfos[e[i]] || console.error("Unkown dimension " + e[i])
    }

    function ch(t, e) {
        var i = t.dimensions, n = new qL(p(i, t.getDimensionInfo, t), t.hostModel);
        ih(n, t);
        for (var o = n._storage = {}, a = t._storage, r = 0; r < i.length; r++) {
            var s = i[r];
            a[s] && (u(e, s) >= 0 ? (o[s] = dh(a[s]), n._rawExtent[s] = fh(), n._extent[s] = null) : o[s] = a[s])
        }
        return n
    }

    function dh(t) {
        for (var e = new Array(t.length), i = 0; i < t.length; i++) e[i] = eh(t[i]);
        return e
    }

    function fh() {
        return [1 / 0, -1 / 0]
    }

    function ph(t, e, i) {
        function o(t, e, i) {
            null != BL.get(e) ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, u.set(e, !0))
        }

        us.isInstance(e) || (e = us.seriesDataToSource(e)), i = i || {}, t = (t || []).slice();
        for (var a = (i.dimsDef || []).slice(), l = B(), u = B(), h = [], c = gh(e, t, a, i.dimCount), d = 0; c > d; d++) {
            var p = a[d] = r({}, S(a[d]) ? a[d] : {name: a[d]}), g = p.name, m = h[d] = new Qu;
            null != g && null == l.get(g) && (m.name = m.displayName = g, l.set(g, d)), null != p.type && (m.type = p.type), null != p.displayName && (m.displayName = p.displayName)
        }
        var v = i.encodeDef;
        !v && i.encodeDefaulter && (v = i.encodeDefaulter(e, c)), v = B(v), v.each(function (t, e) {
            if (t = eo(t).slice(), 1 === t.length && !b(t[0]) && t[0] < 0) return void v.set(e, !1);
            var i = v.set(e, []);
            f(t, function (t, n) {
                b(t) && (t = l.get(t)), null != t && c > t && (i[n] = t, o(h[t], e, n))
            })
        });
        var y = 0;
        f(t, function (t) {
            var e, t, i, a;
            if (b(t)) e = t, t = {}; else {
                e = t.name;
                var r = t.ordinalMeta;
                t.ordinalMeta = null, t = n(t), t.ordinalMeta = r, i = t.dimsDef, a = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null
            }
            var l = v.get(e);
            if (l !== !1) {
                var l = eo(l);
                if (!l.length) for (var u = 0; u < (i && i.length || 1); u++) {
                    for (; y < h.length && null != h[y].coordDim;) y++;
                    y < h.length && l.push(y++)
                }
                f(l, function (n, r) {
                    var l = h[n];
                    if (o(s(l, t), e, r), null == l.name && i) {
                        var u = i[r];
                        !S(u) && (u = {name: u}), l.name = l.displayName = u.name, l.defaultTooltip = u.defaultTooltip
                    }
                    a && s(l.otherDims, a)
                })
            }
        });
        var x = i.generateCoord, _ = i.generateCoordCount, w = null != _;
        _ = x ? _ || 1 : 0;
        for (var M = x || "value", I = 0; c > I; I++) {
            var m = h[I] = h[I] || new Qu, T = m.coordDim;
            null == T && (m.coordDim = mh(M, u, w), m.coordDimIndex = 0, (!x || 0 >= _) && (m.isExtraCoord = !0), _--), null == m.name && (m.name = mh(m.coordDim, l)), null != m.type || ws(e, I, m.name) !== BD.Must && (!m.isExtraCoord || null == m.otherDims.itemName && null == m.otherDims.seriesName) || (m.type = "ordinal")
        }
        return h
    }

    function gh(t, e, i, n) {
        var o = Math.max(t.dimensionsDetectCount || 1, e.length, i.length, n || 0);
        return f(e, function (t) {
            var e = t.dimsDef;
            e && (o = Math.max(o, e.length))
        }), o
    }

    function mh(t, e, i) {
        if (i || null != e.get(t)) {
            for (var n = 0; null != e.get(t + n);) n++;
            t += n
        }
        return e.set(t, !0), t
    }

    function vh(t) {
        this.coordSysName = t, this.coordSysDims = [], this.axisMap = B(), this.categoryAxisMap = B(), this.firstCategoryDimIndex = null
    }

    function yh(t) {
        var e = t.get("coordinateSystem"), i = new vh(e), n = QL[e];
        return n ? (n(t, i, i.axisMap, i.categoryAxisMap), i) : void 0
    }

    function xh(t) {
        return "category" === t.get("type")
    }

    function _h(t, e, i) {
        i = i || {};
        var n, o, a, r, s = i.byIndex, l = i.stackedCoordDimension, u = !(!t || !t.get("stack"));
        if (f(e, function (t, i) {
            b(t) && (e[i] = t = {name: t}), u && !t.isExtraCoord && (s || n || !t.ordinalMeta || (n = t), o || "ordinal" === t.type || "time" === t.type || l && l !== t.coordDim || (o = t))
        }), !o || s || n || (s = !0), o) {
            a = "__\x00ecstackresult", r = "__\x00ecstackedover", n && (n.createInvertedIndices = !0);
            var h = o.coordDim, c = o.type, d = 0;
            f(e, function (t) {
                t.coordDim === h && d++
            }), e.push({
                name: a,
                coordDim: h,
                coordDimIndex: d,
                type: c,
                isExtraCoord: !0,
                isCalculationCoord: !0
            }), d++, e.push({name: r, coordDim: r, coordDimIndex: d, type: c, isExtraCoord: !0, isCalculationCoord: !0})
        }
        return {
            stackedDimension: o && o.name,
            stackedByDimension: n && n.name,
            isStackedByIndex: s,
            stackedOverDimension: r,
            stackResultDimension: a
        }
    }

    function wh(t, e) {
        return !!e && e === t.getCalculationInfo("stackedDimension")
    }

    function bh(t, e) {
        return wh(t, e) ? t.getCalculationInfo("stackResultDimension") : e
    }

    function Sh(t, e, i) {
        i = i || {}, us.isInstance(t) || (t = us.seriesDataToSource(t));
        var n, o = e.get("coordinateSystem"), a = Ps.get(o), r = yh(e);
        r && (n = p(r.coordSysDims, function (t) {
            var e = {name: t}, i = r.axisMap.get(t);
            if (i) {
                var n = i.get("type");
                e.type = $u(n)
            }
            return e
        })), n || (n = a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice()) || ["x", "y"]);
        var s, l, u = JL(t, {
            coordDimensions: n,
            generateCoord: i.generateCoord,
            encodeDefaulter: i.useEncodeDefaulter ? x(ys, n, e) : null
        });
        r && f(u, function (t, e) {
            var i = t.coordDim, n = r.categoryAxisMap.get(i);
            n && (null == s && (s = e), t.ordinalMeta = n.getOrdinalMeta()), null != t.otherDims.itemName && (l = !0)
        }), l || null == s || (u[s].otherDims.itemName = 0);
        var h = _h(e, u), c = new qL(u, e);
        c.setCalculationInfo(h);
        var d = null != s && Mh(t) ? function (t, e, i, n) {
            return n === s ? i : this.defaultDimValueGetter(t, e, i, n)
        } : null;
        return c.hasItemOption = !1, c.initData(t, null, d), c
    }

    function Mh(t) {
        if (t.sourceFormat === LD) {
            var e = Ih(t.data || []);
            return null != e && !_(no(e))
        }
    }

    function Ih(t) {
        for (var e = 0; e < t.length && null == t[e];) e++;
        return t[e]
    }

    function Th(t) {
        this._setting = t || {}, this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments)
    }

    function Ah(t) {
        this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this._map
    }

    function Dh(t) {
        return t._map || (t._map = B(t.categories))
    }

    function Ch(t) {
        return S(t) && null != t.value ? t.value : t + ""
    }

    function Lh(t, e, i, n) {
        var o = {}, a = t[1] - t[0], r = o.interval = zr(a / e, !0);
        null != i && i > r && (r = o.interval = i), null != n && r > n && (r = o.interval = n);
        var s = o.intervalPrecision = kh(r),
            l = o.niceTickExtent = [nk(Math.ceil(t[0] / r) * r, s), nk(Math.floor(t[1] / r) * r, s)];
        return Oh(l, t), o
    }

    function kh(t) {
        return Cr(t) + 2
    }

    function Ph(t, e, i) {
        t[e] = Math.max(Math.min(t[e], i[1]), i[0])
    }

    function Oh(t, e) {
        !isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), Ph(t, 0, e), Ph(t, 1, e), t[0] > t[1] && (t[0] = t[1])
    }

    function Eh(t) {
        return t.get("stack") || rk + t.seriesIndex
    }

    function Nh(t) {
        return t.dim + t.index
    }

    function Rh(t) {
        var e = [], i = t.axis, n = "axis0";
        if ("category" === i.type) {
            for (var o = i.getBandWidth(), a = 0; a < t.count; a++) e.push(s({
                bandWidth: o,
                axisKey: n,
                stackId: rk + a
            }, t));
            for (var r = Gh(e), l = [], a = 0; a < t.count; a++) {
                var u = r[n][rk + a];
                u.offsetCenter = u.offset + u.width / 2, l.push(u)
            }
            return l
        }
    }

    function zh(t, e) {
        var i = [];
        return e.eachSeriesByType(t, function (t) {
            Hh(t) && !Zh(t) && i.push(t)
        }), i
    }

    function Bh(t) {
        var e = {};
        f(t, function (t) {
            var i = t.coordinateSystem, n = i.getBaseAxis();
            if ("time" === n.type || "value" === n.type) for (var o = t.getData(), a = n.dim + "_" + n.index, r = o.mapDimension(n.dim), s = 0, l = o.count(); l > s; ++s) {
                var u = o.get(r, s);
                e[a] ? e[a].push(u) : e[a] = [u]
            }
        });
        var i = [];
        for (var n in e) if (e.hasOwnProperty(n)) {
            var o = e[n];
            if (o) {
                o.sort(function (t, e) {
                    return t - e
                });
                for (var a = null, r = 1; r < o.length; ++r) {
                    var s = o[r] - o[r - 1];
                    s > 0 && (a = null === a ? s : Math.min(a, s))
                }
                i[n] = a
            }
        }
        return i
    }

    function Vh(t) {
        var e = Bh(t), i = [];
        return f(t, function (t) {
            var n, o = t.coordinateSystem, a = o.getBaseAxis(), r = a.getExtent();
            if ("category" === a.type) n = a.getBandWidth(); else if ("value" === a.type || "time" === a.type) {
                var s = a.dim + "_" + a.index, l = e[s], u = Math.abs(r[1] - r[0]), h = a.scale.getExtent(),
                    c = Math.abs(h[1] - h[0]);
                n = l ? u / c * l : u
            } else {
                var d = t.getData();
                n = Math.abs(r[1] - r[0]) / d.count()
            }
            var f = Ir(t.get("barWidth"), n), p = Ir(t.get("barMaxWidth"), n), g = Ir(t.get("barMinWidth") || 1, n),
                m = t.get("barGap"), v = t.get("barCategoryGap");
            i.push({
                bandWidth: n,
                barWidth: f,
                barMaxWidth: p,
                barMinWidth: g,
                barGap: m,
                barCategoryGap: v,
                axisKey: Nh(a),
                stackId: Eh(t)
            })
        }), Gh(i)
    }

    function Gh(t) {
        var e = {};
        f(t, function (t) {
            var i = t.axisKey, n = t.bandWidth, o = e[i] || {
                bandWidth: n,
                remainedWidth: n,
                autoWidthCount: 0,
                categoryGap: "20%",
                gap: "30%",
                stacks: {}
            }, a = o.stacks;
            e[i] = o;
            var r = t.stackId;
            a[r] || o.autoWidthCount++, a[r] = a[r] || {width: 0, maxWidth: 0};
            var s = t.barWidth;
            s && !a[r].width && (a[r].width = s, s = Math.min(o.remainedWidth, s), o.remainedWidth -= s);
            var l = t.barMaxWidth;
            l && (a[r].maxWidth = l);
            var u = t.barMinWidth;
            u && (a[r].minWidth = u);
            var h = t.barGap;
            null != h && (o.gap = h);
            var c = t.barCategoryGap;
            null != c && (o.categoryGap = c)
        });
        var i = {};
        return f(e, function (t, e) {
            i[e] = {};
            var n = t.stacks, o = t.bandWidth, a = Ir(t.categoryGap, o), r = Ir(t.gap, 1), s = t.remainedWidth,
                l = t.autoWidthCount, u = (s - a) / (l + (l - 1) * r);
            u = Math.max(u, 0), f(n, function (t) {
                var e = t.maxWidth, i = t.minWidth;
                if (t.width) {
                    var n = t.width;
                    e && (n = Math.min(n, e)), i && (n = Math.max(n, i)), t.width = n, s -= n + r * n, l--
                } else {
                    var n = u;
                    e && n > e && (n = Math.min(e, s)), i && i > n && (n = i), n !== u && (t.width = n, s -= n + r * n, l--)
                }
            }), u = (s - a) / (l + (l - 1) * r), u = Math.max(u, 0);
            var h, c = 0;
            f(n, function (t) {
                t.width || (t.width = u), h = t, c += t.width * (1 + r)
            }), h && (c -= h.width * r);
            var d = -c / 2;
            f(n, function (t, n) {
                i[e][n] = i[e][n] || {bandWidth: o, offset: d, width: t.width}, d += t.width * (1 + r)
            })
        }), i
    }

    function Fh(t, e, i) {
        if (t && e) {
            var n = t[Nh(e)];
            return null != n && null != i && (n = n[Eh(i)]), n
        }
    }

    function Wh(t, e) {
        var i = zh(t, e), n = Vh(i), o = {};
        f(i, function (t) {
            var e = t.getData(), i = t.coordinateSystem, a = i.getBaseAxis(), r = Eh(t), s = n[Nh(a)][r], l = s.offset,
                u = s.width, h = i.getOtherAxis(a), c = t.get("barMinHeight") || 0;
            o[r] = o[r] || [], e.setLayout({bandWidth: s.bandWidth, offset: l, size: u});
            for (var d = e.mapDimension(h.dim), f = e.mapDimension(a.dim), p = wh(e, d), g = h.isHorizontal(), m = Uh(a, h, p), v = 0, y = e.count(); y > v; v++) {
                var x = e.get(d, v), _ = e.get(f, v), w = x >= 0 ? "p" : "n", b = m;
                p && (o[r][_] || (o[r][_] = {p: m, n: m}), b = o[r][_][w]);
                var S, M, I, T;
                if (g) {
                    var A = i.dataToPoint([x, _]);
                    S = b, M = A[1] + l, I = A[0] - m, T = u, Math.abs(I) < c && (I = (0 > I ? -1 : 1) * c), isNaN(I) || p && (o[r][_][w] += I)
                } else {
                    var A = i.dataToPoint([_, x]);
                    S = A[0] + l, M = b, I = u, T = A[1] - m, Math.abs(T) < c && (T = (0 >= T ? -1 : 1) * c), isNaN(T) || p && (o[r][_][w] += T)
                }
                e.setItemLayout(v, {x: S, y: M, width: I, height: T})
            }
        }, this)
    }

    function Hh(t) {
        return t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type
    }

    function Zh(t) {
        return t.pipelineContext && t.pipelineContext.large
    }

    function Uh(t, e) {
        return e.toGlobalCoord(e.dataToCoord("log" === e.type ? 1 : 0))
    }

    function Xh(t, e) {
        return Sk(t, bk(e))
    }

    function Yh(t, e) {
        var i, n, o, a = t.type, r = e.getMin(), s = e.getMax(), l = t.getExtent();
        "ordinal" === a ? i = e.getCategories().length : (n = e.get("boundaryGap"), _(n) || (n = [n || 0, n || 0]), "boolean" == typeof n[0] && (BS && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), n = [0, 0]), n[0] = Ir(n[0], 1), n[1] = Ir(n[1], 1), o = l[1] - l[0] || Math.abs(l[0])), "dataMin" === r ? r = l[0] : "function" == typeof r && (r = r({
            min: l[0],
            max: l[1]
        })), "dataMax" === s ? s = l[1] : "function" == typeof s && (s = s({min: l[0], max: l[1]}));
        var u = null != r, h = null != s;
        null == r && (r = "ordinal" === a ? i ? 0 : 0 / 0 : l[0] - n[0] * o), null == s && (s = "ordinal" === a ? i ? i - 1 : 0 / 0 : l[1] + n[1] * o), (null == r || !isFinite(r)) && (r = 0 / 0), (null == s || !isFinite(s)) && (s = 0 / 0), t.setBlank(A(r) || A(s) || "ordinal" === a && !t.getOrdinalMeta().categories.length), e.getNeedCrossZero() && (r > 0 && s > 0 && !u && (r = 0), 0 > r && 0 > s && !h && (s = 0));
        var c = e.ecModel;
        if (c && "time" === a) {
            var d, p = zh("bar", c);
            if (f(p, function (t) {
                d |= t.getBaseAxis() === e.axis
            }), d) {
                var g = Vh(p), m = jh(r, s, e, g);
                r = m.min, s = m.max
            }
        }
        return {extent: [r, s], fixMin: u, fixMax: h}
    }

    function jh(t, e, i, n) {
        var o = i.axis.getExtent(), a = o[1] - o[0], r = Fh(n, i.axis);
        if (void 0 === r) return {min: t, max: e};
        var s = 1 / 0;
        f(r, function (t) {
            s = Math.min(t.offset, s)
        });
        var l = -1 / 0;
        f(r, function (t) {
            l = Math.max(t.offset + t.width, l)
        }), s = Math.abs(s), l = Math.abs(l);
        var u = s + l, h = e - t, c = 1 - (s + l) / a, d = h / c - h;
        return e += d * (l / u), t -= d * (s / u), {min: t, max: e}
    }

    function qh(t, e) {
        var i = Yh(t, e), n = i.extent, o = e.get("splitNumber");
        "log" === t.type && (t.base = e.get("logBase"));
        var a = t.type;
        t.setExtent(n[0], n[1]), t.niceExtent({
            splitNumber: o,
            fixMin: i.fixMin,
            fixMax: i.fixMax,
            minInterval: "interval" === a || "time" === a ? e.get("minInterval") : null,
            maxInterval: "interval" === a || "time" === a ? e.get("maxInterval") : null
        });
        var r = e.get("interval");
        null != r && t.setInterval && t.setInterval(r)
    }

    function Kh(t, e) {
        if (e = e || t.get("type")) switch (e) {
            case"category":
                return new ik(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), [1 / 0, -1 / 0]);
            case"value":
                return new ak;
            default:
                return (Th.getClass(e) || ak).create(t)
        }
    }

    function $h(t) {
        var e = t.scale.getExtent(), i = e[0], n = e[1];
        return !(i > 0 && n > 0 || 0 > i && 0 > n)
    }

    function Jh(t) {
        var e = t.getLabelModel().get("formatter"), i = "category" === t.type ? t.scale.getExtent()[0] : null;
        return "string" == typeof e ? e = function (e) {
            return function (i) {
                return i = t.scale.getLabel(i), e.replace("{value}", null != i ? i : "")
            }
        }(e) : "function" == typeof e ? function (n, o) {
            return null != i && (o = n - i), e(Qh(t, n), o)
        } : function (e) {
            return t.scale.getLabel(e)
        }
    }

    function Qh(t, e) {
        return "category" === t.type ? t.scale.getLabel(e) : e
    }

    function tc(t) {
        var e = t.model, i = t.scale;
        if (e.get("axisLabel.show") && !i.isBlank()) {
            var n, o, a = "category" === t.type, r = i.getExtent();
            a ? o = i.count() : (n = i.getTicks(), o = n.length);
            var s, l = t.getLabelModel(), u = Jh(t), h = 1;
            o > 40 && (h = Math.ceil(o / 40));
            for (var c = 0; o > c; c += h) {
                var d = n ? n[c] : r[0] + c, f = u(d), p = l.getTextRect(f), g = ec(p, l.get("rotate") || 0);
                s ? s.union(g) : s = g
            }
            return s
        }
    }

    function ec(t, e) {
        var i = e * Math.PI / 180, n = t.plain(), o = n.width, a = n.height,
            r = o * Math.abs(Math.cos(i)) + Math.abs(a * Math.sin(i)),
            s = o * Math.abs(Math.sin(i)) + Math.abs(a * Math.cos(i)), l = new Ti(n.x, n.y, r, s);
        return l
    }

    function ic(t) {
        var e = t.get("interval");
        return null == e ? "auto" : e
    }

    function nc(t) {
        return "category" === t.type && 0 === ic(t.getLabelModel())
    }

    function oc(t, e) {
        if ("image" !== this.type) {
            var i = this.style, n = this.shape;
            n && "line" === n.symbolType ? i.stroke = t : this.__isEmptyBrush ? (i.stroke = t, i.fill = e || "#fff") : (i.fill && (i.fill = t), i.stroke && (i.stroke = t)), this.dirty(!1)
        }
    }

    function ac(t, e, i, n, o, a, r) {
        var s = 0 === t.indexOf("empty");
        s && (t = t.substr(5, 1).toLowerCase() + t.substr(6));
        var l;
        return l = 0 === t.indexOf("image://") ? Ma(t.slice(8), new Ti(e, i, n, o), r ? "center" : "cover") : 0 === t.indexOf("path://") ? Sa(t.slice(7), {}, new Ti(e, i, n, o), r ? "center" : "cover") : new zk({
            shape: {
                symbolType: t,
                x: e,
                y: i,
                width: n,
                height: o
            }
        }), l.__isEmptyBrush = s, l.setColor = oc, l.setColor(a), l
    }

    function rc(t) {
        return Sh(t.getSource(), t)
    }

    function sc(t, e) {
        var i = e;
        vr.isInstance(e) || (i = new vr(e), c(i, Ck));
        var n = Kh(i);
        return n.setExtent(t[0], t[1]), qh(n, i), n
    }

    function lc(t) {
        c(t, Ck)
    }

    function uc(t, e) {
        return Math.abs(t - e) < Gk
    }

    function hc(t, e, i) {
        var n = 0, o = t[0];
        if (!o) return !1;
        for (var a = 1; a < t.length; a++) {
            var r = t[a];
            n += Ko(o[0], o[1], r[0], r[1], e, i), o = r
        }
        var s = t[0];
        return uc(o[0], s[0]) && uc(o[1], s[1]) || (n += Ko(o[0], o[1], s[0], s[1], e, i)), 0 !== n
    }

    function cc(t, e, i) {
        if (this.name = t, this.geometries = e, i) i = [i[0], i[1]]; else {
            var n = this.getBoundingRect();
            i = [n.x + n.width / 2, n.y + n.height / 2]
        }
        this.center = i
    }

    function dc(t) {
        if (!t.UTF8Encoding) return t;
        var e = t.UTF8Scale;
        null == e && (e = 1024);
        for (var i = t.features, n = 0; n < i.length; n++) for (var o = i[n], a = o.geometry, r = a.coordinates, s = a.encodeOffsets, l = 0; l < r.length; l++) {
            var u = r[l];
            if ("Polygon" === a.type) r[l] = fc(u, s[l], e); else if ("MultiPolygon" === a.type) for (var h = 0; h < u.length; h++) {
                var c = u[h];
                u[h] = fc(c, s[l][h], e)
            }
        }
        return t.UTF8Encoding = !1, t
    }

    function fc(t, e, i) {
        for (var n = [], o = e[0], a = e[1], r = 0; r < t.length; r += 2) {
            var s = t.charCodeAt(r) - 64, l = t.charCodeAt(r + 1) - 64;
            s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), s += o, l += a, o = s, a = l, n.push([s / i, l / i])
        }
        return n
    }

    function pc(t) {
        return "category" === t.type ? mc(t) : xc(t)
    }

    function gc(t, e) {
        return "category" === t.type ? yc(t, e) : {ticks: t.scale.getTicks()}
    }

    function mc(t) {
        var e = t.getLabelModel(), i = vc(t, e);
        return !e.get("show") || t.scale.isBlank() ? {labels: [], labelCategoryInterval: i.labelCategoryInterval} : i
    }

    function vc(t, e) {
        var i = _c(t, "labels"), n = ic(e), o = wc(i, n);
        if (o) return o;
        var a, r;
        return w(n) ? a = Ac(t, n) : (r = "auto" === n ? Sc(t) : n, a = Tc(t, r)), bc(i, n, {
            labels: a,
            labelCategoryInterval: r
        })
    }

    function yc(t, e) {
        var i = _c(t, "ticks"), n = ic(e), o = wc(i, n);
        if (o) return o;
        var a, r;
        if ((!e.get("show") || t.scale.isBlank()) && (a = []), w(n)) a = Ac(t, n, !0); else if ("auto" === n) {
            var s = vc(t, t.getLabelModel());
            r = s.labelCategoryInterval, a = p(s.labels, function (t) {
                return t.tickValue
            })
        } else r = n, a = Tc(t, r, !0);
        return bc(i, n, {ticks: a, tickCategoryInterval: r})
    }

    function xc(t) {
        var e = t.scale.getTicks(), i = Jh(t);
        return {
            labels: p(e, function (e, n) {
                return {formattedLabel: i(e, n), rawLabel: t.scale.getLabel(e), tickValue: e}
            })
        }
    }

    function _c(t, e) {
        return Wk(t)[e] || (Wk(t)[e] = [])
    }

    function wc(t, e) {
        for (var i = 0; i < t.length; i++) if (t[i].key === e) return t[i].value
    }

    function bc(t, e, i) {
        return t.push({key: e, value: i}), i
    }

    function Sc(t) {
        var e = Wk(t).autoInterval;
        return null != e ? e : Wk(t).autoInterval = t.calculateCategoryInterval()
    }

    function Mc(t) {
        var e = Ic(t), i = Jh(t), n = (e.axisRotate - e.labelRotate) / 180 * Math.PI, o = t.scale, a = o.getExtent(),
            r = o.count();
        if (a[1] - a[0] < 1) return 0;
        var s = 1;
        r > 40 && (s = Math.max(1, Math.floor(r / 40)));
        for (var l = a[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(n)), c = Math.abs(u * Math.sin(n)), d = 0, f = 0; l <= a[1]; l += s) {
            var p = 0, g = 0, m = Xi(i(l), e.font, "center", "top");
            p = 1.3 * m.width, g = 1.3 * m.height, d = Math.max(d, p, 7), f = Math.max(f, g, 7)
        }
        var v = d / h, y = f / c;
        isNaN(v) && (v = 1 / 0), isNaN(y) && (y = 1 / 0);
        var x = Math.max(0, Math.floor(Math.min(v, y))), _ = Wk(t.model), w = t.getExtent(), b = _.lastAutoInterval,
            S = _.lastTickCount;
        return null != b && null != S && Math.abs(b - x) <= 1 && Math.abs(S - r) <= 1 && b > x && _.axisExtend0 === w[0] && _.axisExtend1 === w[1] ? x = b : (_.lastTickCount = r, _.lastAutoInterval = x, _.axisExtend0 = w[0], _.axisExtend1 = w[1]), x
    }

    function Ic(t) {
        var e = t.getLabelModel();
        return {
            axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0,
            labelRotate: e.get("rotate") || 0,
            font: e.getFont()
        }
    }

    function Tc(t, e, i) {
        function n(t) {
            l.push(i ? t : {formattedLabel: o(t), rawLabel: a.getLabel(t), tickValue: t})
        }

        var o = Jh(t), a = t.scale, r = a.getExtent(), s = t.getLabelModel(), l = [], u = Math.max((e || 0) + 1, 1),
            h = r[0], c = a.count();
        0 !== h && u > 1 && c / u > 2 && (h = Math.round(Math.ceil(h / u) * u));
        var d = nc(t), f = s.get("showMinLabel") || d, p = s.get("showMaxLabel") || d;
        f && h !== r[0] && n(r[0]);
        for (var g = h; g <= r[1]; g += u) n(g);
        return p && g - u !== r[1] && n(r[1]), l
    }

    function Ac(t, e, i) {
        var n = t.scale, o = Jh(t), a = [];
        return f(n.getTicks(), function (t) {
            var r = n.getLabel(t);
            e(t, r) && a.push(i ? t : {formattedLabel: o(t), rawLabel: r, tickValue: t})
        }), a
    }

    function Dc(t, e) {
        var i = t[1] - t[0], n = e, o = i / n / 2;
        t[0] += o, t[1] -= o
    }

    function Cc(t, e, i, n) {
        function o(t, e) {
            return t = Tr(t), e = Tr(e), d ? t > e : e > t
        }

        var a = e.length;
        if (t.onBand && !i && a) {
            var r, s, l = t.getExtent();
            if (1 === a) e[0].coord = l[0], r = e[1] = {coord: l[0]}; else {
                var u = e[a - 1].tickValue - e[0].tickValue, h = (e[a - 1].coord - e[0].coord) / u;
                f(e, function (t) {
                    t.coord -= h / 2
                });
                var c = t.scale.getExtent();
                s = 1 + c[1] - e[a - 1].tickValue, r = {coord: e[a - 1].coord + h * s}, e.push(r)
            }
            var d = l[0] > l[1];
            o(e[0].coord, l[0]) && (n ? e[0].coord = l[0] : e.shift()), n && o(l[0], e[0].coord) && e.unshift({coord: l[0]}), o(l[1], r.coord) && (n ? r.coord = l[1] : e.pop()), n && o(r.coord, l[1]) && e.push({coord: l[1]})
        }
    }

    function Lc(t) {
        return this._axes[t]
    }

    function kc(t) {
        jk.call(this, t)
    }

    function Pc(t, e) {
        return e.type || (e.data ? "category" : "value")
    }

    function Oc(t, e) {
        return t.getCoordSysModel() === e
    }

    function Ec(t, e, i) {
        this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this.model = t
    }

    function Nc(t, e, i, n) {
        function o(t) {
            return t.dim + "_" + t.index
        }

        i.getAxesOnZeroOf = function () {
            return a ? [a] : []
        };
        var a, r = t[e], s = i.model, l = s.get("axisLine.onZero"), u = s.get("axisLine.onZeroAxisIndex");
        if (l) {
            if (null != u) Rc(r[u]) && (a = r[u]); else for (var h in r) if (r.hasOwnProperty(h) && Rc(r[h]) && !n[o(r[h])]) {
                a = r[h];
                break
            }
            a && (n[o(a)] = !0)
        }
    }

    function Rc(t) {
        return t && "category" !== t.type && "time" !== t.type && $h(t)
    }

    function zc(t, e) {
        var i = t.getExtent(), n = i[0] + i[1];
        t.toGlobalCoord = "x" === t.dim ? function (t) {
            return t + e
        } : function (t) {
            return n - t + e
        }, t.toLocalCoord = "x" === t.dim ? function (t) {
            return t - e
        } : function (t) {
            return n - t + e
        }
    }

    function Bc(t) {
        return p(nP, function (e) {
            var i = t.getReferringComponents(e)[0];
            if (BS && !i) throw new Error(e + ' "' + D(t.get(e + "Index"), t.get(e + "Id"), 0) + '" not found');
            return i
        })
    }

    function Vc(t) {
        return "cartesian2d" === t.get("coordinateSystem")
    }

    function Gc(t, e) {
        var i = t.mapDimension("defaultedLabel", !0), n = i.length;
        if (1 === n) return ol(t, e, i[0]);
        if (n) {
            for (var o = [], a = 0; a < i.length; a++) {
                var r = ol(t, e, i[a]);
                o.push(r)
            }
            return o.join(" ")
        }
    }

    function Fc(t, e, i, n, o, a) {
        var r = i.getModel("label"), s = i.getModel("emphasis.label");
        Xa(t, e, r, s, {
            labelFetcher: o,
            labelDataIndex: a,
            defaultText: Gc(o.getData(), a),
            isRectText: !0,
            autoColor: n
        }), Wc(t), Wc(e)
    }

    function Wc(t, e) {
        "outside" === t.textPosition && (t.textPosition = e)
    }

    function Hc(t, e, i) {
        var n = t.getArea(), o = t.getBaseAxis().isHorizontal(), a = n.x, r = n.y, s = n.width, l = n.height,
            u = i.get("lineStyle.width") || 2;
        a -= u / 2, r -= u / 2, s += u, l += u, a = Math.floor(a), s = Math.round(s);
        var h = new CA({shape: {x: a, y: r, width: s, height: l}});
        return e && (h.shape[o ? "width" : "height"] = 0, ar(h, {shape: {width: s, height: l}}, i)), h
    }

    function Zc(t, e, i) {
        var n = t.getArea(), o = new wA({
            shape: {
                cx: Tr(t.cx, 1),
                cy: Tr(t.cy, 1),
                r0: Tr(n.r0, 1),
                r: Tr(n.r, 1),
                startAngle: n.startAngle,
                endAngle: n.endAngle,
                clockwise: n.clockwise
            }
        });
        return e && (o.shape.endAngle = n.startAngle, ar(o, {shape: {endAngle: n.endAngle}}, i)), o
    }

    function Uc(t, e, i) {
        return t ? "polar" === t.type ? Zc(t, e, i) : "cartesian2d" === t.type ? Hc(t, e, i) : null : null
    }

    function Xc(t, e) {
        var i = t.getArea && t.getArea();
        if ("cartesian2d" === t.type) {
            var n = t.getBaseAxis();
            if ("category" !== n.type || !n.onBand) {
                var o = e.getLayout("bandWidth");
                n.isHorizontal() ? (i.x -= o, i.width += 2 * o) : (i.y -= o, i.height += 2 * o)
            }
        }
        return i
    }

    function Yc(t, e, i) {
        i.style.text = null, or(i, {shape: {width: 0}}, e, t, function () {
            i.parent && i.parent.remove(i)
        })
    }

    function jc(t, e, i) {
        i.style.text = null, or(i, {shape: {r: i.shape.r0}}, e, t, function () {
            i.parent && i.parent.remove(i)
        })
    }

    function qc(t) {
        return null != t.startAngle && null != t.endAngle && t.startAngle === t.endAngle
    }

    function Kc(t, e, i, n, o, a, r, l) {
        var u = e.getItemVisual(i, "color"), h = e.getItemVisual(i, "opacity"), c = e.getVisual("borderColor"),
            d = n.getModel("itemStyle"), f = n.getModel("emphasis.itemStyle").getBarItemStyle();
        l || t.setShape("r", d.get("barBorderRadius") || 0), t.useStyle(s({
            stroke: qc(o) ? "none" : c,
            fill: qc(o) ? "none" : u,
            opacity: h
        }, d.getBarItemStyle()));
        var p = n.getShallow("cursor");
        p && t.attr("cursor", p);
        var g = r ? o.height > 0 ? "bottom" : "top" : o.width > 0 ? "left" : "right";
        l || Fc(t.style, f, n, u, a, i, g), qc(o) && (f.fill = f.stroke = "none"), Wa(t, f)
    }

    function $c(t, e) {
        var i = t.get(lP) || 0, n = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width),
            o = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
        return Math.min(i, n, o)
    }

    function Jc(t, e, i) {
        var n = t.getData(), o = [], a = n.getLayout("valueAxisHorizontal") ? 1 : 0;
        o[1 - a] = n.getLayout("valueAxisStart");
        var r = n.getLayout("largeDataIndices"), s = n.getLayout("barWidth"), l = t.getModel("backgroundStyle"),
            u = t.get("showBackground", !0);
        if (u) {
            var h = n.getLayout("largeBackgroundPoints"), c = [];
            c[1 - a] = n.getLayout("backgroundStart");
            var d = new gP({
                shape: {points: h},
                incremental: !!i,
                __startPoint: c,
                __baseDimIdx: a,
                __largeDataIndices: r,
                __barWidth: s,
                silent: !0,
                z2: 0
            });
            ed(d, l, n), e.add(d)
        }
        var f = new gP({
            shape: {points: n.getLayout("largePoints")},
            incremental: !!i,
            __startPoint: o,
            __baseDimIdx: a,
            __largeDataIndices: r,
            __barWidth: s
        });
        e.add(f), td(f, t, n), f.seriesIndex = t.seriesIndex, t.get("silent") || (f.on("mousedown", mP), f.on("mousemove", mP))
    }

    function Qc(t, e, i) {
        var n = t.__baseDimIdx, o = 1 - n, a = t.shape.points, r = t.__largeDataIndices, s = Math.abs(t.__barWidth / 2),
            l = t.__startPoint[o];
        uP[0] = e, uP[1] = i;
        for (var u = uP[n], h = uP[1 - n], c = u - s, d = u + s, f = 0, p = a.length / 2; p > f; f++) {
            var g = 2 * f, m = a[g + n], v = a[g + o];
            if (m >= c && d >= m && (v >= l ? h >= l && v >= h : h >= v && l >= h)) return r[f]
        }
        return -1
    }

    function td(t, e, i) {
        var n = i.getVisual("borderColor") || i.getVisual("color"),
            o = e.getModel("itemStyle").getItemStyle(["color", "borderColor"]);
        t.useStyle(o), t.style.fill = null, t.style.stroke = n, t.style.lineWidth = i.getLayout("barWidth")
    }

    function ed(t, e, i) {
        var n = e.get("borderColor") || e.get("color"), o = e.getItemStyle(["color", "borderColor"]);
        t.useStyle(o), t.style.fill = null, t.style.stroke = n, t.style.lineWidth = i.getLayout("barWidth")
    }

    function id(t, e, i) {
        var n, o = "polar" === i.type;
        return n = o ? i.getArea() : i.grid.getRect(), o ? {
            cx: n.cx,
            cy: n.cy,
            r0: t ? n.r0 : e.r0,
            r: t ? n.r : e.r,
            startAngle: t ? e.startAngle : 0,
            endAngle: t ? e.endAngle : 2 * Math.PI
        } : {x: t ? e.x : n.x, y: t ? n.y : e.y, width: t ? e.width : n.width, height: t ? n.height : e.height}
    }

    function nd(t, e, i) {
        var n = "polar" === t.type ? wA : CA;
        return new n({shape: id(e, i, t), silent: !0, z2: 0})
    }

    function od(t, e, i, n) {
        var o, a, r = Pr(i - t.rotation), s = n[0] > n[1], l = "start" === e && !s || "start" !== e && s;
        return Or(r - vP / 2) ? (a = l ? "bottom" : "top", o = "center") : Or(r - 1.5 * vP) ? (a = l ? "top" : "bottom", o = "center") : (a = "middle", o = 1.5 * vP > r && r > vP / 2 ? l ? "left" : "right" : l ? "right" : "left"), {
            rotation: r,
            textAlign: o,
            textVerticalAlign: a
        }
    }

    function ad(t, e, i) {
        if (!nc(t.axis)) {
            var n = t.get("axisLabel.showMinLabel"), o = t.get("axisLabel.showMaxLabel");
            e = e || [], i = i || [];
            var a = e[0], r = e[1], s = e[e.length - 1], l = e[e.length - 2], u = i[0], h = i[1], c = i[i.length - 1],
                d = i[i.length - 2];
            n === !1 ? (rd(a), rd(u)) : sd(a, r) && (n ? (rd(r), rd(h)) : (rd(a), rd(u))), o === !1 ? (rd(s), rd(c)) : sd(l, s) && (o ? (rd(l), rd(d)) : (rd(s), rd(c)))
        }
    }

    function rd(t) {
        t && (t.ignore = !0)
    }

    function sd(t, e) {
        var i = t && t.getBoundingRect().clone(), n = e && e.getBoundingRect().clone();
        if (i && n) {
            var o = Ee([]);
            return Be(o, o, -t.rotation), i.applyTransform(Re([], o, t.getLocalTransform())), n.applyTransform(Re([], o, e.getLocalTransform())), i.intersect(n)
        }
    }

    function ld(t) {
        return "middle" === t || "center" === t
    }

    function ud(t, e, i, n, o) {
        for (var a = [], r = [], s = [], l = 0; l < t.length; l++) {
            var u = t[l].coord;
            r[0] = u, r[1] = 0, s[0] = u, s[1] = i, e && (ae(r, r, e), ae(s, s, e));
            var h = new kA({
                anid: o + "_" + t[l].tickValue,
                subPixelOptimize: !0,
                shape: {x1: r[0], y1: r[1], x2: s[0], y2: s[1]},
                style: n,
                z2: 2,
                silent: !0
            });
            a.push(h)
        }
        return a
    }

    function hd(t, e, i) {
        var n = e.axis, o = e.getModel("axisTick");
        if (o.get("show") && !n.scale.isBlank()) {
            for (var a = o.getModel("lineStyle"), r = i.tickDirection * o.get("length"), l = n.getTicksCoords(), u = ud(l, t._transform, r, s(a.getLineStyle(), {stroke: e.get("axisLine.lineStyle.color")}), "ticks"), h = 0; h < u.length; h++) t.group.add(u[h]);
            return u
        }
    }

    function cd(t, e, i) {
        var n = e.axis, o = e.getModel("minorTick");
        if (o.get("show") && !n.scale.isBlank()) {
            var a = n.getMinorTicksCoords();
            if (a.length) for (var r = o.getModel("lineStyle"), l = i.tickDirection * o.get("length"), u = s(r.getLineStyle(), s(e.getModel("axisTick").getLineStyle(), {stroke: e.get("axisLine.lineStyle.color")})), h = 0; h < a.length; h++) for (var c = ud(a[h], t._transform, l, u, "minorticks_" + h), d = 0; d < c.length; d++) t.group.add(c[d])
        }
    }

    function dd(t, e, i) {
        var n = e.axis, o = D(i.axisLabelShow, e.get("axisLabel.show"));
        if (o && !n.scale.isBlank()) {
            var a = e.getModel("axisLabel"), r = a.get("margin"), s = n.getViewLabels(),
                l = (D(i.labelRotate, a.get("rotate")) || 0) * vP / 180, u = wP(i.rotation, l, i.labelDirection),
                h = e.getCategories && e.getCategories(!0), c = [], d = bP(e), p = e.get("triggerEvent");
            return f(s, function (o, s) {
                var l = o.tickValue, f = o.formattedLabel, g = o.rawLabel, m = a;
                h && h[l] && h[l].textStyle && (m = new vr(h[l].textStyle, a, e.ecModel));
                var v = m.getTextColor() || e.get("axisLine.lineStyle.color"), y = n.dataToCoord(l),
                    x = [y, i.labelOffset + i.labelDirection * r],
                    _ = new vA({anid: "label_" + l, position: x, rotation: u.rotation, silent: d, z2: 10});
                ja(_.style, m, {
                    text: f,
                    textAlign: m.getShallow("align", !0) || u.textAlign,
                    textVerticalAlign: m.getShallow("verticalAlign", !0) || m.getShallow("baseline", !0) || u.textVerticalAlign,
                    textFill: "function" == typeof v ? v("category" === n.type ? g : "value" === n.type ? l + "" : l, s) : v
                }), p && (_.eventData = _P(e), _.eventData.targetType = "axisLabel", _.eventData.value = g), t._dumbGroup.add(_), _.updateTransform(), c.push(_), t.group.add(_), _.decomposeTransform()
            }), c
        }
    }

    function fd(t, e) {
        var i = {axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {}};
        return pd(i, t, e), i.seriesInvolved && md(i, t), i
    }

    function pd(t, e, i) {
        var n = e.getComponent("tooltip"), o = e.getComponent("axisPointer"), a = o.get("link", !0) || [], r = [];
        SP(i.getCoordinateSystems(), function (i) {
            function s(n, s, l) {
                var h = l.model.getModel("axisPointer", o), d = h.get("show");
                if (d && ("auto" !== d || n || bd(h))) {
                    null == s && (s = h.get("triggerTooltip")), h = n ? gd(l, c, o, e, n, s) : h;
                    var f = h.get("snap"), p = Sd(l.model), g = s || f || "category" === l.type, m = t.axesInfo[p] = {
                        key: p,
                        axis: l,
                        coordSys: i,
                        axisPointerModel: h,
                        triggerTooltip: s,
                        involveSeries: g,
                        snap: f,
                        useHandle: bd(h),
                        seriesModels: []
                    };
                    u[p] = m, t.seriesInvolved |= g;
                    var v = vd(a, l);
                    if (null != v) {
                        var y = r[v] || (r[v] = {axesInfo: {}});
                        y.axesInfo[p] = m, y.mapper = a[v].mapper, m.linkGroup = y
                    }
                }
            }

            if (i.axisPointerEnabled) {
                var l = Sd(i.model), u = t.coordSysAxesInfo[l] = {};
                t.coordSysMap[l] = i;
                var h = i.model, c = h.getModel("tooltip", n);
                if (SP(i.getAxes(), MP(s, !1, null)), i.getTooltipAxes && n && c.get("show")) {
                    var d = "axis" === c.get("trigger"), f = "cross" === c.get("axisPointer.type"),
                        p = i.getTooltipAxes(c.get("axisPointer.axis"));
                    (d || f) && SP(p.baseAxes, MP(s, f ? "cross" : !0, d)), f && SP(p.otherAxes, MP(s, "cross", !1))
                }
            }
        })
    }

    function gd(t, e, i, o, a, r) {
        var l = e.getModel("axisPointer"), u = {};
        SP(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function (t) {
            u[t] = n(l.get(t))
        }), u.snap = "category" !== t.type && !!r, "cross" === l.get("type") && (u.type = "line");
        var h = u.label || (u.label = {});
        if (null == h.show && (h.show = !1), "cross" === a) {
            var c = l.get("label.show");
            if (h.show = null != c ? c : !0, !r) {
                var d = u.lineStyle = l.get("crossStyle");
                d && s(h, d.textStyle)
            }
        }
        return t.model.getModel("axisPointer", new vr(u, i, o))
    }

    function md(t, e) {
        e.eachSeries(function (e) {
            var i = e.coordinateSystem, n = e.get("tooltip.trigger", !0), o = e.get("tooltip.show", !0);
            i && "none" !== n && n !== !1 && "item" !== n && o !== !1 && e.get("axisPointer.show", !0) !== !1 && SP(t.coordSysAxesInfo[Sd(i.model)], function (t) {
                var n = t.axis;
                i.getAxis(n.dim) === n && (t.seriesModels.push(e), null == t.seriesDataCount && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count())
            })
        }, this)
    }

    function vd(t, e) {
        for (var i = e.model, n = e.dim, o = 0; o < t.length; o++) {
            var a = t[o] || {};
            if (yd(a[n + "AxisId"], i.id) || yd(a[n + "AxisIndex"], i.componentIndex) || yd(a[n + "AxisName"], i.name)) return o
        }
    }

    function yd(t, e) {
        return "all" === t || _(t) && u(t, e) >= 0 || t === e
    }

    function xd(t) {
        var e = _d(t);
        if (e) {
            var i = e.axisPointerModel, n = e.axis.scale, o = i.option, a = i.get("status"), r = i.get("value");
            null != r && (r = n.parse(r));
            var s = bd(i);
            null == a && (o.status = s ? "show" : "hide");
            var l = n.getExtent().slice();
            l[0] > l[1] && l.reverse(), (null == r || r > l[1]) && (r = l[1]), r < l[0] && (r = l[0]), o.value = r, s && (o.status = e.axis.scale.isBlank() ? "hide" : "show")
        }
    }

    function _d(t) {
        var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
        return e && e.axesInfo[Sd(t)]
    }

    function wd(t) {
        var e = _d(t);
        return e && e.axisPointerModel
    }

    function bd(t) {
        return !!t.get("handle.show")
    }

    function Sd(t) {
        return t.type + "||" + t.id
    }

    function Md(t, e, i, n, o, a) {
        var r = IP.getAxisPointerClass(t.axisPointerClass);
        if (r) {
            var s = wd(e);
            s ? (t._axisPointer || (t._axisPointer = new r)).render(e, s, n, a) : Id(t, n)
        }
    }

    function Id(t, e, i) {
        var n = t._axisPointer;
        n && n.dispose(e, i), t._axisPointer = null
    }

    function Td(t, e, i) {
        i = i || {};
        var n = t.coordinateSystem, o = e.axis, a = {}, r = o.getAxesOnZeroOf()[0], s = o.position,
            l = r ? "onZero" : s, u = o.dim, h = n.getRect(), c = [h.x, h.x + h.width, h.y, h.y + h.height],
            d = {left: 0, right: 1, top: 0, bottom: 1, onZero: 2}, f = e.get("offset") || 0,
            p = "x" === u ? [c[2] - f, c[3] + f] : [c[0] - f, c[1] + f];
        if (r) {
            var g = r.toGlobalCoord(r.dataToCoord(0));
            p[d.onZero] = Math.max(Math.min(g, p[1]), p[0])
        }
        a.position = ["y" === u ? p[d[l]] : c[0], "x" === u ? p[d[l]] : c[3]], a.rotation = Math.PI / 2 * ("x" === u ? 0 : 1);
        var m = {top: -1, bottom: 1, left: -1, right: 1};
        a.labelDirection = a.tickDirection = a.nameDirection = m[s], a.labelOffset = r ? p[d[s]] - p[d.onZero] : 0, e.get("axisTick.inside") && (a.tickDirection = -a.tickDirection), D(i.labelInside, e.get("axisLabel.inside")) && (a.labelDirection = -a.labelDirection);
        var v = e.get("axisLabel.rotate");
        return a.labelRotate = "top" === l ? -v : v, a.z2 = 1, a
    }

    function Ad(t, e, i, n) {
        var o = i.axis;
        if (!o.scale.isBlank()) {
            var a = i.getModel("splitArea"), r = a.getModel("areaStyle"), l = r.get("color"),
                u = n.coordinateSystem.getRect(), h = o.getTicksCoords({tickModel: a, clamp: !0});
            if (h.length) {
                var c = l.length, d = t.__splitAreaColors, f = B(), p = 0;
                if (d) for (var g = 0; g < h.length; g++) {
                    var m = d.get(h[g].tickValue);
                    if (null != m) {
                        p = (m + (c - 1) * g) % c;
                        break
                    }
                }
                var v = o.toGlobalCoord(h[0].coord), y = r.getAreaStyle();
                l = _(l) ? l : [l];
                for (var g = 1; g < h.length; g++) {
                    var x, w, b, S, M = o.toGlobalCoord(h[g].coord);
                    o.isHorizontal() ? (x = v, w = u.y, b = M - x, S = u.height, v = x + b) : (x = u.x, w = v, b = u.width, S = M - w, v = w + S);
                    var I = h[g - 1].tickValue;
                    null != I && f.set(I, p), e.add(new CA({
                        anid: null != I ? "area_" + I : null,
                        shape: {x: x, y: w, width: b, height: S},
                        style: s({fill: l[p]}, y),
                        silent: !0
                    })), p = (p + 1) % c
                }
                t.__splitAreaColors = f
            }
        }
    }

    function Dd(t) {
        t.__splitAreaColors = null
    }

    function Cd(t, e, i) {
        iI.call(this), this.updateData(t, e, i)
    }

    function Ld(t) {
        return [t[0] / 2, t[1] / 2]
    }

    function kd(t, e) {
        this.parent.drift(t, e)
    }

    function Pd(t, e) {
        if (!this.incremental && !this.useHoverLayer) if ("emphasis" === e) {
            var i = this.__symbolOriginalScale, n = i[1] / i[0],
                o = {scale: [Math.max(1.1 * i[0], i[0] + 3), Math.max(1.1 * i[1], i[1] + 3 * n)]};
            this.animateTo(o, 400, "elasticOut")
        } else "normal" === e && this.animateTo({scale: this.__symbolOriginalScale}, 400, "elasticOut")
    }

    function Od(t) {
        this.group = new iI, this._symbolCtor = t || Cd
    }

    function Ed(t, e, i, n) {
        return !(!e || isNaN(e[0]) || isNaN(e[1]) || n.isIgnore && n.isIgnore(i) || n.clipShape && !n.clipShape.contain(e[0], e[1]) || "none" === t.getItemVisual(i, "symbol"))
    }

    function Nd(t) {
        return null == t || S(t) || (t = {isIgnore: t}), t || {}
    }

    function Rd(t) {
        var e = t.hostModel;
        return {
            itemStyle: e.getModel("itemStyle").getItemStyle(["color"]),
            hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(),
            symbolRotate: e.get("symbolRotate"),
            symbolOffset: e.get("symbolOffset"),
            hoverAnimation: e.get("hoverAnimation"),
            labelModel: e.getModel("label"),
            hoverLabelModel: e.getModel("emphasis.label"),
            cursorStyle: e.get("cursor")
        }
    }

    function zd(t, e, i) {
        var n, o = t.getBaseAxis(), a = t.getOtherAxis(o), r = Bd(a, i), s = o.dim, l = a.dim, u = e.mapDimension(l),
            h = e.mapDimension(s), c = "x" === l || "radius" === l ? 1 : 0, d = p(t.dimensions, function (t) {
                return e.mapDimension(t)
            }), f = e.getCalculationInfo("stackResultDimension");
        return (n |= wh(e, d[0])) && (d[0] = f), (n |= wh(e, d[1])) && (d[1] = f), {
            dataDimsForPoint: d,
            valueStart: r,
            valueAxisDim: l,
            baseAxisDim: s,
            stacked: !!n,
            valueDim: u,
            baseDim: h,
            baseDataOffset: c,
            stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
        }
    }

    function Bd(t, e) {
        var i = 0, n = t.scale.getExtent();
        return "start" === e ? i = n[0] : "end" === e ? i = n[1] : n[0] > 0 ? i = n[0] : n[1] < 0 && (i = n[1]), i
    }

    function Vd(t, e, i, n) {
        var o = 0 / 0;
        t.stacked && (o = i.get(i.getCalculationInfo("stackedOverDimension"), n)), isNaN(o) && (o = t.valueStart);
        var a = t.baseDataOffset, r = [];
        return r[a] = i.get(t.baseDim, n), r[1 - a] = o, e.dataToPoint(r)
    }

    function Gd(t, e) {
        var i = [];
        return e.diff(t).add(function (t) {
            i.push({cmd: "+", idx: t})
        }).update(function (t, e) {
            i.push({cmd: "=", idx: e, idx1: t})
        }).remove(function (t) {
            i.push({cmd: "-", idx: t})
        }).execute(), i
    }

    function Fd(t) {
        return isNaN(t[0]) || isNaN(t[1])
    }

    function Wd(t, e, i, n, o, a, r, s, l, u) {
        return "none" !== u && u ? Hd.apply(this, arguments) : Zd.apply(this, arguments)
    }

    function Hd(t, e, i, n, o, a, r, s, l, u, h) {
        for (var c = 0, d = i, f = 0; n > f; f++) {
            var p = e[d];
            if (d >= o || 0 > d) break;
            if (Fd(p)) {
                if (h) {
                    d += a;
                    continue
                }
                break
            }
            if (d === i) t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]); else if (l > 0) {
                var g = e[c], m = "y" === u ? 1 : 0, v = (p[m] - g[m]) * l;
                FP(HP, g), HP[m] = g[m] + v, FP(ZP, p), ZP[m] = p[m] - v, t.bezierCurveTo(HP[0], HP[1], ZP[0], ZP[1], p[0], p[1])
            } else t.lineTo(p[0], p[1]);
            c = d, d += a
        }
        return f
    }

    function Zd(t, e, i, n, o, a, r, s, l, u, h) {
        for (var c = 0, d = i, f = 0; n > f; f++) {
            var p = e[d];
            if (d >= o || 0 > d) break;
            if (Fd(p)) {
                if (h) {
                    d += a;
                    continue
                }
                break
            }
            if (d === i) t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]), FP(HP, p); else if (l > 0) {
                var g = d + a, m = e[g];
                if (h) for (; m && Fd(e[g]);) g += a, m = e[g];
                var v = .5, y = e[c], m = e[g];
                if (!m || Fd(m)) FP(ZP, p); else {
                    Fd(m) && !h && (m = p), Y(WP, m, y);
                    var x, _;
                    if ("x" === u || "y" === u) {
                        var w = "x" === u ? 0 : 1;
                        x = Math.abs(p[w] - y[w]), _ = Math.abs(p[w] - m[w])
                    } else x = rM(p, y), _ = rM(p, m);
                    v = _ / (_ + x), GP(ZP, p, WP, -l * (1 - v))
                }
                BP(HP, HP, s), VP(HP, HP, r), BP(ZP, ZP, s), VP(ZP, ZP, r), t.bezierCurveTo(HP[0], HP[1], ZP[0], ZP[1], p[0], p[1]), GP(HP, p, WP, l * v)
            } else t.lineTo(p[0], p[1]);
            c = d, d += a
        }
        return f
    }

    function Ud(t, e) {
        var i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0];
        if (e) for (var o = 0; o < t.length; o++) {
            var a = t[o];
            a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1])
        }
        return {min: e ? i : n, max: e ? n : i}
    }

    function Xd(t, e) {
        if (t.length === e.length) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i], o = e[i];
                if (n[0] !== o[0] || n[1] !== o[1]) return
            }
            return !0
        }
    }

    function Yd(t, e) {
        var i = [], n = [], o = [], a = [];
        return Go(t, i, n), Go(e, o, a), Math.max(Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]), Math.abs(n[0] - a[0]), Math.abs(n[1] - a[1]))
    }

    function jd(t) {
        return "number" == typeof t ? t : t ? .5 : 0
    }

    function qd(t, e, i) {
        if (!i.valueDim) return [];
        for (var n = [], o = 0, a = e.count(); a > o; o++) n.push(Vd(i, t, e, o));
        return n
    }

    function Kd(t, e, i) {
        for (var n = e.getBaseAxis(), o = "x" === n.dim || "radius" === n.dim ? 0 : 1, a = [], r = 0; r < t.length - 1; r++) {
            var s = t[r + 1], l = t[r];
            a.push(l);
            var u = [];
            switch (i) {
                case"end":
                    u[o] = s[o], u[1 - o] = l[1 - o], a.push(u);
                    break;
                case"middle":
                    var h = (l[o] + s[o]) / 2, c = [];
                    u[o] = c[o] = h, u[1 - o] = l[1 - o], c[1 - o] = s[1 - o], a.push(u), a.push(c);
                    break;
                default:
                    u[o] = l[o], u[1 - o] = s[1 - o], a.push(u)
            }
        }
        return t[r] && a.push(t[r]), a
    }

    function $d(t, e) {
        var i = t.getVisual("visualMeta");
        if (i && i.length && t.count()) {
            if ("cartesian2d" !== e.type) return void (BS && console.warn("Visual map on line style is only supported on cartesian2d."));
            for (var n, o, a = i.length - 1; a >= 0; a--) {
                var r = i[a].dimension, s = t.dimensions[r], l = t.getDimensionInfo(s);
                if (n = l && l.coordDim, "x" === n || "y" === n) {
                    o = i[a];
                    break
                }
            }
            if (!o) return void (BS && console.warn("Visual map on line style only support x or y dimension."));
            var u = e.getAxis(n), h = p(o.stops, function (t) {
                return {coord: u.toGlobalCoord(u.dataToCoord(t.value)), color: t.color}
            }), c = h.length, d = o.outerColors.slice();
            c && h[0].coord > h[c - 1].coord && (h.reverse(), d.reverse());
            var g = 10, m = h[0].coord - g, v = h[c - 1].coord + g, y = v - m;
            if (.001 > y) return "transparent";
            f(h, function (t) {
                t.offset = (t.coord - m) / y
            }), h.push({
                offset: c ? h[c - 1].offset : .5,
                color: d[1] || "transparent"
            }), h.unshift({offset: c ? h[0].offset : .5, color: d[0] || "transparent"});
            var x = new zA(0, 0, 0, 0, h, !0);
            return x[n] = m, x[n + "2"] = v, x
        }
    }

    function Jd(t, e, i) {
        var n = t.get("showAllSymbol"), o = "auto" === n;
        if (!n || o) {
            var a = i.getAxesByScale("ordinal")[0];
            if (a && (!o || !Qd(a, e))) {
                var r = e.mapDimension(a.dim), s = {};
                return f(a.getViewLabels(), function (t) {
                    s[t.tickValue] = 1
                }), function (t) {
                    return !s.hasOwnProperty(e.get(r, t))
                }
            }
        }
    }

    function Qd(t, e) {
        var i = t.getExtent(), n = Math.abs(i[1] - i[0]) / t.scale.count();
        isNaN(n) && (n = 0);
        for (var o = e.count(), a = Math.max(1, Math.round(o / 5)), r = 0; o > r; r += a) if (1.5 * Cd.getSymbolSize(e, r)[t.isHorizontal() ? 1 : 0] > n) return !1;
        return !0
    }

    function tf(t, e, i) {
        if ("cartesian2d" === t.type) {
            var n = t.getBaseAxis().isHorizontal(), o = Hc(t, e, i);
            if (!i.get("clip", !0)) {
                var a = o.shape, r = Math.max(a.width, a.height);
                n ? (a.y -= r, a.height += 2 * r) : (a.x -= r, a.width += 2 * r)
            }
            return o
        }
        return Zc(t, e, i)
    }

    function ef(t, e) {
        this.getAllNames = function () {
            var t = e();
            return t.mapArray(t.getName)
        }, this.containName = function (t) {
            var i = e();
            return i.indexOfName(t) >= 0
        }, this.indexOfName = function (e) {
            var i = t();
            return i.indexOfName(e)
        }, this.getItemVisual = function (e, i) {
            var n = t();
            return n.getItemVisual(e, i)
        }
    }

    function nf(t, e, i, n) {
        var o = e.getData(), a = this.dataIndex, r = o.getName(a), s = e.get("selectedOffset");
        n.dispatchAction({type: "pieToggleSelect", from: t, name: r, seriesId: e.id}), o.each(function (t) {
            of(o.getItemGraphicEl(t), o.getItemLayout(t), e.isSelected(o.getName(t)), s, i)
        })
    }

    function of(t, e, i, n, o) {
        var a = (e.startAngle + e.endAngle) / 2, r = Math.cos(a), s = Math.sin(a), l = i ? n : 0, u = [r * l, s * l];
        o ? t.animate().when(200, {position: u}).start("bounceOut") : t.attr("position", u)
    }

    function af(t, e) {
        iI.call(this);
        var i = new wA({z2: 2}), n = new TA, o = new vA;
        this.add(i), this.add(n), this.add(o), this.updateData(t, e, !0)
    }

    function rf(t, e, i, n, o, a, r, s, l, u) {
        function h(e, i, n) {
            for (var o = e; i > o && !(t[o].y + n > l + r); o++) if (t[o].y += n, o > e && i > o + 1 && t[o + 1].y > t[o].y + t[o].height) return void c(o, n / 2);
            c(i - 1, n / 2)
        }

        function c(e, i) {
            for (var n = e; n >= 0 && !(t[n].y - i < l) && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1].height)); n--) ;
        }

        function d(t, e, i, n, o, a) {
            for (var r = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t.length; l > s; s++) if ("none" === t[s].labelAlignTo) {
                var u = Math.abs(t[s].y - n), h = t[s].len, c = t[s].len2,
                    d = o + h > u ? Math.sqrt((o + h + c) * (o + h + c) - u * u) : Math.abs(t[s].x - i);
                e && d >= r && (d = r - 10), !e && r >= d && (d = r + 10), t[s].x = i + d * a, r = d
            }
        }

        t.sort(function (t, e) {
            return t.y - e.y
        });
        for (var f, p = 0, g = t.length, m = [], v = [], y = 0; g > y; y++) {
            if ("outer" === t[y].position && "labelLine" === t[y].labelAlignTo) {
                var x = t[y].x - u;
                t[y].linePoints[1][0] += x, t[y].x = u
            }
            f = t[y].y - p, 0 > f && h(y, g, -f, o), p = t[y].y + t[y].height
        }
        0 > r - p && c(g - 1, p - r);
        for (var y = 0; g > y; y++) t[y].y >= i ? v.push(t[y]) : m.push(t[y]);
        d(m, !1, e, i, n, o), d(v, !0, e, i, n, o)
    }

    function sf(t, e, i, n, o, a, r, s) {
        for (var l = [], u = [], h = Number.MAX_VALUE, c = -Number.MAX_VALUE, d = 0; d < t.length; d++) lf(t[d]) || (t[d].x < e ? (h = Math.min(h, t[d].x), l.push(t[d])) : (c = Math.max(c, t[d].x), u.push(t[d])));
        rf(u, e, i, n, 1, o, a, r, s, c), rf(l, e, i, n, -1, o, a, r, s, h);
        for (var d = 0; d < t.length; d++) {
            var f = t[d];
            if (!lf(f)) {
                var p = f.linePoints;
                if (p) {
                    var g, m = "edge" === f.labelAlignTo, v = f.textRect.width;
                    g = m ? f.x < e ? p[2][0] - f.labelDistance - r - f.labelMargin : r + o - f.labelMargin - p[2][0] - f.labelDistance : f.x < e ? f.x - r - f.bleedMargin : r + o - f.x - f.bleedMargin, g < f.textRect.width && (f.text = Ji(f.text, g, f.font), "edge" === f.labelAlignTo && (v = Ui(f.text, f.font)));
                    var y = p[1][0] - p[2][0];
                    m ? p[2][0] = f.x < e ? r + f.labelMargin + v + f.labelDistance : r + o - f.labelMargin - v - f.labelDistance : (p[2][0] = f.x < e ? f.x + f.labelDistance : f.x - f.labelDistance, p[1][0] = p[2][0] + y), p[1][1] = p[2][1] = f.y
                }
            }
        }
    }

    function lf(t) {
        return "center" === t.position
    }

    function uf(t, e) {
        return es(t.getBoxLayoutParams(), {width: e.getWidth(), height: e.getHeight()})
    }

    function hf() {
        this.group = new iI
    }

    function cf(t) {
        return _(t) || (t = [+t, +t]), t
    }

    function df(t, e) {
        var i = e.rippleEffectColor || e.color;
        t.eachChild(function (t) {
            t.attr({
                z: e.z,
                zlevel: e.zlevel,
                style: {stroke: "stroke" === e.brushType ? i : null, fill: "fill" === e.brushType ? i : null}
            })
        })
    }

    function ff(t, e) {
        iI.call(this);
        var i = new Cd(t, e), n = new iI;
        this.add(i), this.add(n), n.beforeUpdate = function () {
            this.attr(i.getScale())
        }, this.updateData(t, e)
    }

    function pf(t, e, i) {
        var n = t.ends;
        return new _O({shape: {points: i ? vf(n, t) : n}, z2: 100})
    }

    function gf(t, e) {
        for (var i = !0, n = 0; n < e.ends.length; n++) if (t.contain(e.ends[n][0], e.ends[n][1])) {
            i = !1;
            break
        }
        return i
    }

    function mf(t, e, i, n) {
        var o = e.getItemModel(i), a = o.getModel(vO), r = e.getItemVisual(i, "color"),
            s = e.getItemVisual(i, "borderColor") || r, l = a.getItemStyle(xO);
        t.useStyle(l), t.style.strokeNoScale = !0, t.style.fill = r, t.style.stroke = s, t.__simpleBox = n;
        var u = o.getModel(yO).getItemStyle();
        Wa(t, u)
    }

    function vf(t, e) {
        return p(t, function (t) {
            return t = t.slice(), t[1] = e.initBaseline, t
        })
    }

    function yf(t, e, i) {
        var n = t.getData(), o = n.getLayout("largePoints"), a = new wO({shape: {points: o}, __sign: 1});
        e.add(a);
        var r = new wO({shape: {points: o}, __sign: -1});
        e.add(r), xf(1, a, t, n), xf(-1, r, t, n), i && (a.incremental = !0, r.incremental = !0)
    }

    function xf(t, e, i, n) {
        var o = t > 0 ? "P" : "N", a = n.getVisual("borderColor" + o) || n.getVisual("color" + o),
            r = i.getModel(vO).getItemStyle(xO);
        e.useStyle(r), e.style.fill = null, e.style.stroke = a
    }

    function _f(t, e, i, n, o) {
        var a;
        return a = i > n ? -1 : n > i ? 1 : e > 0 ? t.get(o, e - 1) <= n ? 1 : -1 : 1
    }

    function wf(t, e) {
        var i, n = t.getBaseAxis(),
            o = "category" === n.type ? n.getBandWidth() : (i = n.getExtent(), Math.abs(i[1] - i[0]) / e.count()),
            a = Ir(C(t.get("barMaxWidth"), o), o), r = Ir(C(t.get("barMinWidth"), 1), o), s = t.get("barWidth");
        return null != s ? Ir(s, o) : Math.max(Math.min(o / 2, a), r)
    }

    function bf(t, e, i) {
        Zk.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model
    }

    function Sf(t, e, i) {
        this._model = t, this.dimensions = [], this._indicatorAxes = p(t.getIndicatorModels(), function (t, e) {
            var i = "indicator_" + e, n = new bf(i, "log" === t.get("axisType") ? new Dk : new ak);
            return n.name = t.get("name"), n.model = t, t.axis = n, this.dimensions.push(i), n
        }, this), this.resize(t, i), this.cx, this.cy, this.r, this.r0, this.startAngle
    }

    function Mf(t, e) {
        return s({show: e}, t)
    }

    function If(t) {
        return _(t) || (t = [+t, +t]), t
    }

    function Tf(t) {
        return !isNaN(t[0]) && !isNaN(t[1])
    }

    function Af(t) {
        return [t.cx, t.cy]
    }

    function Df() {
        var t = QS();
        this.canvas = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {}
    }

    function Cf(t, e, i) {
        var n = t[1] - t[0];
        e = p(e, function (e) {
            return {interval: [(e.interval[0] - t[0]) / n, (e.interval[1] - t[0]) / n]}
        });
        var o = e.length, a = 0;
        return function (t) {
            for (var n = a; o > n; n++) {
                var r = e[n].interval;
                if (r[0] <= t && t <= r[1]) {
                    a = n;
                    break
                }
            }
            if (n === o) for (var n = a - 1; n >= 0; n--) {
                var r = e[n].interval;
                if (r[0] <= t && t <= r[1]) {
                    a = n;
                    break
                }
            }
            return n >= 0 && o > n && i[n]
        }
    }

    function Lf(t, e) {
        var i = t[1] - t[0];
        return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i], function (t) {
            return t >= e[0] && t <= e[1]
        }
    }

    function kf(t) {
        var e = t.dimensions;
        return "lng" === e[0] && "lat" === e[1]
    }

    function Pf(t) {
        var e = t.mainData, i = t.datas;
        i || (i = {main: e}, t.datasAttr = {main: "data"}), t.datas = t.mainData = null, Bf(e, i, t), RO(i, function (i) {
            RO(e.TRANSFERABLE_METHODS, function (e) {
                i.wrapMethod(e, x(Of, t))
            })
        }), e.wrapMethod("cloneShallow", x(Nf, t)), RO(e.CHANGABLE_METHODS, function (i) {
            e.wrapMethod(i, x(Ef, t))
        }), O(i[e.dataType] === e)
    }

    function Of(t, e) {
        if (zf(this)) {
            var i = r({}, this[zO]);
            i[this.dataType] = e, Bf(e, i, t)
        } else Vf(e, this.dataType, this[BO], t);
        return e
    }

    function Ef(t, e) {
        return t.struct && t.struct.update(this), e
    }

    function Nf(t, e) {
        return RO(e[zO], function (i, n) {
            i !== e && Vf(i.cloneShallow(), n, e, t)
        }), e
    }

    function Rf(t) {
        var e = this[BO];
        return null == t || null == e ? e : e[zO][t]
    }

    function zf(t) {
        return t[BO] === t
    }

    function Bf(t, e, i) {
        t[zO] = {}, RO(e, function (e, n) {
            Vf(e, n, t, i)
        })
    }

    function Vf(t, e, i, n) {
        i[zO][e] = t, t[BO] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = Rf
    }

    function Gf(t) {
        this.root, this.data, this._nodes = [], this.hostModel = t
    }

    function Ff(t, e) {
        var i = e.children;
        t.parentNode !== e && (i.push(t), t.parentNode = e)
    }

    function Wf(t) {
        t.hierNode = {
            defaultAncestor: null,
            ancestor: t,
            prelim: 0,
            modifier: 0,
            change: 0,
            shift: 0,
            i: 0,
            thread: null
        };
        for (var e, i, n = [t]; e = n.pop();) if (i = e.children, e.isExpand && i.length) for (var o = i.length, a = o - 1; a >= 0; a--) {
            var r = i[a];
            r.hierNode = {
                defaultAncestor: null,
                ancestor: r,
                prelim: 0,
                modifier: 0,
                change: 0,
                shift: 0,
                i: a,
                thread: null
            }, n.push(r)
        }
    }

    function Hf(t, e) {
        var i = t.isExpand ? t.children : [], n = t.parentNode.children, o = t.hierNode.i ? n[t.hierNode.i - 1] : null;
        if (i.length) {
            jf(t);
            var a = (i[0].hierNode.prelim + i[i.length - 1].hierNode.prelim) / 2;
            o ? (t.hierNode.prelim = o.hierNode.prelim + e(t, o), t.hierNode.modifier = t.hierNode.prelim - a) : t.hierNode.prelim = a
        } else o && (t.hierNode.prelim = o.hierNode.prelim + e(t, o));
        t.parentNode.hierNode.defaultAncestor = qf(t, o, t.parentNode.hierNode.defaultAncestor || n[0], e)
    }

    function Zf(t) {
        var e = t.hierNode.prelim + t.parentNode.hierNode.modifier;
        t.setLayout({x: e}, !0), t.hierNode.modifier += t.parentNode.hierNode.modifier
    }

    function Uf(t) {
        return arguments.length ? t : tp
    }

    function Xf(t, e) {
        var i = {};
        return t -= Math.PI / 2, i.x = e * Math.cos(t), i.y = e * Math.sin(t), i
    }

    function Yf(t, e) {
        return es(t.getBoxLayoutParams(), {width: e.getWidth(), height: e.getHeight()})
    }

    function jf(t) {
        for (var e = t.children, i = e.length, n = 0, o = 0; --i >= 0;) {
            var a = e[i];
            a.hierNode.prelim += n, a.hierNode.modifier += n, o += a.hierNode.change, n += a.hierNode.shift + o
        }
    }

    function qf(t, e, i, n) {
        if (e) {
            for (var o = t, a = t, r = a.parentNode.children[0], s = e, l = o.hierNode.modifier, u = a.hierNode.modifier, h = r.hierNode.modifier, c = s.hierNode.modifier; s = Kf(s), a = $f(a), s && a;) {
                o = Kf(o), r = $f(r), o.hierNode.ancestor = t;
                var d = s.hierNode.prelim + c - a.hierNode.prelim - u + n(s, a);
                d > 0 && (Qf(Jf(s, t, i), t, d), u += d, l += d), c += s.hierNode.modifier, u += a.hierNode.modifier, l += o.hierNode.modifier, h += r.hierNode.modifier
            }
            s && !Kf(o) && (o.hierNode.thread = s, o.hierNode.modifier += c - l), a && !$f(r) && (r.hierNode.thread = a, r.hierNode.modifier += u - h, i = t)
        }
        return i
    }

    function Kf(t) {
        var e = t.children;
        return e.length && t.isExpand ? e[e.length - 1] : t.hierNode.thread
    }

    function $f(t) {
        var e = t.children;
        return e.length && t.isExpand ? e[0] : t.hierNode.thread
    }

    function Jf(t, e, i) {
        return t.hierNode.ancestor.parentNode === e.parentNode ? t.hierNode.ancestor : i
    }

    function Qf(t, e, i) {
        var n = i / (e.hierNode.i - t.hierNode.i);
        e.hierNode.change -= n, e.hierNode.shift += i, e.hierNode.modifier += i, e.hierNode.prelim += i, t.hierNode.change += n
    }

    function tp(t, e) {
        return t.parentNode === e.parentNode ? 1 : 2
    }

    function ep() {
        AM.call(this)
    }

    function ip(t) {
        this.name = t, this.zoomLimit, AM.call(this), this._roamTransformable = new ep, this._rawTransformable = new ep, this._center, this._zoom
    }

    function np(t, e, i, n) {
        var o = i.seriesModel, a = o ? o.coordinateSystem : null;
        return a === this ? a[t](n) : null
    }

    function op(t, e, i) {
        var n = t.target, o = n.position;
        o[0] += e, o[1] += i, n.dirty()
    }

    function ap(t, e, i, n) {
        var o = t.target, a = t.zoomLimit, r = o.position, s = o.scale, l = t.zoom = t.zoom || 1;
        if (l *= e, a) {
            var u = a.min || 0, h = a.max || 1 / 0;
            l = Math.max(Math.min(h, l), u)
        }
        var c = l / t.zoom;
        t.zoom = l, r[0] -= (i - r[0]) * (c - 1), r[1] -= (n - r[1]) * (c - 1), s[0] *= c, s[1] *= c, o.dirty()
    }

    function rp(t, e, i) {
        var n = up(t);
        n[e] = i
    }

    function sp(t, e, i) {
        var n = up(t), o = n[e];
        o === i && (n[e] = null)
    }

    function lp(t, e) {
        return !!up(t)[e]
    }

    function up(t) {
        return t[FO] || (t[FO] = {})
    }

    function hp(t) {
        this.pointerChecker, this._zr = t, this._opt = {};
        var e = y, i = e(cp, this), o = e(dp, this), a = e(fp, this), r = e(pp, this), l = e(gp, this);
        hM.call(this), this.setPointerChecker = function (t) {
            this.pointerChecker = t
        }, this.enable = function (e, u) {
            this.disable(), this._opt = s(n(u) || {}, {
                zoomOnMouseWheel: !0,
                moveOnMouseMove: !0,
                moveOnMouseWheel: !1,
                preventDefaultMouseMove: !0
            }), null == e && (e = !0), (e === !0 || "move" === e || "pan" === e) && (t.on("mousedown", i), t.on("mousemove", o), t.on("mouseup", a)), (e === !0 || "scale" === e || "zoom" === e) && (t.on("mousewheel", r), t.on("pinch", l))
        }, this.disable = function () {
            t.off("mousedown", i), t.off("mousemove", o), t.off("mouseup", a), t.off("mousewheel", r), t.off("pinch", l)
        }, this.dispose = this.disable, this.isDragging = function () {
            return this._dragging
        }, this.isPinching = function () {
            return this._pinching
        }
    }

    function cp(t) {
        if (!(Ie(t) || t.target && t.target.draggable)) {
            var e = t.offsetX, i = t.offsetY;
            this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e, this._y = i, this._dragging = !0)
        }
    }

    function dp(t) {
        if (this._dragging && yp("moveOnMouseMove", t, this._opt) && "pinch" !== t.gestureEvent && !lp(this._zr, "globalPan")) {
            var e = t.offsetX, i = t.offsetY, n = this._x, o = this._y, a = e - n, r = i - o;
            this._x = e, this._y = i, this._opt.preventDefaultMouseMove && vM(t.event), vp(this, "pan", "moveOnMouseMove", t, {
                dx: a,
                dy: r,
                oldX: n,
                oldY: o,
                newX: e,
                newY: i
            })
        }
    }

    function fp(t) {
        Ie(t) || (this._dragging = !1)
    }

    function pp(t) {
        var e = yp("zoomOnMouseWheel", t, this._opt), i = yp("moveOnMouseWheel", t, this._opt), n = t.wheelDelta,
            o = Math.abs(n), a = t.offsetX, r = t.offsetY;
        if (0 !== n && (e || i)) {
            if (e) {
                var s = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, l = n > 0 ? s : 1 / s;
                mp(this, "zoom", "zoomOnMouseWheel", t, {scale: l, originX: a, originY: r})
            }
            if (i) {
                var u = Math.abs(n), h = (n > 0 ? 1 : -1) * (u > 3 ? .4 : u > 1 ? .15 : .05);
                mp(this, "scrollMove", "moveOnMouseWheel", t, {scrollDelta: h, originX: a, originY: r})
            }
        }
    }

    function gp(t) {
        if (!lp(this._zr, "globalPan")) {
            var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
            mp(this, "zoom", null, t, {scale: e, originX: t.pinchX, originY: t.pinchY})
        }
    }

    function mp(t, e, i, n, o) {
        t.pointerChecker && t.pointerChecker(n, o.originX, o.originY) && (vM(n.event), vp(t, e, i, n, o))
    }

    function vp(t, e, i, n, o) {
        o.isAvailableBehavior = y(yp, null, i, n), t.trigger(e, o)
    }

    function yp(t, e, i) {
        var n = i[t];
        return !t || n && (!b(n) || e.event[n + "Key"])
    }

    function xp(t, e, i) {
        var n = e.getComponentByElement(t.topTarget), o = n && n.coordinateSystem;
        return n && n !== i && !WO[n.mainType] && o && o.model !== i
    }

    function _p(t, e) {
        var i = t.getItemLayout(e);
        return i && !isNaN(i.x) && !isNaN(i.y) && "none" !== t.getItemVisual(e, "symbol")
    }

    function wp(t, e, i) {
        return i.itemModel = e, i.itemStyle = e.getModel("itemStyle").getItemStyle(), i.hoverItemStyle = e.getModel("emphasis.itemStyle").getItemStyle(), i.lineStyle = e.getModel("lineStyle").getLineStyle(), i.labelModel = e.getModel("label"), i.hoverLabelModel = e.getModel("emphasis.label"), i.symbolInnerColor = t.isExpand === !1 && 0 !== t.children.length ? i.itemStyle.fill : "#fff", i
    }

    function bp(t, e, i, n, o, a) {
        var r = !i, s = t.tree.getNodeByDataIndex(e), l = s.getModel(), a = wp(s, l, a), u = t.tree.root,
            h = s.parentNode === u ? s : s.parentNode || s, c = t.getItemGraphicEl(h.dataIndex), d = h.getLayout(),
            f = c ? {x: c.position[0], y: c.position[1], rawX: c.__radialOldRawX, rawY: c.__radialOldRawY} : d,
            p = s.getLayout();
        r ? (i = new Cd(t, e, a), i.attr("position", [f.x, f.y])) : i.updateData(t, e, a), i.__radialOldRawX = i.__radialRawX, i.__radialOldRawY = i.__radialRawY, i.__radialRawX = p.rawX, i.__radialRawY = p.rawY, n.add(i), t.setItemGraphicEl(e, i), or(i, {position: [p.x, p.y]}, o);
        var g = i.getSymbolPath();
        if ("radial" === a.layout) {
            var m, v, y = u.children[0], x = y.getLayout(), _ = y.children.length;
            if (p.x === x.x && s.isExpand === !0) {
                var w = {};
                w.x = (y.children[0].getLayout().x + y.children[_ - 1].getLayout().x) / 2, w.y = (y.children[0].getLayout().y + y.children[_ - 1].getLayout().y) / 2, m = Math.atan2(w.y - x.y, w.x - x.x), 0 > m && (m = 2 * Math.PI + m), v = w.x < x.x, v && (m -= Math.PI)
            } else m = Math.atan2(p.y - x.y, p.x - x.x), 0 > m && (m = 2 * Math.PI + m), 0 === s.children.length || 0 !== s.children.length && s.isExpand === !1 ? (v = p.x < x.x, v && (m -= Math.PI)) : (v = p.x > x.x, v || (m -= Math.PI));
            var b = v ? "left" : "right", S = a.labelModel.get("rotate"), M = S * (Math.PI / 180);
            g.setStyle({
                textPosition: a.labelModel.get("position") || b,
                textRotation: null == S ? -m : M,
                textOrigin: "center",
                verticalAlign: "middle"
            })
        }
        Sp(o, s, u, i, f, d, p, n, a)
    }

    function Sp(t, e, i, n, o, a, r, l, u) {
        var h = u.edgeShape, c = n.__edge;
        if ("curve" === h) e.parentNode && e.parentNode !== i && (c || (c = n.__edge = new OA({
            shape: Ip(u, o, o),
            style: s({opacity: 0, strokeNoScale: !0}, u.lineStyle)
        })), or(c, {
            shape: Ip(u, a, r),
            style: s({opacity: 1}, u.lineStyle)
        }, t)); else if ("polyline" === h) if ("orthogonal" === u.layout) {
            if (e !== i && e.children && 0 !== e.children.length && e.isExpand === !0) {
                for (var d = e.children, f = [], p = 0; p < d.length; p++) {
                    var g = d[p].getLayout();
                    f.push([g.x, g.y])
                }
                c || (c = n.__edge = new HO({
                    shape: {
                        parentPoint: [r.x, r.y],
                        childPoints: [[r.x, r.y]],
                        orient: u.orient,
                        forkPosition: u.edgeForkPosition
                    }, style: s({opacity: 0, strokeNoScale: !0}, u.lineStyle)
                })), or(c, {shape: {parentPoint: [r.x, r.y], childPoints: f}, style: s({opacity: 1}, u.lineStyle)}, t)
            }
        } else if (BS) throw new Error("The polyline edgeShape can only be used in orthogonal layout");
        l.add(c)
    }

    function Mp(t, e, i, n, o, a) {
        for (var r, s = t.tree.getNodeByDataIndex(e), l = t.tree.root, u = s.getModel(), a = wp(s, u, a), h = s.parentNode === l ? s : s.parentNode || s, c = a.edgeShape; r = h.getLayout(), null == r;) h = h.parentNode === l ? h : h.parentNode || h;
        or(i, {position: [r.x + 1, r.y + 1]}, o, function () {
            n.remove(i), t.setItemGraphicEl(e, null)
        }), i.fadeOut(null, {keepLabel: !0});
        var d = t.getItemGraphicEl(h.dataIndex), f = d.__edge,
            p = i.__edge || (h.isExpand === !1 || 1 === h.children.length ? f : void 0), c = a.edgeShape;
        p && ("curve" === c ? or(p, {shape: Ip(a, r, r), style: {opacity: 0}}, o, function () {
            n.remove(p)
        }) : "polyline" === c && "orthogonal" === a.layout && or(p, {
            shape: {
                parentPoint: [r.x, r.y],
                childPoints: [[r.x, r.y]]
            }, style: {opacity: 0}
        }, o, function () {
            n.remove(p)
        }))
    }

    function Ip(t, e, i) {
        var n, o, a, r, s, l, u, h, c = t.orient;
        if ("radial" === t.layout) {
            s = e.rawX, u = e.rawY, l = i.rawX, h = i.rawY;
            var d = Xf(s, u), f = Xf(s, u + (h - u) * t.curvature), p = Xf(l, h + (u - h) * t.curvature), g = Xf(l, h);
            return {x1: d.x, y1: d.y, x2: g.x, y2: g.y, cpx1: f.x, cpy1: f.y, cpx2: p.x, cpy2: p.y}
        }
        return s = e.x, u = e.y, l = i.x, h = i.y, ("LR" === c || "RL" === c) && (n = s + (l - s) * t.curvature, o = u, a = l + (s - l) * t.curvature, r = h), ("TB" === c || "BT" === c) && (n = s, o = u + (h - u) * t.curvature, a = l, r = h + (u - h) * t.curvature), {
            x1: s,
            y1: u,
            x2: l,
            y2: h,
            cpx1: n,
            cpy1: o,
            cpx2: a,
            cpy2: r
        }
    }

    function Tp(t, e, i) {
        var n = t.getZoom(), o = t.getCenter(), a = e.zoom, r = t.dataToPoint(o);
        if (null != e.dx && null != e.dy) {
            r[0] -= e.dx, r[1] -= e.dy;
            var o = t.pointToData(r);
            t.setCenter(o)
        }
        if (null != a) {
            if (i) {
                var s = i.min || 0, l = i.max || 1 / 0;
                a = Math.max(Math.min(n * a, l), s) / n
            }
            t.scale[0] *= a, t.scale[1] *= a;
            var u = t.position, h = (e.originX - u[0]) * (a - 1), c = (e.originY - u[1]) * (a - 1);
            u[0] -= h, u[1] -= c, t.updateTransform();
            var o = t.pointToData(r);
            t.setCenter(o), t.setZoom(a * n)
        }
        return {center: t.getCenter(), zoom: t.getZoom()}
    }

    function Ap(t, e, i) {
        for (var n, o = [t], a = []; n = o.pop();) if (a.push(n), n.isExpand) {
            var r = n.children;
            if (r.length) for (var s = 0; s < r.length; s++) o.push(r[s])
        }
        for (; n = a.pop();) e(n, i)
    }

    function Dp(t, e) {
        for (var i, n = [t]; i = n.pop();) if (e(i), i.isExpand) {
            var o = i.children;
            if (o.length) for (var a = o.length - 1; a >= 0; a--) n.push(o[a])
        }
    }

    function Cp(t, e) {
        var i = Yf(t, e);
        t.layoutInfo = i;
        var n = t.get("layout"), o = 0, a = 0, r = null;
        "radial" === n ? (o = 2 * Math.PI, a = Math.min(i.height, i.width) / 2, r = Uf(function (t, e) {
            return (t.parentNode === e.parentNode ? 1 : 2) / t.depth
        })) : (o = i.width, a = i.height, r = Uf());
        var s = t.getData().tree.root, l = s.children[0];
        if (l) {
            Wf(s), Ap(l, Hf, r), s.hierNode.modifier = -l.hierNode.prelim, Dp(l, Zf);
            var u = l, h = l, c = l;
            Dp(l, function (t) {
                var e = t.getLayout().x;
                e < u.getLayout().x && (u = t), e > h.getLayout().x && (h = t), t.depth > c.depth && (c = t)
            });
            var d = u === h ? 1 : r(u, h) / 2, f = d - u.getLayout().x, p = 0, g = 0, m = 0, v = 0;
            if ("radial" === n) p = o / (h.getLayout().x + d + f), g = a / (c.depth - 1 || 1), Dp(l, function (t) {
                m = (t.getLayout().x + f) * p, v = (t.depth - 1) * g;
                var e = Xf(m, v);
                t.setLayout({x: e.x, y: e.y, rawX: m, rawY: v}, !0)
            }); else {
                var y = t.getOrient();
                "RL" === y || "LR" === y ? (g = a / (h.getLayout().x + d + f), p = o / (c.depth - 1 || 1), Dp(l, function (t) {
                    v = (t.getLayout().x + f) * g, m = "LR" === y ? (t.depth - 1) * p : o - (t.depth - 1) * p, t.setLayout({
                        x: m,
                        y: v
                    }, !0)
                })) : ("TB" === y || "BT" === y) && (p = o / (h.getLayout().x + d + f), g = a / (c.depth - 1 || 1), Dp(l, function (t) {
                    m = (t.getLayout().x + f) * p, v = "TB" === y ? (t.depth - 1) * g : a - (t.depth - 1) * g, t.setLayout({
                        x: m,
                        y: v
                    }, !0)
                }))
            }
        }
    }

    function Lp(t, e, i) {
        if (t && u(e, t.type) >= 0) {
            var n = i.getData().tree.root, o = t.targetNode;
            if ("string" == typeof o && (o = n.getNodeById(o)), o && n.contains(o)) return {node: o};
            var a = t.targetNodeId;
            if (null != a && (o = n.getNodeById(a))) return {node: o}
        }
    }

    function kp(t) {
        for (var e = []; t;) t = t.parentNode, t && e.push(t);
        return e.reverse()
    }

    function Pp(t, e) {
        var i = kp(t);
        return u(i, e) >= 0
    }

    function Op(t, e) {
        for (var i = []; t;) {
            var n = t.dataIndex;
            i.push({name: t.name, dataIndex: n, value: e.getRawValue(n)}), t = t.parentNode
        }
        return i.reverse(), i
    }

    function Ep(t) {
        var e = 0;
        f(t.children, function (t) {
            Ep(t);
            var i = t.value;
            _(i) && (i = i[0]), e += i
        });
        var i = t.value;
        _(i) && (i = i[0]), (null == i || isNaN(i)) && (i = e), 0 > i && (i = 0), _(t.value) ? t.value[0] = i : t.value = i
    }

    function Np(t, e) {
        var i = e.get("color");
        if (i) {
            t = t || [];
            var n;
            if (f(t, function (t) {
                var e = new vr(t), i = e.get("color");
                (e.get("itemStyle.color") || i && "none" !== i) && (n = !0)
            }), !n) {
                var o = t[0] || (t[0] = {});
                o.color = i.slice()
            }
            return t
        }
    }

    function Rp(t) {
        this.group = new iI, t.add(this.group)
    }

    function zp(t, e, i, n, o, a) {
        var r = [[o ? t : t - YO, e], [t + i, e], [t + i, e + n], [o ? t : t - YO, e + n]];
        return !a && r.splice(2, 0, [t + i + YO, e + n / 2]), !o && r.push([t, e + n / 2]), r
    }

    function Bp(t, e, i) {
        t.eventData = {
            componentType: "series",
            componentSubType: "treemap",
            componentIndex: e.componentIndex,
            seriesIndex: e.componentIndex,
            seriesName: e.name,
            seriesType: "treemap",
            selfType: "breadcrumb",
            nodeData: {dataIndex: i && i.dataIndex, name: i && i.name},
            treePathInfo: i && Op(i, e)
        }
    }

    function Vp() {
        var t, e = [], i = {};
        return {
            add: function (t, n, o, a, r) {
                return b(a) && (r = a, a = 0), i[t.id] ? !1 : (i[t.id] = 1, e.push({
                    el: t,
                    target: n,
                    time: o,
                    delay: a,
                    easing: r
                }), !0)
            }, done: function (e) {
                return t = e, this
            }, start: function () {
                function n() {
                    o--, o || (e.length = 0, i = {}, t && t())
                }

                for (var o = e.length, a = 0, r = e.length; r > a; a++) {
                    var s = e[a];
                    s.el.animateTo(s.target, s.time, s.delay, s.easing, n)
                }
                return this
            }
        }
    }

    function Gp() {
        return {nodeGroup: [], background: [], content: []}
    }

    function Fp(t, e, i, o, a, s, l, u, h, c) {
        function d(e, i, n) {
            if (i.dataIndex = l.dataIndex, i.seriesIndex = t.seriesIndex, i.setShape({
                x: 0,
                y: 0,
                width: b,
                height: S
            }), I) p(i); else {
                i.invisible = !1;
                var o = l.getVisual("borderColor", !0), a = P.get("borderColor"), r = sE(k);
                r.fill = o;
                var s = rE(P);
                if (s.fill = a, n) {
                    var u = b - 2 * M;
                    g(r, s, o, u, C, {x: M, y: 0, width: u, height: C})
                } else r.text = s.text = null;
                i.setStyle(r), Ra(i, s)
            }
            e.add(i)
        }

        function f(e, i) {
            i.dataIndex = l.dataIndex, i.seriesIndex = t.seriesIndex;
            var n = Math.max(b - 2 * M, 0), o = Math.max(S - 2 * M, 0);
            if (i.culling = !0, i.setShape({x: M, y: M, width: n, height: o}), I) p(i);
            else {
                i.invisible = !1;
                var a = l.getVisual("color", !0), r = sE(k);
                r.fill = a;
                var s = rE(P);
                g(r, s, a, n, o), i.setStyle(r), Ra(i, s)
            }
            e.add(i)
        }

        function p(t) {
            !t.invisible && s.push(t)
        }

        function g(e, i, o, a, r, s) {
            var u = E.get("name"), h = E.getModel(s ? eE : QO), c = E.getModel(s ? iE : tE), d = h.getShallow("show");
            Xa(e, i, h, c, {
                defaultText: d ? u : null,
                autoColor: o,
                isRectText: !0,
                labelFetcher: t,
                labelDataIndex: l.dataIndex,
                labelProp: s ? "upperLabel" : "label"
            }), m(e, s, _), m(i, s, _), s && (e.textRect = n(s)), e.truncate = d && h.get("ellipsis") ? {
                outerWidth: a,
                outerHeight: r,
                minChar: 2
            } : null
        }

        function m(e, i, n) {
            var o = e.text;
            if (!i && n.isLeafRoot && null != o) {
                var a = t.get("drillDownIcon", !0);
                e.text = a ? a + " " + o : o
            }
        }

        function v(t, n, o, r) {
            var s = null != A && i[t][A], l = a[t];
            return s ? (i[t][A] = null, y(l, s, t)) : I || (s = new n({z: Wp(o, r)}), s.__tmDepth = o, s.__tmStorageName = t, x(l, s, t)), e[t][T] = s
        }

        function y(t, e, i) {
            var n = t[T] = {};
            n.old = "nodeGroup" === i ? e.position.slice() : r({}, e.shape)
        }

        function x(t, e, i) {
            var n = t[T] = {}, r = l.parentNode;
            if (r && (!o || "drillDown" === o.direction)) {
                var s = 0, u = 0, h = a.background[r.getRawIndex()];
                !o && h && h.old && (s = h.old.width, u = h.old.height), n.old = "nodeGroup" === i ? [0, u] : {
                    x: s,
                    y: u,
                    width: 0,
                    height: 0
                }
            }
            n.fadein = "nodeGroup" !== i
        }

        if (l) {
            var _ = l.getLayout(), w = t.getData();
            if (w.setItemGraphicEl(l.dataIndex, null), _ && _.isInView) {
                var b = _.width, S = _.height, M = _.borderWidth, I = _.invisible, T = l.getRawIndex(),
                    A = u && u.getRawIndex(), D = l.viewChildren, C = _.upperHeight, L = D && D.length,
                    k = l.getModel("itemStyle"), P = l.getModel("emphasis.itemStyle"), O = v("nodeGroup", qO);
                if (O) {
                    if (h.add(O), O.attr("position", [_.x || 0, _.y || 0]), O.__tmNodeWidth = b, O.__tmNodeHeight = S, _.isAboveViewRoot) return O;
                    var E = l.getModel(), N = v("background", KO, c, oE);
                    if (N && d(O, N, L && _.upperLabelHeight), L) Za(O) && Ha(O, !1), N && (Ha(N, !0), w.setItemGraphicEl(l.dataIndex, N)); else {
                        var R = v("content", KO, c, aE);
                        R && f(O, R), N && Za(N) && Ha(N, !1), Ha(O, !0), w.setItemGraphicEl(l.dataIndex, O)
                    }
                    return O
                }
            }
        }
    }

    function Wp(t, e) {
        var i = t * nE + e;
        return (i - 1) / i
    }

    function Hp(t) {
        var e = t.pieceList;
        t.hasSpecialVisual = !1, f(e, function (e, i) {
            e.originIndex = i, null != e.visual && (t.hasSpecialVisual = !0)
        })
    }

    function Zp(t) {
        var e = t.categories, i = t.visual, n = t.categoryMap = {};
        if (cE(e, function (t, e) {
            n[t] = e
        }), !_(i)) {
            var o = [];
            S(i) ? cE(i, function (t, e) {
                var i = n[e];
                o[null != i ? i : fE] = t
            }) : o[fE] = i, i = Qp(t, o)
        }
        for (var a = e.length - 1; a >= 0; a--) null == i[a] && (delete n[e[a]], e.pop())
    }

    function Up(t, e) {
        var i = t.visual, n = [];
        S(i) ? cE(i, function (t) {
            n.push(t)
        }) : null != i && n.push(i);
        var o = {color: 1, symbol: 1};
        e || 1 !== n.length || o.hasOwnProperty(t.type) || (n[1] = n[0]), Qp(t, n)
    }

    function Xp(t) {
        return {
            applyVisual: function (e, i, n) {
                e = this.mapValueToVisual(e), n("color", t(i("color"), e))
            }, _doMap: $p([0, 1])
        }
    }

    function Yp(t) {
        var e = this.option.visual;
        return e[Math.round(Mr(t, [0, 1], [0, e.length - 1], !0))] || {}
    }

    function jp(t) {
        return function (e, i, n) {
            n(t, this.mapValueToVisual(e))
        }
    }

    function qp(t) {
        var e = this.option.visual;
        return e[this.option.loop && t !== fE ? t % e.length : t]
    }

    function Kp() {
        return this.option.visual[0]
    }

    function $p(t) {
        return {
            linear: function (e) {
                return Mr(e, t, this.option.visual, !0)
            }, category: qp, piecewise: function (e, i) {
                var n = Jp.call(this, i);
                return null == n && (n = Mr(e, t, this.option.visual, !0)), n
            }, fixed: Kp
        }
    }

    function Jp(t) {
        var e = this.option, i = e.pieceList;
        if (e.hasSpecialVisual) {
            var n = pE.findPieceIndex(t, i), o = i[n];
            if (o && o.visual) return o.visual[this.type]
        }
    }

    function Qp(t, e) {
        return t.visual = e, "color" === t.type && (t.parsedVisual = p(e, function (t) {
            return ti(t)
        })), e
    }

    function tg(t, e, i) {
        return t ? i >= e : i > e
    }

    function eg(t, e, i, n) {
        var o = t.getModel(), a = t.getLayout();
        if (a && !a.invisible && a.isInView) {
            var r, s = t.getModel(yE), l = ig(s, e, n), u = s.get("borderColor"), h = s.get("borderColorSaturation");
            null != h && (r = ng(l, t), u = og(h, r)), t.setVisual("borderColor", u);
            var c = t.viewChildren;
            if (c && c.length) {
                var d = rg(t, o, a, s, l, c);
                f(c, function (t, e) {
                    if (t.depth >= i.length || t === i[t.depth]) {
                        var a = lg(o, l, t, e, d, n);
                        eg(t, a, i, n)
                    }
                })
            } else r = ng(l, t), t.setVisual("color", r)
        }
    }

    function ig(t, e, i) {
        var n = r({}, e), o = i.designatedVisualItemStyle;
        return f(["color", "colorAlpha", "colorSaturation"], function (i) {
            o[i] = e[i];
            var a = t.get(i);
            o[i] = null, null != a && (n[i] = a)
        }), n
    }

    function ng(t) {
        var e = ag(t, "color");
        if (e) {
            var i = ag(t, "colorAlpha"), n = ag(t, "colorSaturation");
            return n && (e = si(e, null, null, n)), i && (e = li(e, i)), e
        }
    }

    function og(t, e) {
        return null != e ? si(e, null, null, t) : null
    }

    function ag(t, e) {
        var i = t[e];
        return null != i && "none" !== i ? i : void 0
    }

    function rg(t, e, i, n, o, a) {
        if (a && a.length) {
            var r = sg(e, "color") || null != o.color && "none" !== o.color && (sg(e, "colorAlpha") || sg(e, "colorSaturation"));
            if (r) {
                var s = e.get("visualMin"), l = e.get("visualMax"), u = i.dataExtent.slice();
                null != s && s < u[0] && (u[0] = s), null != l && l > u[1] && (u[1] = l);
                var h = e.get("colorMappingBy"), c = {type: r.name, dataExtent: u, visual: r.range};
                "color" !== c.type || "index" !== h && "id" !== h ? c.mappingMethod = "linear" : (c.mappingMethod = "category", c.loop = !0);
                var d = new pE(c);
                return d.__drColorMappingBy = h, d
            }
        }
    }

    function sg(t, e) {
        var i = t.get(e);
        return vE(i) && i.length ? {name: e, range: i} : null
    }

    function lg(t, e, i, n, o, a) {
        var s = r({}, e);
        if (o) {
            var l = o.type, u = "color" === l && o.__drColorMappingBy,
                h = "index" === u ? n : "id" === u ? a.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));
            s[l] = o.mapValueToVisual(h)
        }
        return s
    }

    function ug(t, e, i, n) {
        var o, a;
        if (!t.isRemoved()) {
            var r = t.getLayout();
            o = r.width, a = r.height;
            var s = t.getModel(), l = s.get(ME), u = s.get(IE) / 2, h = xg(s), c = Math.max(l, h), d = l - u, f = c - u,
                s = t.getModel();
            t.setLayout({
                borderWidth: l,
                upperHeight: c,
                upperLabelHeight: h
            }, !0), o = _E(o - 2 * d, 0), a = _E(a - d - f, 0);
            var p = o * a, g = hg(t, s, p, e, i, n);
            if (g.length) {
                var m = {x: d, y: f, width: o, height: a}, v = wE(o, a), y = 1 / 0, x = [];
                x.area = 0;
                for (var _ = 0, w = g.length; w > _;) {
                    var b = g[_];
                    x.push(b), x.area += b.getLayout().area;
                    var S = pg(x, v, e.squareRatio);
                    y >= S ? (_++, y = S) : (x.area -= x.pop().getLayout().area, gg(x, v, m, u, !1), v = wE(m.width, m.height), x.length = x.area = 0, y = 1 / 0)
                }
                if (x.length && gg(x, v, m, u, !0), !i) {
                    var M = s.get("childrenVisibleMin");
                    null != M && M > p && (i = !0)
                }
                for (var _ = 0, w = g.length; w > _; _++) ug(g[_], e, i, n + 1)
            }
        }
    }

    function hg(t, e, i, n, o, a) {
        var r = t.children || [], s = n.sort;
        "asc" !== s && "desc" !== s && (s = null);
        var l = null != n.leafDepth && n.leafDepth <= a;
        if (o && !l) return t.viewChildren = [];
        r = m(r, function (t) {
            return !t.isRemoved()
        }), dg(r, s);
        var u = fg(e, r, s);
        if (0 === u.sum) return t.viewChildren = [];
        if (u.sum = cg(e, i, u.sum, s, r), 0 === u.sum) return t.viewChildren = [];
        for (var h = 0, c = r.length; c > h; h++) {
            var d = r[h].getValue() / u.sum * i;
            r[h].setLayout({area: d})
        }
        return l && (r.length && t.setLayout({isLeafRoot: !0}, !0), r.length = 0), t.viewChildren = r, t.setLayout({dataExtent: u.dataExtent}, !0), r
    }

    function cg(t, e, i, n, o) {
        if (!n) return i;
        for (var a = t.get("visibleMin"), r = o.length, s = r, l = r - 1; l >= 0; l--) {
            var u = o["asc" === n ? r - l - 1 : l].getValue();
            a > u / i * e && (s = l, i -= u)
        }
        return "asc" === n ? o.splice(0, r - s) : o.splice(s, r - s), i
    }

    function dg(t, e) {
        return e && t.sort(function (t, i) {
            var n = "asc" === e ? t.getValue() - i.getValue() : i.getValue() - t.getValue();
            return 0 === n ? "asc" === e ? t.dataIndex - i.dataIndex : i.dataIndex - t.dataIndex : n
        }), t
    }

    function fg(t, e, i) {
        for (var n = 0, o = 0, a = e.length; a > o; o++) n += e[o].getValue();
        var r, s = t.get("visualDimension");
        if (e && e.length) if ("value" === s && i) r = [e[e.length - 1].getValue(), e[0].getValue()], "asc" === i && r.reverse(); else {
            var r = [1 / 0, -1 / 0];
            SE(e, function (t) {
                var e = t.getValue(s);
                e < r[0] && (r[0] = e), e > r[1] && (r[1] = e)
            })
        } else r = [0 / 0, 0 / 0];
        return {sum: n, dataExtent: r}
    }

    function pg(t, e, i) {
        for (var n, o = 0, a = 1 / 0, r = 0, s = t.length; s > r; r++) n = t[r].getLayout().area, n && (a > n && (a = n), n > o && (o = n));
        var l = t.area * t.area, u = e * e * i;
        return l ? _E(u * o / l, l / (u * a)) : 1 / 0
    }

    function gg(t, e, i, n, o) {
        var a = e === i.width ? 0 : 1, r = 1 - a, s = ["x", "y"], l = ["width", "height"], u = i[s[a]],
            h = e ? t.area / e : 0;
        (o || h > i[l[r]]) && (h = i[l[r]]);
        for (var c = 0, d = t.length; d > c; c++) {
            var f = t[c], p = {}, g = h ? f.getLayout().area / h : 0, m = p[l[r]] = _E(h - 2 * n, 0),
                v = i[s[a]] + i[l[a]] - u, y = c === d - 1 || g > v ? v : g, x = p[l[a]] = _E(y - 2 * n, 0);
            p[s[r]] = i[s[r]] + wE(n, m / 2), p[s[a]] = u + wE(n, x / 2), u += y, f.setLayout(p, !0)
        }
        i[s[r]] += h, i[l[r]] -= h
    }

    function mg(t, e, i, n, o) {
        var a = (e || {}).node, r = [n, o];
        if (!a || a === i) return r;
        for (var s, l = n * o, u = l * t.option.zoomToNodeRatio; s = a.parentNode;) {
            for (var h = 0, c = s.children, d = 0, f = c.length; f > d; d++) h += c[d].getValue();
            var p = a.getValue();
            if (0 === p) return r;
            u *= h / p;
            var g = s.getModel(), m = g.get(ME), v = Math.max(m, xg(g, m));
            u += 4 * m * m + (3 * m + v) * Math.pow(u, .5), u > uD && (u = uD), a = s
        }
        l > u && (u = l);
        var y = Math.pow(u / l, .5);
        return [n * y, o * y]
    }

    function vg(t, e, i) {
        if (e) return {x: e.x, y: e.y};
        var n = {x: 0, y: 0};
        if (!i) return n;
        var o = i.node, a = o.getLayout();
        if (!a) return n;
        for (var r = [a.width / 2, a.height / 2], s = o; s;) {
            var l = s.getLayout();
            r[0] += l.x, r[1] += l.y, s = s.parentNode
        }
        return {x: t.width / 2 - r[0], y: t.height / 2 - r[1]}
    }

    function yg(t, e, i, n, o) {
        var a = t.getLayout(), r = i[o], s = r && r === t;
        if (!(r && !s || o === i.length && t !== n)) {
            t.setLayout({isInView: !0, invisible: !s && !e.intersect(a), isAboveViewRoot: s}, !0);
            var l = new Ti(e.x - a.x, e.y - a.y, e.width, e.height);
            SE(t.viewChildren || [], function (t) {
                yg(t, l, i, n, o + 1)
            })
        }
    }

    function xg(t) {
        return t.get(TE) ? t.get(AE) : 0
    }

    function _g(t) {
        var e = 0;
        f(t.children, function (t) {
            _g(t);
            var i = t.value;
            _(i) && (i = i[0]), e += i
        });
        var i = t.value;
        _(i) && (i = i[0]), (null == i || isNaN(i)) && (i = e), 0 > i && (i = 0), _(t.value) ? t.value[0] = i : t.value = i
    }

    function wg(t, e, i) {
        function n() {
            r.ignore = r.hoverIgnore
        }

        function o() {
            r.ignore = r.normalIgnore
        }

        iI.call(this);
        var a = new wA({z2: LE});
        a.seriesIndex = e.seriesIndex;
        var r = new vA({z2: kE, silent: t.getModel("label").get("silent")});
        this.add(a), this.add(r), this.updateData(!0, t, "normal", e, i), this.on("emphasis", n).on("normal", o).on("mouseover", n).on("mouseout", o)
    }

    function bg(t, e, i) {
        var n = t.getVisual("color"), o = t.getVisual("visualMeta");
        o && 0 !== o.length || (n = null);
        var a = t.getModel("itemStyle").get("color");
        if (a) return a;
        if (n) return n;
        if (0 === t.depth) return i.option.color[0];
        var r = i.option.color.length;
        return a = i.option.color[Sg(t) % r]
    }

    function Sg(t) {
        for (var e = t; e.depth > 1;) e = e.parentNode;
        var i = t.getAncestors()[0];
        return u(i.children, e)
    }

    function Mg(t, e, i) {
        return i === CE.NONE ? !1 : i === CE.SELF ? t === e : i === CE.ANCESTOR ? t === e || t.isAncestorOf(e) : t === e || t.isDescendantOf(e)
    }

    function Ig(t, e, i) {
        var n = e.getData();
        n.setItemVisual(t.dataIndex, "color", i)
    }

    function Tg(t, e) {
        var i = t.children || [];
        t.children = Ag(i, e), i.length && f(t.children, function (t) {
            Tg(t, e)
        })
    }

    function Ag(t, e) {
        if ("function" == typeof e) return t.sort(e);
        var i = "asc" === e;
        return t.sort(function (t, e) {
            var n = (t.getValue() - e.getValue()) * (i ? 1 : -1);
            return 0 === n ? (t.dataIndex - e.dataIndex) * (i ? -1 : 1) : n
        })
    }

    function Dg(t) {
        for (var e, i = 0; i < t.length; i++) {
            var n = t[i].getBoundingRect();
            e = e || n.clone(), e.union(n)
        }
        return e
    }

    function Cg(t, e) {
        var i, n, o = t.svgXML;
        try {
            i = o && $l(o, {ignoreViewBox: !0, ignoreRootClip: !0}) || {}, n = i.root, O(null != n)
        } catch (a) {
            throw new Error("Invalid svg format\n" + a.message)
        }
        var r = i.width, s = i.height, l = i.viewBoxRect;
        if (e || (e = null == r || null == s ? n.getBoundingRect() : new Ti(0, 0, 0, 0), null != r && (e.width = r), null != s && (e.height = s)), l) {
            var u = Kl(l, e.width, e.height), h = n;
            n = new iI, n.add(h), h.scale = u.scale, h.position = u.position
        }
        return n.setClipPath(new CA({shape: e.plain()})), {root: n, boundingRect: e}
    }

    function Lg(t) {
        return function (e, i) {
            var n = Pg(e), o = [];
            return f(n, function (n) {
                var a = tN[n.type][t];
                a && o.push(a(e, n, i))
            }), o
        }
    }

    function kg(t) {
        BS && console.error("Map " + t + " not exists. The GeoJSON of the map must be provided.")
    }

    function Pg(t) {
        var e = qC.retrieveMap(t) || [];
        return BS && (e.length || kg(t)), e
    }

    function Og(t) {
        var e = t.getItemStyle(), i = t.get("areaColor");
        return null != i && (e.fill = i), e
    }

    function Eg(t, e, i, n, o) {
        i.off("click"), i.off("mousedown"), e.get("selectedMode") && (i.on("mousedown", function () {
            t._mouseDownFlag = !0
        }), i.on("click", function (a) {
            if (t._mouseDownFlag) {
                t._mouseDownFlag = !1;
                for (var r = a.target; !r.__regions;) r = r.parent;
                if (r) {
                    var s = {
                        type: ("geo" === e.mainType ? "geo" : "map") + "ToggleSelect",
                        batch: p(r.__regions, function (t) {
                            return {name: t.name, from: o.uid}
                        })
                    };
                    s[e.mainType + "Id"] = e.id, n.dispatchAction(s), Ng(e, i)
                }
            }
        }))
    }

    function Ng(t, e) {
        e.eachChild(function (e) {
            f(e.__regions, function (i) {
                e.trigger(t.isSelected(i.name) ? "emphasis" : "normal")
            })
        })
    }

    function Rg(t, e) {
        var i = new iI;
        this.uid = _r("ec_map_draw"), this._controller = new hp(t.getZr()), this._controllerHost = {target: e ? i : null}, this.group = i, this._updateGroup = e, this._mouseDownFlag, this._mapName, this._initialized, i.add(this._regionsGroup = new iI), i.add(this._backgroundGroup = new iI)
    }

    function zg(t) {
        var e = this[nN];
        e && e.recordVersion === this[oN] && Bg(e, t)
    }

    function Bg(t, e) {
        var i = t.circle, n = t.labelModel, o = t.hoverLabelModel, a = t.emphasisText, r = t.normalText;
        e ? (i.style.extendFrom(ja({}, o, {text: o.get("show") ? a : null}, {
            isRectText: !0,
            useInsideStyle: !1
        }, !0)), i.__mapOriginalZ2 = i.z2, i.z2 += HA) : (ja(i.style, n, {
            text: n.get("show") ? r : null,
            textPosition: n.getShallow("position") || "bottom"
        }, {
            isRectText: !0,
            useInsideStyle: !1
        }), i.dirty(!1), null != i.__mapOriginalZ2 && (i.z2 = i.__mapOriginalZ2, i.__mapOriginalZ2 = null))
    }

    function Vg(t, e, i, n) {
        ip.call(this, t), this.map = e;
        var o = eN.load(e, i);
        this._nameCoordMap = o.nameCoordMap, this._regionsMap = o.regionsMap, this._invertLongitute = null == n ? !0 : n, this.regions = o.regions, this._rect = o.boundingRect
    }

    function Gg(t, e, i, n) {
        var o = i.geoModel, a = i.seriesModel,
            r = o ? o.coordinateSystem : a ? a.coordinateSystem || (a.getReferringComponents("geo")[0] || {}).coordinateSystem : null;
        return r === this ? r[t](n) : null
    }

    function Fg(t, e) {
        var i = t.get("boundingCoords");
        if (null != i) {
            var n = i[0], o = i[1];
            isNaN(n[0]) || isNaN(n[1]) || isNaN(o[0]) || isNaN(o[1]) ? BS && console.error("Invalid boundingCoords") : this.setBoundingRect(n[0], n[1], o[0] - n[0], o[1] - n[1])
        }
        var a, r = this.getBoundingRect(), s = t.get("layoutCenter"), l = t.get("layoutSize"), u = e.getWidth(),
            h = e.getHeight(), c = r.width / r.height * this.aspectScale, d = !1;
        s && l && (s = [Ir(s[0], u), Ir(s[1], h)], l = Ir(l, Math.min(u, h)), isNaN(s[0]) || isNaN(s[1]) || isNaN(l) ? BS && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.") : d = !0);
        var f;
        if (d) {
            var f = {};
            c > 1 ? (f.width = l, f.height = l / c) : (f.height = l, f.width = l * c), f.y = s[1] - f.height / 2, f.x = s[0] - f.width / 2
        } else a = t.getBoxLayoutParams(), a.aspect = c, f = es(a, {width: u, height: h});
        this.setViewRect(f.x, f.y, f.width, f.height), this.setCenter(t.get("center")), this.setZoom(t.get("zoom"))
    }

    function Wg(t, e) {
        f(e.get("geoCoord"), function (e, i) {
            t.addGeoCoord(i, e)
        })
    }

    function Hg(t, e) {
        var i = {};
        return f(t, function (t) {
            t.each(t.mapDimension("value"), function (e, n) {
                var o = "ec-" + t.getName(n);
                i[o] = i[o] || [], isNaN(e) || i[o].push(e)
            })
        }), t[0].map(t[0].mapDimension("value"), function (n, o) {
            for (var a = "ec-" + t[0].getName(o), r = 0, s = 1 / 0, l = -1 / 0, u = i[a].length, h = 0; u > h; h++) s = Math.min(s, i[a][h]), l = Math.max(l, i[a][h]), r += i[a][h];
            var c;
            return c = "min" === e ? s : "max" === e ? l : "average" === e ? r / u : r, 0 === u ? 0 / 0 : c
        })
    }

    function Zg(t) {
        var e = t.data;
        e && e[0] && e[0][0] && e[0][0].coord && (BS && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), t.data = p(e, function (t) {
            var e = [t[0].coord, t[1].coord], i = {coords: e};
            return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), a([i, t[0], t[1]])
        }))
    }

    function Ug(t) {
        return isNaN(+t.cpx1) || isNaN(+t.cpy1)
    }

    function Xg(t) {
        return "_" + t + "Type"
    }

    function Yg(t, e, i) {
        var n = e.getItemVisual(i, t);
        if (n && "none" !== n) {
            var o = e.getItemVisual(i, "color"), a = e.getItemVisual(i, t + "Size"),
                r = e.getItemVisual(i, t + "Rotate");
            _(a) || (a = [a, a]);
            var s = ac(n, -a[0] / 2, -a[1] / 2, a[0], a[1], o);
            return s.__specifiedRotation = null == r || isNaN(r) ? void 0 : +r * Math.PI / 180 || 0, s.name = t, s
        }
    }

    function jg(t) {
        var e = new gN({name: "line", subPixelOptimize: !0});
        return qg(e.shape, t), e
    }

    function qg(t, e) {
        t.x1 = e[0][0], t.y1 = e[0][1], t.x2 = e[1][0], t.y2 = e[1][1], t.percent = 1;
        var i = e[2];
        i ? (t.cpx1 = i[0], t.cpy1 = i[1]) : (t.cpx1 = 0 / 0, t.cpy1 = 0 / 0)
    }

    function Kg() {
        var t = this, e = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), n = t.childOfName("label");
        if (e || i || !n.ignore) {
            for (var o = 1, a = this.parent; a;) a.scale && (o /= a.scale[0]), a = a.parent;
            var r = t.childOfName("line");
            if (this.__dirty || r.__dirty) {
                var s = r.shape.percent, l = r.pointAt(0), u = r.pointAt(s), h = Y([], u, l);
                if (te(h, h), e) {
                    e.attr("position", l);
                    var c = e.__specifiedRotation;
                    if (null == c) {
                        var d = r.tangentAt(0);
                        e.attr("rotation", Math.PI / 2 - Math.atan2(d[1], d[0]))
                    } else e.attr("rotation", c);
                    e.attr("scale", [o * s, o * s])
                }
                if (i) {
                    i.attr("position", u);
                    var c = i.__specifiedRotation;
                    if (null == c) {
                        var d = r.tangentAt(1);
                        i.attr("rotation", -Math.PI / 2 - Math.atan2(d[1], d[0]))
                    } else i.attr("rotation", c);
                    i.attr("scale", [o * s, o * s])
                }
                if (!n.ignore) {
                    n.attr("position", u);
                    var f, p, g, m, v = n.__labelDistance, y = v[0] * o, x = v[1] * o, _ = s / 2, d = r.tangentAt(_),
                        w = [d[1], -d[0]], b = r.pointAt(_);
                    w[1] > 0 && (w[0] = -w[0], w[1] = -w[1]);
                    var S = d[0] < 0 ? -1 : 1;
                    if ("start" !== n.__position && "end" !== n.__position) {
                        var M = -Math.atan2(d[1], d[0]);
                        u[0] < l[0] && (M = Math.PI + M), n.attr("rotation", M)
                    }
                    var I;
                    switch (n.__position) {
                        case"insideStartTop":
                        case"insideMiddleTop":
                        case"insideEndTop":
                        case"middle":
                            I = -x, g = "bottom";
                            break;
                        case"insideStartBottom":
                        case"insideMiddleBottom":
                        case"insideEndBottom":
                            I = x, g = "top";
                            break;
                        default:
                            I = 0, g = "middle"
                    }
                    switch (n.__position) {
                        case"end":
                            f = [h[0] * y + u[0], h[1] * x + u[1]], p = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", g = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle";
                            break;
                        case"start":
                            f = [-h[0] * y + l[0], -h[1] * x + l[1]], p = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", g = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle";
                            break;
                        case"insideStartTop":
                        case"insideStart":
                        case"insideStartBottom":
                            f = [y * S + l[0], l[1] + I], p = d[0] < 0 ? "right" : "left", m = [-y * S, -I];
                            break;
                        case"insideMiddleTop":
                        case"insideMiddle":
                        case"insideMiddleBottom":
                        case"middle":
                            f = [b[0], b[1] + I], p = "center", m = [0, -I];
                            break;
                        case"insideEndTop":
                        case"insideEnd":
                        case"insideEndBottom":
                            f = [-y * S + u[0], u[1] + I], p = d[0] >= 0 ? "right" : "left", m = [y * S, -I]
                    }
                    n.attr({
                        style: {textVerticalAlign: n.__verticalAlign || g, textAlign: n.__textAlign || p},
                        position: f,
                        scale: [o, o],
                        origin: m
                    })
                }
            }
        }
    }

    function $g(t, e, i) {
        iI.call(this), this._createLine(t, e, i)
    }

    function Jg(t) {
        this._ctor = t || $g, this.group = new iI
    }

    function Qg(t, e, i, n) {
        var o = e.getItemLayout(i);
        if (om(o)) {
            var a = new t._ctor(e, i, n);
            e.setItemGraphicEl(i, a), t.group.add(a)
        }
    }

    function tm(t, e, i, n, o, a) {
        var r = e.getItemGraphicEl(n);
        return om(i.getItemLayout(o)) ? (r ? r.updateData(i, o, a) : r = new t._ctor(i, o, a), i.setItemGraphicEl(o, r), void t.group.add(r)) : void t.group.remove(r)
    }

    function em(t) {
        return t.animators && t.animators.length > 0
    }

    function im(t) {
        var e = t.hostModel;
        return {
            lineStyle: e.getModel("lineStyle").getLineStyle(),
            hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(),
            labelModel: e.getModel("label"),
            hoverLabelModel: e.getModel("emphasis.label")
        }
    }

    function nm(t) {
        return isNaN(t[0]) || isNaN(t[1])
    }

    function om(t) {
        return !nm(t[0]) && !nm(t[1])
    }

    function am(t, e, i) {
        iI.call(this), this.add(this.createLine(t, e, i)), this._updateEffectSymbol(t, e)
    }

    function rm(t, e, i) {
        iI.call(this), this._createPolyline(t, e, i)
    }

    function sm(t, e, i) {
        am.call(this, t, e, i), this._lastFrame = 0, this._lastFramePercent = 0
    }

    function lm() {
        this.group = new iI
    }

    function um(t) {
        return t instanceof Array || (t = [t, t]), t
    }

    function hm(t) {
        return "_EC_" + t
    }

    function cm(t, e) {
        this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = null == e ? -1 : e
    }

    function dm(t, e, i) {
        this.node1 = t, this.node2 = e, this.dataIndex = null == i ? -1 : i
    }

    function fm(t) {
        PN(t) && (t.__curvenessList = [], t.__edgeMap = {}, ON(t))
    }

    function pm(t, e, i, n) {
        if (PN(i)) {
            var o = EN(t, e, i), a = i.__edgeMap, r = a[NN(o)];
            a[o] && !r ? a[o].isForward = !0 : r && a[o] && (r.isForward = !0, a[o].isForward = !1), a[o] = a[o] || [], a[o].push(n)
        }
    }

    function gm(t, e, i, n) {
        var o = PN(e), a = _(o);
        if (!o) return null;
        var r = RN(t, e);
        if (!r) return null;
        for (var s = -1, l = 0; l < r.length; l++) if (r[l] === i) {
            s = l;
            break
        }
        var u = zN(t, e);
        ON(e, u), t.lineStyle = t.lineStyle || {};
        var h = EN(t.node1, t.node2, e), c = e.__curvenessList, d = a ? 0 : u % 2 ? 0 : 1;
        if (r.isForward) return c[d + s];
        var f = NN(h), p = BN(f, e), g = c[s + p + d];
        return n ? a ? o && 0 === o[0] ? (p + d) % 2 ? g : -g : ((p % 2 ? 0 : 1) + d) % 2 ? g : -g : (p + d) % 2 ? g : -g : c[s + p + d]
    }

    function mm(t) {
        var e = t.coordinateSystem;
        if ("view" !== e.type) return 1;
        var i = t.option.nodeScaleRatio, n = e.scale, o = n && n[0] || 1, a = e.getZoom(), r = (a - 1) * i + 1;
        return r / o
    }

    function vm(t) {
        var e = t.getVisual("symbolSize");
        return e instanceof Array && (e = (e[0] + e[1]) / 2), +e
    }

    function ym(t, e, i) {
        for (var n, o = t[0], a = t[1], r = t[2], s = 1 / 0, l = i * i, u = .1, h = .1; .9 >= h; h += .1) {
            GN[0] = HN(o[0], a[0], r[0], h), GN[1] = HN(o[1], a[1], r[1], h);
            var c = UN(ZN(GN, e) - l);
            s > c && (s = c, n = h)
        }
        for (var d = 0; 32 > d; d++) {
            var f = n + u;
            FN[0] = HN(o[0], a[0], r[0], n), FN[1] = HN(o[1], a[1], r[1], n), WN[0] = HN(o[0], a[0], r[0], f), WN[1] = HN(o[1], a[1], r[1], f);
            var c = ZN(FN, e) - l;
            if (UN(c) < .01) break;
            var p = ZN(WN, e) - l;
            u /= 2, 0 > c ? p >= 0 ? n += u : n -= u : p >= 0 ? n -= u : n += u
        }
        return n
    }

    function xm(t, e) {
        var i = t.getVisual("opacity");
        return null != i ? i : t.getModel().get(e)
    }

    function _m(t, e, i) {
        var n = t.getGraphicEl(), o = xm(t, e);
        null != i && (null == o && (o = 1), o *= i), n.downplay && n.downplay(), n.traverse(function (t) {
            if (!t.isGroup) {
                var e = t.lineLabelOriginalOpacity;
                (null == e || null != i) && (e = o), t.setStyle("opacity", e)
            }
        })
    }

    function wm(t, e) {
        var i = xm(t, e), n = t.getGraphicEl();
        n.traverse(function (t) {
            !t.isGroup && t.setStyle("opacity", i)
        }), n.highlight && n.highlight()
    }

    function bm(t) {
        return t instanceof Array || (t = [t, t]), t
    }

    function Sm(t) {
        var e = t.coordinateSystem;
        if (!e || "view" === e.type) {
            var i = t.getGraph();
            i.eachNode(function (t) {
                var e = t.getModel();
                t.setLayout([+e.get("x"), +e.get("y")])
            }), Mm(i, t)
        }
    }

    function Mm(t, e) {
        t.eachEdge(function (t, i) {
            var n = L(t.getModel().get("lineStyle.curveness"), -gm(t, e, i, !0), 0), o = H(t.node1.getLayout()),
                a = H(t.node2.getLayout()), r = [o, a];
            +n && r.push([(o[0] + a[0]) / 2 - (o[1] - a[1]) * n, (o[1] + a[1]) / 2 - (a[0] - o[0]) * n]), t.setLayout(r)
        })
    }

    function Im(t, e) {
        var i = t.coordinateSystem;
        if (!i || "view" === i.type) {
            var n = i.getBoundingRect(), o = t.getData(), a = o.graph, r = n.width / 2 + n.x, s = n.height / 2 + n.y,
                l = Math.min(n.width, n.height) / 2, u = o.count();
            o.setLayout({cx: r, cy: s}), u && (oR[e](t, i, a, o, l, r, s, u), a.eachEdge(function (e, i) {
                var n, o = L(e.getModel().get("lineStyle.curveness"), gm(e, t, i), 0), a = H(e.node1.getLayout()),
                    l = H(e.node2.getLayout()), u = (a[0] + l[0]) / 2, h = (a[1] + l[1]) / 2;
                +o && (o *= 3, n = [r * o + u * (1 - o), s * o + h * (1 - o)]), e.setLayout([a, l, n])
            }))
        }
    }

    function Tm(t, e, i) {
        for (var n = i.rect, o = n.width, a = n.height, r = [n.x + o / 2, n.y + a / 2], s = null == i.gravity ? .1 : i.gravity, l = 0; l < t.length; l++) {
            var u = t[l];
            u.p || (u.p = F(o * (Math.random() - .5) + r[0], a * (Math.random() - .5) + r[1])), u.pp = H(u.p), u.edges = null
        }
        var h = null == i.friction ? .6 : i.friction, c = h;
        return {
            warmUp: function () {
                c = .8 * h
            }, setFixed: function (e) {
                t[e].fixed = !0
            }, setUnfixed: function (e) {
                t[e].fixed = !1
            }, step: function (i) {
                for (var n = [], o = t.length, a = 0; a < e.length; a++) {
                    var l = e[a];
                    if (!l.ignoreForceLayout) {
                        var u = l.n1, h = l.n2;
                        Y(n, h.p, u.p);
                        var d = j(n) - l.d, f = h.w / (u.w + h.w);
                        isNaN(f) && (f = 0), te(n, n), !u.fixed && rR(u.p, u.p, n, f * d * c), !h.fixed && rR(h.p, h.p, n, -(1 - f) * d * c)
                    }
                }
                for (var a = 0; o > a; a++) {
                    var p = t[a];
                    p.fixed || (Y(n, r, p.p), rR(p.p, p.p, n, s * c))
                }
                for (var a = 0; o > a; a++) for (var u = t[a], g = a + 1; o > g; g++) {
                    var h = t[g];
                    Y(n, h.p, u.p);
                    var d = j(n);
                    0 === d && (Z(n, Math.random() - .5, Math.random() - .5), d = 1);
                    var m = (u.rep + h.rep) / d / d;
                    !u.fixed && rR(u.pp, u.pp, n, m), !h.fixed && rR(h.pp, h.pp, n, -m)
                }
                for (var v = [], a = 0; o > a; a++) {
                    var p = t[a];
                    p.fixed || (Y(v, p.p, p.pp), rR(p.p, p.p, v, c), W(p.pp, p.p))
                }
                c = .992 * c, i && i(t, e, .01 > c)
            }
        }
    }

    function Am(t, e, i) {
        var n = t.getBoxLayoutParams();
        return n.aspect = i, es(n, {width: e.getWidth(), height: e.getHeight()})
    }

    function Dm(t, e, i, n, o) {
        var a = t.ends, r = new dR({shape: {points: o ? Lm(a, n, t) : a}});
        return Cm(t, r, e, i, o), r
    }

    function Cm(t, e, i, n, o) {
        var a = i.hostModel, r = tD[o ? "initProps" : "updateProps"];
        r(e, {shape: {points: t.ends}}, a, n);
        var s = i.getItemModel(n), l = s.getModel(hR), u = i.getItemVisual(n, "color"),
            h = l.getItemStyle(["borderColor"]);
        h.stroke = u, h.strokeNoScale = !0, e.useStyle(h), e.z2 = 100;
        var c = s.getModel(cR).getItemStyle();
        Wa(e, c)
    }

    function Lm(t, e, i) {
        return p(t, function (t) {
            return t = t.slice(), t[e] = i.initBaseline, t
        })
    }

    function km(t) {
        var e = [], i = [];
        return t.eachSeriesByType("boxplot", function (t) {
            var n = t.getBaseAxis(), o = u(i, n);
            0 > o && (o = i.length, i[o] = n, e[o] = {axis: n, seriesModels: []}), e[o].seriesModels.push(t)
        }), e
    }

    function Pm(t) {
        var e, i, n = t.axis, o = t.seriesModels, a = o.length, r = t.boxWidthList = [], s = t.boxOffsetList = [],
            l = [];
        if ("category" === n.type) i = n.getBandWidth(); else {
            var u = 0;
            gR(o, function (t) {
                u = Math.max(u, t.getData().count())
            }), e = n.getExtent(), Math.abs(e[1] - e[0]) / u
        }
        gR(o, function (t) {
            var e = t.get("boxWidth");
            _(e) || (e = [e, e]), l.push([Ir(e[0], i) || 0, Ir(e[1], i) || 0])
        });
        var h = .8 * i - 2, c = h / a * .3, d = (h - c * (a - 1)) / a, f = d / 2 - h / 2;
        gR(o, function (t, e) {
            s.push(f), f += c + d, r.push(Math.min(Math.max(d, l[e][0]), l[e][1]))
        })
    }

    function Om(t, e, i) {
        function n(t, i, n) {
            var o = s.get(i, n), a = [];
            a[u] = t, a[h] = o;
            var l;
            return isNaN(t) || isNaN(o) ? l = [0 / 0, 0 / 0] : (l = r.dataToPoint(a), l[u] += e), l
        }

        function o(t, e, i) {
            var n = e.slice(), o = e.slice();
            n[u] += l, o[u] -= l, i ? t.push(n, o) : t.push(o, n)
        }

        function a(t, e) {
            var i = e.slice(), n = e.slice();
            i[u] -= l, n[u] += l, t.push(i, n)
        }

        var r = t.coordinateSystem, s = t.getData(), l = i / 2, u = "horizontal" === t.get("layout") ? 0 : 1, h = 1 - u,
            c = ["x", "y"], d = s.mapDimension(c[u]), f = s.mapDimension(c[h], !0);
        if (!(null == d || f.length < 5)) for (var p = 0; p < s.count(); p++) {
            var g = s.get(d, p), m = n(g, f[2], p), v = n(g, f[0], p), y = n(g, f[1], p), x = n(g, f[3], p),
                _ = n(g, f[4], p), w = [];
            o(w, y, 0), o(w, x, 1), w.push(v, y, _, x), a(w, v), a(w, _), a(w, m), s.setItemLayout(p, {
                initBaseline: m[h],
                ends: w
            })
        }
    }

    function Em(t) {
        if (!t.parallel) {
            var e = !1;
            f(t.series, function (t) {
                t && "parallel" === t.type && (e = !0)
            }), e && (t.parallel = [{}])
        }
    }

    function Nm(t) {
        var e = eo(t.parallelAxis);
        f(e, function (e) {
            if (S(e)) {
                var i = e.parallelIndex || 0, n = eo(t.parallel)[i];
                n && n.parallelAxisDefault && o(e, n.parallelAxisDefault, !1)
            }
        })
    }

    function Rm(t, e) {
        var i = t[e] - t[1 - e];
        return {span: Math.abs(i), sign: i > 0 ? -1 : 0 > i ? 1 : e ? -1 : 1}
    }

    function zm(t, e) {
        return Math.min(null != e[1] ? e[1] : 1 / 0, Math.max(null != e[0] ? e[0] : -1 / 0, t))
    }

    function Bm(t, e, i) {
        this._axesMap = B(), this._axesLayout = {}, this.dimensions = t.dimensions, this._rect, this._model = t, this._init(t, e, i)
    }

    function Vm(t, e) {
        return wR(bR(t, e[0]), e[1])
    }

    function Gm(t, e) {
        var i = e.layoutLength / (e.axisCount - 1);
        return {position: i * t, axisNameAvailableWidth: i, axisLabelShow: !0}
    }

    function Fm(t, e) {
        var i, n, o = e.layoutLength, a = e.axisExpandWidth, r = e.axisCount, s = e.axisCollapseWidth,
            l = e.winInnerIndices, u = s, h = !1;
        return t < l[0] ? (i = t * s, n = s) : t <= l[1] ? (i = e.axisExpandWindow0Pos + t * a - e.axisExpandWindow[0], u = a, h = !0) : (i = o - (r - 1 - t) * s, n = s), {
            position: i,
            axisNameAvailableWidth: u,
            axisLabelShow: h,
            nameTruncateMaxWidth: n
        }
    }

    function Wm(t, e) {
        var i = [];
        return t.eachComponent("parallel", function (n, o) {
            var a = new Bm(n, t, e);
            a.name = "parallel_" + o, a.resize(n, e), n.coordinateSystem = a, a.model = n, i.push(a)
        }), t.eachSeries(function (e) {
            if ("parallel" === e.get("coordinateSystem")) {
                var i = t.queryComponents({
                    mainType: "parallel",
                    index: e.get("parallelIndex"),
                    id: e.get("parallelId")
                })[0];
                e.coordinateSystem = i.coordinateSystem
            }
        }), i
    }

    function Hm(t, e) {
        return e.type || (e.data ? "category" : "value")
    }

    function Zm(t) {
        BS && O(t), hM.call(this), this._zr = t, this.group = new iI, this._brushType, this._brushOption, this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, this._creatingPanel, this._enableGlobalPan, BS && this._mounted, this._uid = "brushController_" + HR++, this._handlers = {}, kR(ZR, function (t, e) {
            this._handlers[e] = y(t, this)
        }, this)
    }

    function Um(t, e) {
        var i = t._zr;
        t._enableGlobalPan || rp(i, VR, t._uid), Ym(i, t._handlers), t._brushType = e.brushType, t._brushOption = o(n(WR), e, !0)
    }

    function Xm(t) {
        var e = t._zr;
        sp(e, VR, t._uid), jm(e, t._handlers), t._brushType = t._brushOption = null
    }

    function Ym(t, e) {
        kR(e, function (e, i) {
            t.on(i, e)
        })
    }

    function jm(t, e) {
        kR(e, function (e, i) {
            t.off(i, e)
        })
    }

    function qm(t, e) {
        var i = UR[e.brushType].createCover(t, e);
        return i.__brushOption = e, Jm(i, e), t.group.add(i), i
    }

    function Km(t, e) {
        var i = tv(e);
        return i.endCreating && (i.endCreating(t, e), Jm(e, e.__brushOption)), e
    }

    function $m(t, e) {
        var i = e.__brushOption;
        tv(e).updateCoverShape(t, e, i.range, i)
    }

    function Jm(t, e) {
        var i = e.z;
        null == i && (i = RR), t.traverse(function (t) {
            t.z = i, t.z2 = i
        })
    }

    function Qm(t, e) {
        tv(e).updateCommon(t, e), $m(t, e)
    }

    function tv(t) {
        return UR[t.__brushOption.brushType]
    }

    function ev(t, e, i) {
        var n = t._panels;
        if (!n) return !0;
        var o, a = t._transform;
        return kR(n, function (t) {
            t.isTargetByCursor(e, i, a) && (o = t)
        }), o
    }

    function iv(t, e) {
        var i = t._panels;
        if (!i) return !0;
        var n = e.__brushOption.panelId;
        return null != n ? i[n] : !0
    }

    function nv(t) {
        var e = t._covers, i = e.length;
        return kR(e, function (e) {
            t.group.remove(e)
        }, t), e.length = 0, !!i
    }

    function ov(t, e) {
        var i = PR(t._covers, function (t) {
            var e = t.__brushOption, i = n(e.range);
            return {brushType: e.brushType, panelId: e.panelId, range: i}
        });
        t.trigger("brush", i, {isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick})
    }

    function av(t) {
        var e = t._track;
        if (!e.length) return !1;
        var i = e[e.length - 1], n = e[0], o = i[0] - n[0], a = i[1] - n[1], r = NR(o * o + a * a, .5);
        return r > zR
    }

    function rv(t) {
        var e = t.length - 1;
        return 0 > e && (e = 0), [t[0], t[e]]
    }

    function sv(t, e, i, n) {
        var o = new iI;
        return o.add(new CA({
            name: "main",
            style: cv(i),
            silent: !0,
            draggable: !0,
            cursor: "move",
            drift: LR(t, e, o, "nswe"),
            ondragend: LR(ov, e, {isEnd: !0})
        })), kR(n, function (i) {
            o.add(new CA({
                name: i,
                style: {opacity: 0},
                draggable: !0,
                silent: !0,
                invisible: !0,
                drift: LR(t, e, o, i),
                ondragend: LR(ov, e, {isEnd: !0})
            }))
        }), o
    }

    function lv(t, e, i, n) {
        var o = n.brushStyle.lineWidth || 0, a = ER(o, BR), r = i[0][0], s = i[1][0], l = r - o / 2, u = s - o / 2,
            h = i[0][1], c = i[1][1], d = h - a + o / 2, f = c - a + o / 2, p = h - r, g = c - s, m = p + o, v = g + o;
        hv(t, e, "main", r, s, p, g), n.transformable && (hv(t, e, "w", l, u, a, v), hv(t, e, "e", d, u, a, v), hv(t, e, "n", l, u, m, a), hv(t, e, "s", l, f, m, a), hv(t, e, "nw", l, u, a, a), hv(t, e, "ne", d, u, a, a), hv(t, e, "sw", l, f, a, a), hv(t, e, "se", d, f, a, a))
    }

    function uv(t, e) {
        var i = e.__brushOption, n = i.transformable, o = e.childAt(0);
        o.useStyle(cv(i)), o.attr({
            silent: !n,
            cursor: n ? "move" : "default"
        }), kR(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function (i) {
            var o = e.childOfName(i), a = pv(t, i);
            o && o.attr({silent: !n, invisible: !n, cursor: n ? FR[a] + "-resize" : null})
        })
    }

    function hv(t, e, i, n, o, a, r) {
        var s = e.childOfName(i);
        s && s.setShape(xv(yv(t, e, [[n, o], [n + a, o + r]])))
    }

    function cv(t) {
        return s({strokeNoScale: !0}, t.brushStyle)
    }

    function dv(t, e, i, n) {
        var o = [OR(t, i), OR(e, n)], a = [ER(t, i), ER(e, n)];
        return [[o[0], a[0]], [o[1], a[1]]]
    }

    function fv(t) {
        return rr(t.group)
    }

    function pv(t, e) {
        if (e.length > 1) {
            e = e.split("");
            var i = [pv(t, e[0]), pv(t, e[1])];
            return ("e" === i[0] || "w" === i[0]) && i.reverse(), i.join("")
        }
        var n = {w: "left", e: "right", n: "top", s: "bottom"}, o = {left: "w", right: "e", top: "n", bottom: "s"},
            i = lr(n[e], fv(t));
        return o[i]
    }

    function gv(t, e, i, n, o, a, r) {
        var s = n.__brushOption, l = t(s.range), u = vv(i, a, r);
        kR(o.split(""), function (t) {
            var e = GR[t];
            l[e[0]][e[1]] += u[e[0]]
        }), s.range = e(dv(l[0][0], l[1][0], l[0][1], l[1][1])), Qm(i, n), ov(i, {isEnd: !1})
    }

    function mv(t, e, i, n) {
        var o = e.__brushOption.range, a = vv(t, i, n);
        kR(o, function (t) {
            t[0] += a[0], t[1] += a[1]
        }), Qm(t, e), ov(t, {isEnd: !1})
    }

    function vv(t, e, i) {
        var n = t.group, o = n.transformCoordToLocal(e, i), a = n.transformCoordToLocal(0, 0);
        return [o[0] - a[0], o[1] - a[1]]
    }

    function yv(t, e, i) {
        var o = iv(t, e);
        return o && o !== !0 ? o.clipPath(i, t._transform) : n(i)
    }

    function xv(t) {
        var e = OR(t[0][0], t[1][0]), i = OR(t[0][1], t[1][1]), n = ER(t[0][0], t[1][0]), o = ER(t[0][1], t[1][1]);
        return {x: e, y: i, width: n - e, height: o - i}
    }

    function _v(t, e, i) {
        if (t._brushType && !Tv(t, e)) {
            var n = t._zr, o = t._covers, a = ev(t, e, i);
            if (!t._dragging) for (var r = 0; r < o.length; r++) {
                var s = o[r].__brushOption;
                if (a && (a === !0 || s.panelId === a.panelId) && UR[s.brushType].contain(o[r], i[0], i[1])) return
            }
            a && n.setCursorStyle("crosshair")
        }
    }

    function wv(t) {
        var e = t.event;
        e.preventDefault && e.preventDefault()
    }

    function bv(t, e, i) {
        return t.childOfName("main").contain(e, i)
    }

    function Sv(t, e, i, o) {
        var a, r = t._creatingCover, s = t._creatingPanel, l = t._brushOption;
        if (t._track.push(i.slice()), av(t) || r) {
            if (s && !r) {
                "single" === l.brushMode && nv(t);
                var u = n(l);
                u.brushType = Mv(u.brushType, s), u.panelId = s === !0 ? null : s.panelId, r = t._creatingCover = qm(t, u), t._covers.push(r)
            }
            if (r) {
                var h = UR[Mv(t._brushType, s)], c = r.__brushOption;
                c.range = h.getCreatingRange(yv(t, r, t._track)), o && (Km(t, r), h.updateCommon(t, r)), $m(t, r), a = {isEnd: o}
            }
        } else o && "single" === l.brushMode && l.removeOnClick && ev(t, e, i) && nv(t) && (a = {
            isEnd: o,
            removeOnClick: !0
        });
        return a
    }

    function Mv(t, e) {
        return "auto" === t ? (BS && O(e && e.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), e.defaultBrushType) : t
    }

    function Iv(t, e) {
        if (t._dragging) {
            wv(e);
            var i = e.offsetX, n = e.offsetY, o = t.group.transformCoordToLocal(i, n), a = Sv(t, e, o, !0);
            t._dragging = !1, t._track = [], t._creatingCover = null, a && ov(t, a)
        }
    }

    function Tv(t, e, i) {
        var n = t._zr;
        return 0 > e || e > n.getWidth() || 0 > i || i > n.getHeight()
    }

    function Av(t) {
        return {
            createCover: function (e, i) {
                return sv(LR(gv, function (e) {
                    var i = [e, [0, 100]];
                    return t && i.reverse(), i
                }, function (e) {
                    return e[t]
                }), e, i, [["w", "e"], ["n", "s"]][t])
            }, getCreatingRange: function (e) {
                var i = rv(e), n = OR(i[0][t], i[1][t]), o = ER(i[0][t], i[1][t]);
                return [n, o]
            }, updateCoverShape: function (e, i, n, o) {
                var a, r = iv(e, i);
                if (r !== !0 && r.getLinearBrushOtherExtent) a = r.getLinearBrushOtherExtent(t, e._transform); else {
                    var s = e._zr;
                    a = [0, [s.getWidth(), s.getHeight()][1 - t]]
                }
                var l = [n, a];
                t && l.reverse(), lv(e, i, l, o)
            }, updateCommon: uv, contain: bv
        }
    }

    function Dv(t) {
        return t = kv(t), function (e) {
            return hr(e, t)
        }
    }

    function Cv(t, e) {
        return t = kv(t), function (i) {
            var n = null != e ? e : i, o = n ? t.width : t.height, a = n ? t.x : t.y;
            return [a, a + (o || 0)]
        }
    }

    function Lv(t, e, i) {
        return t = kv(t), function (n, o) {
            return t.contain(o[0], o[1]) && !xp(n, e, i)
        }
    }

    function kv(t) {
        return Ti.create(t)
    }

    function Pv(t, e, i) {
        return i && "axisAreaSelect" === i.type && e.findComponents({mainType: "parallelAxis", query: i})[0] === t
    }

    function Ov(t) {
        var e = t.axis;
        return p(t.activeIntervals, function (t) {
            return {brushType: "lineX", panelId: "pl", range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)]}
        })
    }

    function Ev(t, e) {
        return e.getComponent("parallel", t.get("parallelIndex"))
    }

    function Nv(t, e) {
        var i = t._model;
        return i.get("axisExpandable") && i.get("axisExpandTriggerOn") === e
    }

    function Rv(t, e) {
        if (!t.encodeDefine) {
            var i = e.ecModel.getComponent("parallel", e.get("parallelIndex"));
            if (i) {
                var n = t.encodeDefine = B();
                f(i.dimensions, function (t) {
                    var e = zv(t);
                    n.set(t, e)
                })
            }
        }
    }

    function zv(t) {
        return +t.replace("dim", "")
    }

    function Bv(t, e, i) {
        var n = t.model, o = t.getRect(), a = new CA({shape: {x: o.x, y: o.y, width: o.width, height: o.height}}),
            r = "horizontal" === n.get("layout") ? "width" : "height";
        return a.setShape(r, 0), ar(a, {shape: {width: o.width, height: o.height}}, e, i), a
    }

    function Vv(t, e, i, n) {
        for (var o = [], a = 0; a < i.length; a++) {
            var r = i[a], s = t.get(t.mapDimension(r), e);
            Hv(s, n.getAxis(r).type) || o.push(n.dataToPoint(s, r))
        }
        return o
    }

    function Gv(t, e, i, n, o) {
        var a = Vv(t, i, n, o), r = new TA({shape: {points: a}, silent: !0, z2: 10});
        return e.add(r), t.setItemGraphicEl(i, r), r
    }

    function Fv(t) {
        var e = t.get("smooth", !0);
        return e === !0 && (e = KR), {lineStyle: t.getModel("lineStyle").getLineStyle(), smooth: null != e ? e : KR}
    }

    function Wv(t, e, i, n) {
        var o = n.lineStyle;
        if (e.hasItemOption) {
            var a = e.getItemModel(i).getModel("lineStyle");
            o = a.getLineStyle()
        }
        t.useStyle(o);
        var r = t.style;
        r.fill = null, r.stroke = e.getItemVisual(i, "color"), r.opacity = e.getItemVisual(i, "opacity"), n.smooth && (t.shape.smooth = n.smooth)
    }

    function Hv(t, e) {
        return "category" === e ? null == t : null == t || isNaN(t)
    }

    function Zv(t, e) {
        var i = t.get("center"), n = e.getWidth(), o = e.getHeight(), a = Math.min(n, o), r = Ir(i[0], e.getWidth()),
            s = Ir(i[1], e.getHeight()), l = Ir(t.get("radius"), a / 2);
        return {cx: r, cy: s, r: l}
    }

    function Uv(t, e) {
        return e && ("string" == typeof e ? t = e.replace("{value}", null != t ? t : "") : "function" == typeof e && (t = e(t))), t
    }

    function Xv(t, e) {
        iI.call(this);
        var i = new IA, n = new TA, o = new vA;
        this.add(i), this.add(n), this.add(o), this.highDownOnUpdate = function (t, e) {
            "emphasis" === e ? (n.ignore = n.hoverIgnore, o.ignore = o.hoverIgnore) : (n.ignore = n.normalIgnore, o.ignore = o.normalIgnore)
        }, this.updateData(t, e, !0)
    }

    function Yv(t, e) {
        return es(t.getBoxLayoutParams(), {width: e.getWidth(), height: e.getHeight()})
    }

    function jv(t, e) {
        for (var i = t.mapDimension("value"), n = t.mapArray(i, function (t) {
            return t
        }), o = [], a = "ascending" === e, r = 0, s = t.count(); s > r; r++) o[r] = r;
        return "function" == typeof e ? o.sort(e) : "none" !== e && o.sort(function (t, e) {
            return a ? n[t] - n[e] : n[e] - n[t]
        }), o
    }

    function qv(t) {
        t.each(function (e) {
            var i, n, o, a, r = t.getItemModel(e), s = r.getModel("label"), l = s.get("position"), u = r.get("orient"),
                h = r.getModel("labelLine"), c = t.getItemLayout(e), d = c.points,
                f = "inner" === l || "inside" === l || "center" === l || "insideLeft" === l || "insideRight" === l;
            if (f) "insideLeft" === l ? (n = (d[0][0] + d[3][0]) / 2 + 5, o = (d[0][1] + d[3][1]) / 2, i = "left") : "insideRight" === l ? (n = (d[1][0] + d[2][0]) / 2 - 5, o = (d[1][1] + d[2][1]) / 2, i = "right") : (n = (d[0][0] + d[1][0] + d[2][0] + d[3][0]) / 4, o = (d[0][1] + d[1][1] + d[2][1] + d[3][1]) / 4, i = "center"), a = [[n, o], [n, o]]; else {
                var p, g, m, v, y = h.get("length");
                BS && ("vertical" === u && ["top", "bottom"].indexOf(l) > -1 && (l = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), "horizontal" === u && ["left", "right"].indexOf(l) > -1 && (l = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), "left" === l ? (p = (d[3][0] + d[0][0]) / 2, g = (d[3][1] + d[0][1]) / 2, m = p - y, n = m - 5, i = "right") : "right" === l ? (p = (d[1][0] + d[2][0]) / 2, g = (d[1][1] + d[2][1]) / 2, m = p + y, n = m + 5, i = "left") : "top" === l ? (p = (d[3][0] + d[0][0]) / 2, g = (d[3][1] + d[0][1]) / 2, v = g - y, o = v - 5, i = "center") : "bottom" === l ? (p = (d[1][0] + d[2][0]) / 2, g = (d[1][1] + d[2][1]) / 2, v = g + y, o = v + 5, i = "center") : "rightTop" === l ? (p = "horizontal" === u ? d[3][0] : d[1][0], g = "horizontal" === u ? d[3][1] : d[1][1], "horizontal" === u ? (v = g - y, o = v - 5, i = "center") : (m = p + y, n = m + 5, i = "top")) : "rightBottom" === l ? (p = d[2][0], g = d[2][1], "horizontal" === u ? (v = g + y, o = v + 5, i = "center") : (m = p + y, n = m + 5, i = "bottom")) : "leftTop" === l ? (p = d[0][0], g = "horizontal" === u ? d[0][1] : d[1][1], "horizontal" === u ? (v = g - y, o = v - 5, i = "center") : (m = p - y, n = m - 5, i = "right")) : "leftBottom" === l ? (p = "horizontal" === u ? d[1][0] : d[3][0], g = "horizontal" === u ? d[1][1] : d[2][1], "horizontal" === u ? (v = g + y, o = v + 5, i = "center") : (m = p - y, n = m - 5, i = "right")) : (p = (d[1][0] + d[2][0]) / 2, g = (d[1][1] + d[2][1]) / 2, "horizontal" === u ? (v = g + y, o = v + 5, i = "center") : (m = p + y, n = m + 5, i = "left")), "horizontal" === u ? (m = p, n = m) : (v = g, o = v), a = [[p, g], [m, v]]
            }
            c.label = {linePoints: a, x: n, y: o, verticalAlign: "middle", textAlign: i, inside: f}
        })
    }

    function Kv(t, e) {
        return t.getVisual("opacity") || t.getModel().get(e)
    }

    function $v(t, e, i) {
        var n = t.getGraphicEl(), o = Kv(t, e);
        null != i && (null == o && (o = 1), o *= i), n.downplay && n.downplay(), n.traverse(function (t) {
            "group" !== t.type && t.setStyle("opacity", o)
        })
    }

    function Jv(t, e) {
        var i = Kv(t, e), n = t.getGraphicEl();
        n.traverse(function (t) {
            "group" !== t.type && t.setStyle("opacity", i)
        }), n.highlight && n.highlight()
    }

    function Qv(t, e, i) {
        var n = new CA({shape: {x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20}});
        return ar(n, {shape: {width: t.width + 20}}, e, i), n
    }

    function ty(t, e) {
        return es(t.getBoxLayoutParams(), {width: e.getWidth(), height: e.getHeight()})
    }

    function ey(t, e, i, n, o, a, r, s, l) {
        ny(t, e, i, o, a, s, l), ly(t, e, a, o, n, r, s), wy(t, s)
    }

    function iy(t) {
        f(t, function (t) {
            var e = xy(t.outEdges, yy), i = xy(t.inEdges, yy), n = t.getValue() || 0, o = Math.max(e, i, n);
            t.setLayout({value: o}, !0)
        })
    }

    function ny(t, e, i, n, o, a, r) {
        for (var s = [], l = [], u = [], h = [], c = 0, d = 0, f = 0; f < e.length; f++) s[f] = 1;
        for (f = 0; f < t.length; f++) l[f] = t[f].inEdges.length, 0 === l[f] && u.push(t[f]);
        for (var p = -1; u.length;) {
            for (var g = 0; g < u.length; g++) {
                var m = u[g], v = m.hostGraph.data.getRawDataItem(m.dataIndex), y = null != v.depth && v.depth >= 0;
                y && v.depth > p && (p = v.depth), m.setLayout({depth: y ? v.depth : c}, !0), "vertical" === a ? m.setLayout({dy: i}, !0) : m.setLayout({dx: i}, !0);
                for (var x = 0; x < m.outEdges.length; x++) {
                    var _ = m.outEdges[x], w = e.indexOf(_);
                    s[w] = 0;
                    var b = _.node2, S = t.indexOf(b);
                    0 === --l[S] && h.indexOf(b) < 0 && h.push(b)
                }
            }
            ++c, u = h, h = []
        }
        for (f = 0; f < s.length; f++) if (1 === s[f]) throw new Error("Sankey is a DAG, the original data has cycle!");
        var M = p > c - 1 ? p : c - 1;
        r && "left" !== r && ay(t, r, a, M);
        var d = "vertical" === a ? (o - i) / M : (n - i) / M;
        sy(t, d, a)
    }

    function oy(t) {
        var e = t.hostGraph.data.getRawDataItem(t.dataIndex);
        return null != e.depth && e.depth >= 0
    }

    function ay(t, e, i, n) {
        if ("right" === e) {
            for (var o = [], a = t, r = 0; a.length;) {
                for (var s = 0; s < a.length; s++) {
                    var l = a[s];
                    l.setLayout({skNodeHeight: r}, !0);
                    for (var u = 0; u < l.inEdges.length; u++) {
                        var h = l.inEdges[u];
                        o.indexOf(h.node1) < 0 && o.push(h.node1)
                    }
                }
                a = o, o = [], ++r
            }
            f(t, function (t) {
                oy(t) || t.setLayout({depth: Math.max(0, n - t.getLayout().skNodeHeight)}, !0)
            })
        } else "justify" === e && ry(t, n)
    }

    function ry(t, e) {
        f(t, function (t) {
            oy(t) || t.outEdges.length || t.setLayout({depth: e}, !0)
        })
    }

    function sy(t, e, i) {
        f(t, function (t) {
            var n = t.getLayout().depth * e;
            "vertical" === i ? t.setLayout({y: n}, !0) : t.setLayout({x: n}, !0)
        })
    }

    function ly(t, e, i, n, o, a, r) {
        var s = uy(t, r);
        hy(s, e, i, n, o, r), cy(s, o, i, n, r);
        for (var l = 1; a > 0; a--) l *= .99, dy(s, l, r), cy(s, o, i, n, r), _y(s, l, r), cy(s, o, i, n, r)
    }

    function uy(t, e) {
        var i = [], n = "vertical" === e ? "y" : "x", o = yo(t, function (t) {
            return t.getLayout()[n]
        });
        return o.keys.sort(function (t, e) {
            return t - e
        }), f(o.keys, function (t) {
            i.push(o.buckets.get(t))
        }), i
    }

    function hy(t, e, i, n, o, a) {
        var r = 1 / 0;
        f(t, function (t) {
            var e = t.length, s = 0;
            f(t, function (t) {
                s += t.getLayout().value
            });
            var l = "vertical" === a ? (n - (e - 1) * o) / s : (i - (e - 1) * o) / s;
            r > l && (r = l)
        }), f(t, function (t) {
            f(t, function (t, e) {
                var i = t.getLayout().value * r;
                "vertical" === a ? (t.setLayout({x: e}, !0), t.setLayout({dx: i}, !0)) : (t.setLayout({y: e}, !0), t.setLayout({dy: i}, !0))
            })
        }), f(e, function (t) {
            var e = +t.getValue() * r;
            t.setLayout({dy: e}, !0)
        })
    }

    function cy(t, e, i, n, o) {
        var a = "vertical" === o ? "x" : "y";
        f(t, function (t) {
            t.sort(function (t, e) {
                return t.getLayout()[a] - e.getLayout()[a]
            });
            for (var r, s, l, u = 0, h = t.length, c = "vertical" === o ? "dx" : "dy", d = 0; h > d; d++) s = t[d], l = u - s.getLayout()[a], l > 0 && (r = s.getLayout()[a] + l, "vertical" === o ? s.setLayout({x: r}, !0) : s.setLayout({y: r}, !0)), u = s.getLayout()[a] + s.getLayout()[c] + e;
            var f = "vertical" === o ? n : i;
            if (l = u - e - f, l > 0) for (r = s.getLayout()[a] - l, "vertical" === o ? s.setLayout({x: r}, !0) : s.setLayout({y: r}, !0), u = r, d = h - 2; d >= 0; --d) s = t[d], l = s.getLayout()[a] + s.getLayout()[c] + e - u, l > 0 && (r = s.getLayout()[a] - l, "vertical" === o ? s.setLayout({x: r}, !0) : s.setLayout({y: r}, !0)), u = s.getLayout()[a]
        })
    }

    function dy(t, e, i) {
        f(t.slice().reverse(), function (t) {
            f(t, function (t) {
                if (t.outEdges.length) {
                    var n = xy(t.outEdges, fy, i) / xy(t.outEdges, yy, i);
                    if (isNaN(n)) {
                        var o = t.outEdges.length;
                        n = o ? xy(t.outEdges, py, i) / o : 0
                    }
                    if ("vertical" === i) {
                        var a = t.getLayout().x + (n - vy(t, i)) * e;
                        t.setLayout({x: a}, !0)
                    } else {
                        var r = t.getLayout().y + (n - vy(t, i)) * e;
                        t.setLayout({y: r}, !0)
                    }
                }
            })
        })
    }

    function fy(t, e) {
        return vy(t.node2, e) * t.getValue()
    }

    function py(t, e) {
        return vy(t.node2, e)
    }

    function gy(t, e) {
        return vy(t.node1, e) * t.getValue()
    }

    function my(t, e) {
        return vy(t.node1, e)
    }

    function vy(t, e) {
        return "vertical" === e ? t.getLayout().x + t.getLayout().dx / 2 : t.getLayout().y + t.getLayout().dy / 2
    }

    function yy(t) {
        return t.getValue()
    }

    function xy(t, e, i) {
        for (var n = 0, o = t.length, a = -1; ++a < o;) {
            var r = +e.call(t, t[a], i);
            isNaN(r) || (n += r)
        }
        return n
    }

    function _y(t, e, i) {
        f(t, function (t) {
            f(t, function (t) {
                if (t.inEdges.length) {
                    var n = xy(t.inEdges, gy, i) / xy(t.inEdges, yy, i);
                    if (isNaN(n)) {
                        var o = t.inEdges.length;
                        n = o ? xy(t.inEdges, my, i) / o : 0
                    }
                    if ("vertical" === i) {
                        var a = t.getLayout().x + (n - vy(t, i)) * e;
                        t.setLayout({x: a}, !0)
                    } else {
                        var r = t.getLayout().y + (n - vy(t, i)) * e;
                        t.setLayout({y: r}, !0)
                    }
                }
            })
        })
    }

    function wy(t, e) {
        var i = "vertical" === e ? "x" : "y";
        f(t, function (t) {
            t.outEdges.sort(function (t, e) {
                return t.node2.getLayout()[i] - e.node2.getLayout()[i]
            }), t.inEdges.sort(function (t, e) {
                return t.node1.getLayout()[i] - e.node1.getLayout()[i]
            })
        }), f(t, function (t) {
            var e = 0, i = 0;
            f(t.outEdges, function (t) {
                t.setLayout({sy: e}, !0), e += t.getLayout().dy
            }), f(t.inEdges, function (t) {
                t.setLayout({ty: i}, !0), i += t.getLayout().dy
            })
        })
    }

    function by(t, e, i) {
        this.dimension = "single", this.dimensions = ["single"], this._axis = null, this._rect, this._init(t, e, i), this.model = t
    }

    function Sy(t, e) {
        var i = [];
        return t.eachComponent("singleAxis", function (n, o) {
            var a = new by(n, t, e);
            a.name = "single_" + o, a.resize(n, e), n.coordinateSystem = a, i.push(a)
        }), t.eachSeries(function (e) {
            if ("singleAxis" === e.get("coordinateSystem")) {
                var i = t.queryComponents({
                    mainType: "singleAxis",
                    index: e.get("singleAxisIndex"),
                    id: e.get("singleAxisId")
                })[0];
                e.coordinateSystem = i && i.coordinateSystem
            }
        }), i
    }

    function My(t, e) {
        e = e || {};
        var i = t.coordinateSystem, n = t.axis, o = {}, a = n.position, r = n.orient, s = i.getRect(),
            l = [s.x, s.x + s.width, s.y, s.y + s.height],
            u = {horizontal: {top: l[2], bottom: l[3]}, vertical: {left: l[0], right: l[1]}};
        o.position = ["vertical" === r ? u.vertical[a] : l[0], "horizontal" === r ? u.horizontal[a] : l[3]];
        var h = {horizontal: 0, vertical: 1};
        o.rotation = Math.PI / 2 * h[r];
        var c = {top: -1, bottom: 1, right: 1, left: -1};
        o.labelDirection = o.tickDirection = o.nameDirection = c[a], t.get("axisTick.inside") && (o.tickDirection = -o.tickDirection), D(e.labelInside, t.get("axisLabel.inside")) && (o.labelDirection = -o.labelDirection);
        var d = e.rotate;
        return null == d && (d = t.get("axisLabel.rotate")), o.labelRotation = "top" === a ? -d : d, o.z2 = 1, o
    }

    function Iy(t, e) {
        return e.type || (e.data ? "category" : "value")
    }

    function Ty(t, e, i, n, o) {
        var a = t.axis;
        if (!a.scale.isBlank() && a.containData(e)) {
            if (!t.involveSeries) return void i.showPointer(t, e);
            var s = Ay(e, t), l = s.payloadBatch, u = s.snapToValue;
            l[0] && null == o.seriesIndex && r(o, l[0]), !n && t.snap && a.containData(u) && null != u && (e = u), i.showPointer(t, e, l, o), i.showTooltip(t, s, u)
        }
    }

    function Ay(t, e) {
        var i = e.axis, n = i.dim, o = t, a = [], r = Number.MAX_VALUE, s = -1;
        return _z(e.seriesModels, function (e) {
            var l, u, h = e.getData().mapDimension(n, !0);
            if (e.getAxisTooltipData) {
                var c = e.getAxisTooltipData(h, t, i);
                u = c.dataIndices, l = c.nestestValue
            } else {
                if (u = e.getData().indicesOfNearest(h[0], t, "category" === i.type ? .5 : null), !u.length) return;
                l = e.getData().get(h[0], u[0])
            }
            if (null != l && isFinite(l)) {
                var d = t - l, f = Math.abs(d);
                r >= f && ((r > f || d >= 0 && 0 > s) && (r = f, s = d, o = l, a.length = 0), _z(u, function (t) {
                    a.push({seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t)})
                }))
            }
        }), {payloadBatch: a, snapToValue: o}
    }

    function Dy(t, e, i, n) {
        t[e.key] = {value: i, payloadBatch: n}
    }

    function Cy(t, e, i, n) {
        var o = i.payloadBatch, a = e.axis, r = a.model, s = e.axisPointerModel;
        if (e.triggerTooltip && o.length) {
            var l = e.coordSys.model, u = Sd(l), h = t.map[u];
            h || (h = t.map[u] = {
                coordSysId: l.id,
                coordSysIndex: l.componentIndex,
                coordSysType: l.type,
                coordSysMainType: l.mainType,
                dataByAxis: []
            }, t.list.push(h)), h.dataByAxis.push({
                axisDim: a.dim,
                axisIndex: r.componentIndex,
                axisType: r.type,
                axisId: r.id,
                value: n,
                valueLabelOpt: {precision: s.get("label.precision"), formatter: s.get("label.formatter")},
                seriesDataIndices: o.slice()
            })
        }
    }

    function Ly(t, e, i) {
        var n = i.axesInfo = [];
        _z(e, function (e, i) {
            var o = e.axisPointerModel.option, a = t[i];
            a ? (!e.useHandle && (o.status = "show"), o.value = a.value, o.seriesDataIndices = (a.payloadBatch || []).slice()) : !e.useHandle && (o.status = "hide"), "show" === o.status && n.push({
                axisDim: e.axis.dim,
                axisIndex: e.axis.model.componentIndex,
                value: o.value
            })
        })
    }

    function ky(t, e, i, n) {
        if (Ny(e) || !t.list.length) return void n({type: "hideTip"});
        var o = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
        n({
            type: "showTip",
            escapeConnect: !0,
            x: e[0],
            y: e[1],
            tooltipOption: i.tooltipOption,
            position: i.position,
            dataIndexInside: o.dataIndexInside,
            dataIndex: o.dataIndex,
            seriesIndex: o.seriesIndex,
            dataByCoordSys: t.list
        })
    }

    function Py(t, e, i) {
        var n = i.getZr(), o = "axisPointerLastHighlights", a = bz(n)[o] || {}, r = bz(n)[o] = {};
        _z(t, function (t) {
            var e = t.axisPointerModel.option;
            "show" === e.status && _z(e.seriesDataIndices, function (t) {
                var e = t.seriesIndex + " | " + t.dataIndex;
                r[e] = t
            })
        });
        var s = [], l = [];
        f(a, function (t, e) {
            !r[e] && l.push(t)
        }), f(r, function (t, e) {
            !a[e] && s.push(t)
        }), l.length && i.dispatchAction({
            type: "downplay",
            escapeConnect: !0,
            batch: l
        }), s.length && i.dispatchAction({type: "highlight", escapeConnect: !0, batch: s})
    }

    function Oy(t, e) {
        for (var i = 0; i < (t || []).length; i++) {
            var n = t[i];
            if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n
        }
    }

    function Ey(t) {
        var e = t.axis.model, i = {}, n = i.axisDim = t.axis.dim;
        return i.axisIndex = i[n + "AxisIndex"] = e.componentIndex, i.axisName = i[n + "AxisName"] = e.name, i.axisId = i[n + "AxisId"] = e.id, i
    }

    function Ny(t) {
        return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1])
    }

    function Ry(t, e, i) {
        if (!WS.node) {
            var n = e.getZr();
            Mz(n).records || (Mz(n).records = {}), zy(n, e);
            var o = Mz(n).records[t] || (Mz(n).records[t] = {});
            o.handler = i
        }
    }

    function zy(t, e) {
        function i(i, n) {
            t.on(i, function (i) {
                var o = Fy(e);
                Iz(Mz(t).records, function (t) {
                    t && n(t, i, o.dispatchAction)
                }), By(o.pendings, e)
            })
        }

        Mz(t).initialized || (Mz(t).initialized = !0, i("click", x(Gy, "click")), i("mousemove", x(Gy, "mousemove")), i("globalout", Vy))
    }

    function By(t, e) {
        var i, n = t.showTip.length, o = t.hideTip.length;
        n ? i = t.showTip[n - 1] : o && (i = t.hideTip[o - 1]), i && (i.dispatchAction = null, e.dispatchAction(i))
    }

    function Vy(t, e, i) {
        t.handler("leave", null, i)
    }

    function Gy(t, e, i, n) {
        e.handler(t, i, n)
    }

    function Fy(t) {
        var e = {showTip: [], hideTip: []}, i = function (n) {
            var o = e[n.type];
            o ? o.push(n) : (n.dispatchAction = i, t.dispatchAction(n))
        };
        return {dispatchAction: i, pendings: e}
    }

    function Wy(t, e) {
        if (!WS.node) {
            var i = e.getZr(), n = (Mz(i).records || {})[t];
            n && (Mz(i).records[t] = null)
        }
    }

    function Hy() {
    }

    function Zy(t, e, i, n) {
        Uy(Az(i).lastProp, n) || (Az(i).lastProp = n, e ? or(i, n, t) : (i.stopAnimation(), i.attr(n)))
    }

    function Uy(t, e) {
        if (S(t) && S(e)) {
            var i = !0;
            return f(e, function (e, n) {
                i = i && Uy(t[n], e)
            }), !!i
        }
        return t === e
    }

    function Xy(t, e) {
        t[e.get("label.show") ? "show" : "hide"]()
    }

    function Yy(t) {
        return {position: t.position.slice(), rotation: t.rotation || 0}
    }

    function jy(t, e, i) {
        var n = e.get("z"), o = e.get("zlevel");
        t && t.traverse(function (t) {
            "group" !== t.type && (null != n && (t.z = n), null != o && (t.zlevel = o), t.silent = i)
        })
    }

    function qy(t) {
        var e, i = t.get("type"), n = t.getModel(i + "Style");
        return "line" === i ? (e = n.getLineStyle(), e.fill = null) : "shadow" === i && (e = n.getAreaStyle(), e.stroke = null), e
    }

    function Ky(t, e, i, n, o) {
        var a = i.get("value"), r = Jy(a, e.axis, e.ecModel, i.get("seriesDataIndices"), {
                precision: i.get("label.precision"),
                formatter: i.get("label.formatter")
            }), s = i.getModel("label"), l = dD(s.get("padding") || 0), u = s.getFont(), h = Xi(r, u), c = o.position,
            d = h.width + l[1] + l[3], f = h.height + l[0] + l[2], p = o.align;
        "right" === p && (c[0] -= d), "center" === p && (c[0] -= d / 2);
        var g = o.verticalAlign;
        "bottom" === g && (c[1] -= f), "middle" === g && (c[1] -= f / 2), $y(c, d, f, n);
        var m = s.get("backgroundColor");
        m && "auto" !== m || (m = e.get("axisLine.lineStyle.color")), t.label = {
            shape: {
                x: 0,
                y: 0,
                width: d,
                height: f,
                r: s.get("borderRadius")
            },
            position: c.slice(),
            style: {
                text: r,
                textFont: u,
                textFill: s.getTextColor(),
                textPosition: "inside",
                textPadding: l,
                fill: m,
                stroke: s.get("borderColor") || "transparent",
                lineWidth: s.get("borderWidth") || 0,
                shadowBlur: s.get("shadowBlur"),
                shadowColor: s.get("shadowColor"),
                shadowOffsetX: s.get("shadowOffsetX"),
                shadowOffsetY: s.get("shadowOffsetY")
            },
            z2: 10
        }
    }

    function $y(t, e, i, n) {
        var o = n.getWidth(), a = n.getHeight();
        t[0] = Math.min(t[0] + e, o) - e, t[1] = Math.min(t[1] + i, a) - i, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0)
    }

    function Jy(t, e, i, n, o) {
        t = e.scale.parse(t);
        var a = e.scale.getLabel(t, {precision: o.precision}), r = o.formatter;
        if (r) {
            var s = {value: Qh(e, t), axisDimension: e.dim, axisIndex: e.index, seriesData: []};
            f(n, function (t) {
                var e = i.getSeriesByIndex(t.seriesIndex), n = t.dataIndexInside, o = e && e.getDataParams(n);
                o && s.seriesData.push(o)
            }), b(r) ? a = r.replace("{value}", a) : w(r) && (a = r(s))
        }
        return a
    }

    function Qy(t, e, i) {
        var n = Oe();
        return Be(n, n, i.rotation), ze(n, n, i.position), sr([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n)
    }

    function tx(t, e, i, n, o, a) {
        var r = yP.innerTextLayout(i.rotation, 0, i.labelDirection);
        i.labelMargin = o.get("label.margin"), Ky(e, n, o, a, {
            position: Qy(n.axis, t, i),
            align: r.textAlign,
            verticalAlign: r.textVerticalAlign
        })
    }

    function ex(t, e, i) {
        return i = i || 0, {x1: t[i], y1: t[1 - i], x2: e[i], y2: e[1 - i]}
    }

    function ix(t, e, i) {
        return i = i || 0, {x: t[i], y: t[1 - i], width: e[i], height: e[1 - i]}
    }

    function nx(t, e, i, n, o, a) {
        return {cx: t, cy: e, r0: i, r: n, startAngle: o, endAngle: a, clockwise: !0}
    }

    function ox(t, e) {
        var i = {};
        return i[e.dim + "AxisIndex"] = e.index, t.getCartesian(i)
    }

    function ax(t) {
        return "x" === t.dim ? 0 : 1
    }

    function rx(t) {
        return t.isHorizontal() ? 0 : 1
    }

    function sx(t, e) {
        var i = t.getRect();
        return [i[Pz[e]], i[Pz[e]] + i[Oz[e]]]
    }

    function lx(t, e, i) {
        var n = new CA({shape: {x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20}});
        return ar(n, {shape: {width: t.width + 20, height: t.height + 20}}, e, i), n
    }

    function ux(t, e, i) {
        if (t.count()) for (var n, o = e.coordinateSystem, a = e.getLayerSeries(), r = t.mapDimension("single"), s = t.mapDimension("value"), l = p(a, function (e) {
            return p(e.indices, function (e) {
                var i = o.dataToPoint(t.get(r, e));
                return i[1] = t.get(s, e), i
            })
        }), u = hx(l), h = u.y0, c = i / u.max, d = a.length, f = a[0].indices.length, g = 0; f > g; ++g) {
            n = h[g] * c, t.setItemLayout(a[0].indices[g], {layerIndex: 0, x: l[0][g][0], y0: n, y: l[0][g][1] * c});
            for (var m = 1; d > m; ++m) n += l[m - 1][g][1] * c, t.setItemLayout(a[m].indices[g], {
                layerIndex: m,
                x: l[m][g][0],
                y0: n,
                y: l[m][g][1] * c
            })
        }
    }

    function hx(t) {
        for (var e, i = t.length, n = t[0].length, o = [], a = [], r = 0, s = {}, l = 0; n > l; ++l) {
            for (var u = 0, e = 0; i > u; ++u) e += t[u][l][1];
            e > r && (r = e), o.push(e)
        }
        for (var h = 0; n > h; ++h) a[h] = (r - o[h]) / 2;
        r = 0;
        for (var c = 0; n > c; ++c) {
            var d = o[c] + a[c];
            d > r && (r = d)
        }
        return s.y0 = a, s.max = r, s
    }

    function cx(t, e, i, n) {
        var o = t.getItemLayout(e), a = i.get("symbolRepeat"), r = i.get("symbolClip"),
            s = i.get("symbolPosition") || "start", l = i.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0,
            h = i.get("symbolPatternSize") || 2, c = i.isAnimationEnabled(), d = {
                dataIndex: e,
                layout: o,
                itemModel: i,
                symbolType: t.getItemVisual(e, "symbol") || "circle",
                color: t.getItemVisual(e, "color"),
                symbolClip: r,
                symbolRepeat: a,
                symbolRepeatDirection: i.get("symbolRepeatDirection"),
                symbolPatternSize: h,
                rotation: u,
                animationModel: c ? i : null,
                hoverAnimation: c && i.get("hoverAnimation"),
                z2: i.getShallow("z", !0) || 0
            };
        dx(i, a, o, n, d), px(t, e, o, a, r, d.boundingLength, d.pxSign, h, n, d), gx(i, d.symbolScale, u, n, d);
        var f = d.symbolSize, p = i.get("symbolOffset");
        return _(p) && (p = [Ir(p[0], f[0]), Ir(p[1], f[1])]), mx(i, f, o, a, r, p, s, d.valueLineWidth, d.boundingLength, d.repeatCutLength, n, d), d
    }

    function dx(t, e, i, n, o) {
        var a, r = n.valueDim, s = t.get("symbolBoundingData"), l = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()),
            u = l.toGlobalCoord(l.dataToCoord(0)), h = 1 - +(i[r.wh] <= 0);
        if (_(s)) {
            var c = [fx(l, s[0]) - u, fx(l, s[1]) - u];
            c[1] < c[0] && c.reverse(), a = c[h]
        } else a = null != s ? fx(l, s) - u : e ? n.coordSysExtent[r.index][h] - u : i[r.wh];
        o.boundingLength = a, e && (o.repeatCutLength = i[r.wh]), o.pxSign = a > 0 ? 1 : 0 > a ? -1 : 0
    }

    function fx(t, e) {
        return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e)))
    }

    function px(t, e, i, n, o, a, r, s, l, u) {
        var h = l.valueDim, c = l.categoryDim, d = Math.abs(i[c.wh]), f = t.getItemVisual(e, "symbolSize");
        _(f) ? f = f.slice() : (null == f && (f = "100%"), f = [f, f]), f[c.index] = Ir(f[c.index], d), f[h.index] = Ir(f[h.index], n ? d : Math.abs(a)), u.symbolSize = f;
        var p = u.symbolScale = [f[0] / s, f[1] / s];
        p[h.index] *= (l.isHorizontal ? -1 : 1) * r
    }

    function gx(t, e, i, n, o) {
        var a = t.get(Fz) || 0;
        a && (Hz.attr({
            scale: e.slice(),
            rotation: i
        }), Hz.updateTransform(), a /= Hz.getLineScale(), a *= e[n.valueDim.index]), o.valueLineWidth = a
    }

    function mx(t, e, i, n, o, a, s, l, u, h, c, d) {
        var f = c.categoryDim, p = c.valueDim, g = d.pxSign, m = Math.max(e[p.index] + l, 0), v = m;
        if (n) {
            var y = Math.abs(u), x = D(t.get("symbolMargin"), "15%") + "", _ = !1;
            x.lastIndexOf("!") === x.length - 1 && (_ = !0, x = x.slice(0, x.length - 1)), x = Ir(x, e[p.index]);
            var w = Math.max(m + 2 * x, 0), b = _ ? 0 : 2 * x, S = Gr(n), M = S ? n : Ex((y + b) / w), I = y - M * m;
            x = I / 2 / (_ ? M : M - 1), w = m + 2 * x, b = _ ? 0 : 2 * x, S || "fixed" === n || (M = h ? Ex((Math.abs(h) + b) / w) : 0), v = M * w - b, d.repeatTimes = M, d.symbolMargin = x
        }
        var T = g * (v / 2), A = d.pathPosition = [];
        A[f.index] = i[f.wh] / 2, A[p.index] = "start" === s ? T : "end" === s ? u - T : u / 2, a && (A[0] += a[0], A[1] += a[1]);
        var C = d.bundlePosition = [];
        C[f.index] = i[f.xy], C[p.index] = i[p.xy];
        var L = d.barRectShape = r({}, i);
        L[p.wh] = g * Math.max(Math.abs(i[p.wh]), Math.abs(A[p.index] + T)), L[f.wh] = i[f.wh];
        var k = d.clipShape = {};
        k[f.xy] = -i[f.xy], k[f.wh] = c.ecSize[f.wh], k[p.xy] = 0, k[p.wh] = i[p.wh]
    }

    function vx(t) {
        var e = t.symbolPatternSize, i = ac(t.symbolType, -e / 2, -e / 2, e, e, t.color);
        return i.attr({culling: !0}), "image" !== i.type && i.setStyle({strokeNoScale: !0}), i
    }

    function yx(t, e, i, n) {
        function o(t) {
            var e = h.slice(), n = i.pxSign, o = t;
            return ("start" === i.symbolRepeatDirection ? n > 0 : 0 > n) && (o = d - 1 - t), e[c.index] = p * (o - d / 2 + .5) + h[c.index], {
                position: e,
                scale: i.symbolScale.slice(),
                rotation: i.rotation
            }
        }

        function a() {
            kx(t, function (t) {
                t.trigger("emphasis")
            })
        }

        function r() {
            kx(t, function (t) {
                t.trigger("normal")
            })
        }

        var s = t.__pictorialBundle, l = i.symbolSize, u = i.valueLineWidth, h = i.pathPosition, c = e.valueDim,
            d = i.repeatTimes || 0, f = 0, p = l[e.valueDim.index] + u + 2 * i.symbolMargin;
        for (kx(t, function (t) {
            t.__pictorialAnimationIndex = f, t.__pictorialRepeatTimes = d, d > f ? Px(t, null, o(f), i, n) : Px(t, null, {scale: [0, 0]}, i, n, function () {
                s.remove(t)
            }), Tx(t, i), f++
        }); d > f; f++) {
            var g = vx(i);
            g.__pictorialAnimationIndex = f, g.__pictorialRepeatTimes = d, s.add(g);
            var m = o(f);
            Px(g, {position: m.position, scale: [0, 0]}, {
                scale: m.scale,
                rotation: m.rotation
            }, i, n), g.on("mouseover", a).on("mouseout", r), Tx(g, i)
        }
    }

    function xx(t, e, i, n) {
        function o() {
            this.trigger("emphasis")
        }

        function a() {
            this.trigger("normal")
        }

        var r = t.__pictorialBundle, s = t.__pictorialMainPath;
        s ? Px(s, null, {
            position: i.pathPosition.slice(),
            scale: i.symbolScale.slice(),
            rotation: i.rotation
        }, i, n) : (s = t.__pictorialMainPath = vx(i), r.add(s), Px(s, {
            position: i.pathPosition.slice(),
            scale: [0, 0],
            rotation: i.rotation
        }, {scale: i.symbolScale.slice()}, i, n), s.on("mouseover", o).on("mouseout", a)), Tx(s, i)
    }

    function _x(t, e, i) {
        var n = r({}, e.barRectShape), o = t.__pictorialBarRect;
        o ? Px(o, null, {shape: n}, e, i) : (o = t.__pictorialBarRect = new CA({
            z2: 2,
            shape: n,
            silent: !0,
            style: {stroke: "transparent", fill: "transparent", lineWidth: 0}
        }), t.add(o))
    }

    function bx(t, e, i, n) {
        if (i.symbolClip) {
            var o = t.__pictorialClipPath, a = r({}, i.clipShape), s = e.valueDim, l = i.animationModel,
                u = i.dataIndex;
            if (o) or(o, {shape: a}, l, u); else {
                a[s.wh] = 0, o = new CA({shape: a}), t.__pictorialBundle.setClipPath(o), t.__pictorialClipPath = o;
                var h = {};
                h[s.wh] = i.clipShape[s.wh], tD[n ? "updateProps" : "initProps"](o, {shape: h}, l, u)
            }
        }
    }

    function Sx(t, e) {
        var i = t.getItemModel(e);
        return i.getAnimationDelayParams = Mx, i.isAnimationEnabled = Ix, i
    }

    function Mx(t) {
        return {index: t.__pictorialAnimationIndex, count: t.__pictorialRepeatTimes}
    }

    function Ix() {
        return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation")
    }

    function Tx(t, e) {
        t.off("emphasis").off("normal");
        var i = e.symbolScale.slice();
        e.hoverAnimation && t.on("emphasis", function () {
            this.animateTo({scale: [1.1 * i[0], 1.1 * i[1]]}, 400, "elasticOut")
        }).on("normal", function () {
            this.animateTo({scale: i.slice()}, 400, "elasticOut")
        })
    }

    function Ax(t, e, i, n) {
        var o = new iI, a = new iI;
        return o.add(a), o.__pictorialBundle = a, a.attr("position", i.bundlePosition.slice()), i.symbolRepeat ? yx(o, e, i) : xx(o, e, i), _x(o, i, n), bx(o, e, i, n), o.__pictorialShapeStr = Lx(t, i), o.__pictorialSymbolMeta = i, o
    }

    function Dx(t, e, i) {
        var n = i.animationModel, o = i.dataIndex, a = t.__pictorialBundle;
        or(a, {position: i.bundlePosition.slice()}, n, o), i.symbolRepeat ? yx(t, e, i, !0) : xx(t, e, i, !0), _x(t, i, !0), bx(t, e, i, !0)
    }

    function Cx(t, e, i, n) {
        var o = n.__pictorialBarRect;
        o && (o.style.text = null);
        var a = [];
        kx(n, function (t) {
            a.push(t)
        }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (i = null), f(a, function (t) {
            or(t, {scale: [0, 0]}, i, e, function () {
                n.parent && n.parent.remove(n)
            })
        }), t.setItemGraphicEl(e, null)
    }

    function Lx(t, e) {
        return [t.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":")
    }

    function kx(t, e, i) {
        f(t.__pictorialBundle.children(), function (n) {
            n !== t.__pictorialBarRect && e.call(i, n)
        })
    }

    function Px(t, e, i, n, o, a) {
        e && t.attr(e), n.symbolClip && !o ? i && t.attr(i) : i && tD[o ? "updateProps" : "initProps"](t, i, n.animationModel, n.dataIndex, a)
    }

    function Ox(t, e, i) {
        var n = i.color, o = i.dataIndex, a = i.itemModel, r = a.getModel("itemStyle").getItemStyle(["color"]),
            l = a.getModel("emphasis.itemStyle").getItemStyle(), u = a.getShallow("cursor");
        kx(t, function (t) {
            t.setColor(n), t.setStyle(s({fill: n, opacity: i.opacity}, r)), Wa(t, l), u && (t.cursor = u), t.z2 = i.z2
        });
        var h = {}, c = e.valueDim.posDesc[+(i.boundingLength > 0)], d = t.__pictorialBarRect;
        Fc(d.style, h, a, n, e.seriesModel, o, c), Wa(d, h)
    }

    function Ex(t) {
        var e = Math.round(t);
        return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t)
    }

    function Nx(t, e) {
        return e = e || [0, 0], p(["x", "y"], function (i, n) {
            var o = this.getAxis(i), a = e[n], r = t[n] / 2;
            return "category" === o.type ? o.getBandWidth() : Math.abs(o.dataToCoord(a - r) - o.dataToCoord(a + r))
        }, this)
    }

    function Rx(t, e) {
        return e = e || [0, 0], p([0, 1], function (i) {
            var n = e[i], o = t[i] / 2, a = [], r = [];
            return a[i] = n - o, r[i] = n + o, a[1 - i] = r[1 - i] = e[1 - i], Math.abs(this.dataToPoint(a)[i] - this.dataToPoint(r)[i])
        }, this)
    }

    function zx(t, e) {
        var i = this.getAxis(), n = e instanceof Array ? e[0] : e, o = (t instanceof Array ? t[0] : t) / 2;
        return "category" === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - o) - i.dataToCoord(n + o))
    }

    function Bx(t, e) {
        return p(["Radius", "Angle"], function (i, n) {
            var o = this["get" + i + "Axis"](), a = e[n], r = t[n] / 2, s = "dataTo" + i,
                l = "category" === o.type ? o.getBandWidth() : Math.abs(o[s](a - r) - o[s](a + r));
            return "Angle" === i && (l = l * Math.PI / 180), l
        }, this)
    }

    function Vx(t) {
        var e, i = t.type;
        if ("path" === i) {
            var n = t.shape, o = null != n.width && null != n.height ? {
                x: n.x || 0,
                y: n.y || 0,
                width: n.width,
                height: n.height
            } : null, a = Qx(n);
            e = Sa(a, null, o, n.layout || "center"), e.__customPathData = a
        } else if ("image" === i) e = new Cn({}), e.__customImagePath = t.style.image; else if ("text" === i) e = new vA({}), e.__customText = t.style.text; else if ("group" === i) e = new iI; else {
            if ("compoundPath" === i) throw new Error('"compoundPath" is not supported yet.');
            var r = ba(i);
            BS && O(r, 'graphic type "' + i + '" can not be found.'), e = new r
        }
        return e.__customGraphicType = i, e.name = t.name, e
    }

    function Gx(t, e, i, o, a, r, s) {
        var l = {}, u = i.style || {};
        if (i.shape && (l.shape = n(i.shape)), i.position && (l.position = i.position.slice()), i.scale && (l.scale = i.scale.slice()), i.origin && (l.origin = i.origin.slice()), i.rotation && (l.rotation = i.rotation), "image" === t.type && i.style) {
            var h = l.style = {};
            f(["x", "y", "width", "height"], function (e) {
                Fx(e, h, u, t.style, r)
            })
        }
        if ("text" === t.type && i.style) {
            var h = l.style = {};
            f(["x", "y"], function (e) {
                Fx(e, h, u, t.style, r)
            }), !u.hasOwnProperty("textFill") && u.fill && (u.textFill = u.fill), !u.hasOwnProperty("textStroke") && u.stroke && (u.textStroke = u.stroke)
        }
        if ("group" !== t.type && (t.useStyle(u), r)) {
            t.style.opacity = 0;
            var c = u.opacity;
            null == c && (c = 1), ar(t, {style: {opacity: c}}, o, e)
        }
        r ? t.attr(l) : or(t, l, o, e), i.hasOwnProperty("z2") && t.attr("z2", i.z2 || 0), i.hasOwnProperty("silent") && t.attr("silent", i.silent), i.hasOwnProperty("invisible") && t.attr("invisible", i.invisible), i.hasOwnProperty("ignore") && t.attr("ignore", i.ignore), i.hasOwnProperty("info") && t.attr("info", i.info);
        var d = i.styleEmphasis;
        Ra(t, d), s && Ha(t, d !== !1)
    }

    function Fx(t, e, i, n, o) {
        null == i[t] || o || (e[t] = i[t], i[t] = n[t])
    }

    function Wx(t, e, i, n) {
        function o(t) {
            null == t && (t = m), S && (v = e.getItemModel(t), y = v.getModel(Jz), x = v.getModel(Qz), _ = e.getItemVisual(t, "color"), S = !1)
        }

        function a(t, i) {
            return null == i && (i = m), e.get(e.getDimension(t || 0), i)
        }

        function r(i, n) {
            null == n && (n = m), o(n);
            var a = v.getModel(Kz).getItemStyle();
            null != _ && (a.fill = _);
            var r = e.getItemVisual(n, "opacity");
            null != r && (a.opacity = r);
            var s = i ? Kx(i, y) : y;
            return ja(a, s, null, {
                autoColor: _,
                isRectText: !0
            }), a.text = s.getShallow("show") ? C(t.getFormattedLabel(n, "normal"), Gc(e, n)) : null, i && $x(a, i), a
        }

        function l(i, n) {
            null == n && (n = m), o(n);
            var a = v.getModel($z).getItemStyle(), r = i ? Kx(i, x) : x;
            return ja(a, r, null, {isRectText: !0}, !0), a.text = r.getShallow("show") ? L(t.getFormattedLabel(n, "emphasis"), t.getFormattedLabel(n, "normal"), Gc(e, n)) : null, i && $x(a, i), a
        }

        function u(t, i) {
            return null == i && (i = m), e.getItemVisual(i, t)
        }

        function h(t) {
            if (p.getBaseAxis) {
                var e = p.getBaseAxis();
                return Rh(s({axis: e}, t), n)
            }
        }

        function c() {
            return i.getCurrentSeriesIndices()
        }

        function d(t) {
            return ir(t, i)
        }

        var f = t.get("renderItem"), p = t.coordinateSystem, g = {};
        p && (BS && (O(f, "series.render is required."), O(p.prepareCustoms || eB[p.type], "This coordSys does not support custom series.")), g = p.prepareCustoms ? p.prepareCustoms() : eB[p.type](p));
        var m, v, y, x, _, w = s({
            getWidth: n.getWidth,
            getHeight: n.getHeight,
            getZr: n.getZr,
            getDevicePixelRatio: n.getDevicePixelRatio,
            value: a,
            style: r,
            styleEmphasis: l,
            visual: u,
            barLayout: h,
            currentSeriesIndices: c,
            font: d
        }, g.api || {}), b = {
            context: {},
            seriesId: t.id,
            seriesName: t.name,
            seriesIndex: t.seriesIndex,
            coordSys: g.coordSys,
            dataInsideLength: e.count(),
            encode: Hx(t.getData())
        }, S = !0;
        return function (t, i) {
            return m = t, S = !0, f && f(s({
                dataIndexInside: t,
                dataIndex: e.getRawIndex(t),
                actionType: i ? i.type : null
            }, b), w)
        }
    }

    function Hx(t) {
        var e = {};
        return f(t.dimensions, function (i, n) {
            var o = t.getDimensionInfo(i);
            if (!o.isExtraCoord) {
                var a = o.coordDim, r = e[a] = e[a] || [];
                r[o.coordDimIndex] = n
            }
        }), e
    }

    function Zx(t, e, i, n, o, a) {
        return t = Ux(t, e, i, n, o, a, !0), t && a.setItemGraphicEl(e, t), t
    }

    function Ux(t, e, i, n, o, a, r) {
        var s = !i;
        i = i || {};
        var l = i.type, u = i.shape, h = i.style;
        if (t && (s || null != l && l !== t.__customGraphicType || "path" === l && t_(u) && Qx(u) !== t.__customPathData || "image" === l && e_(h, "image") && h.image !== t.__customImagePath || "text" === l && e_(u, "text") && h.text !== t.__customText) && (o.remove(t), t = null), !s) {
            var c = !t;
            return !t && (t = Vx(i)), Gx(t, e, i, n, a, c, r), "group" === l && Xx(t, e, i, n, a), o.add(t), t
        }
    }

    function Xx(t, e, i, n, o) {
        var a = i.children, r = a ? a.length : 0, s = i.$mergeChildren, l = "byName" === s || i.diffChildrenByName,
            u = s === !1;
        if (r || l || u) {
            if (l) return void Yx({
                oldChildren: t.children() || [],
                newChildren: a || [],
                dataIndex: e,
                animatableModel: n,
                group: t,
                data: o
            });
            u && t.removeAll();
            for (var h = 0; r > h; h++) a[h] && Ux(t.childAt(h), e, a[h], n, t, o);
            BS && O(!u || t.childCount() === h, "MUST NOT contain empty item in children array when `group.$mergeChildren` is `false`.")
        }
    }

    function Yx(t) {
        new Yu(t.oldChildren, t.newChildren, jx, jx, t).add(qx).update(qx).remove(Jx).execute()
    }

    function jx(t, e) {
        var i = t && t.name;
        return null != i ? i : tB + e
    }

    function qx(t, e) {
        var i = this.context, n = null != t ? i.newChildren[t] : null, o = null != e ? i.oldChildren[e] : null;
        Ux(o, i.dataIndex, n, i.animatableModel, i.group, i.data)
    }

    function Kx(t, e) {
        var i = new vr({}, e);
        return f(qz, function (e, n) {
            t.hasOwnProperty(e) && (i.option[n] = t[e])
        }), i
    }

    function $x(t, e) {
        for (var i in e) (e.hasOwnProperty(i) || !qz.hasOwnProperty(i)) && (t[i] = e[i])
    }

    function Jx(t) {
        var e = this.context, i = e.oldChildren[t];
        i && e.group.remove(i)
    }

    function Qx(t) {
        return t && (t.pathData || t.d)
    }

    function t_(t) {
        return t && (t.hasOwnProperty("pathData") || t.hasOwnProperty("d"))
    }

    function e_(t, e) {
        return t && t.hasOwnProperty(e)
    }

    function i_(t) {
        return t.get("stack") || "__ec_stack_" + t.seriesIndex
    }

    function n_(t, e) {
        return e.dim + t.model.componentIndex
    }

    function o_(t, e) {
        var i = {}, n = a_(m(e.getSeriesByType(t), function (t) {
            return !e.isSeriesFiltered(t) && t.coordinateSystem && "polar" === t.coordinateSystem.type
        }));
        e.eachSeriesByType(t, function (t) {
            if ("polar" === t.coordinateSystem.type) {
                var e = t.getData(), o = t.coordinateSystem, a = o.getBaseAxis(), r = n_(o, a), s = i_(t), l = n[r][s],
                    u = l.offset, h = l.width, c = o.getOtherAxis(a), d = t.coordinateSystem.cx,
                    f = t.coordinateSystem.cy, p = t.get("barMinHeight") || 0, g = t.get("barMinAngle") || 0;
                i[s] = i[s] || [];
                for (var m = e.mapDimension(c.dim), v = e.mapDimension(a.dim), y = wh(e, m), x = "radius" !== a.dim || !t.get("roundCap", !0), _ = "radius" === c.dim ? c.dataToRadius(0) : c.dataToAngle(0), w = 0, b = e.count(); b > w; w++) {
                    var S = e.get(m, w), M = e.get(v, w), I = S >= 0 ? "p" : "n", T = _;
                    y && (i[s][M] || (i[s][M] = {p: _, n: _}), T = i[s][M][I]);
                    var A, D, C, L;
                    if ("radius" === c.dim) {
                        var k = c.dataToRadius(S) - _, P = a.dataToAngle(M);
                        Math.abs(k) < p && (k = (0 > k ? -1 : 1) * p), A = T, D = T + k, C = P - u, L = C - h, y && (i[s][M][I] = D)
                    } else {
                        var O = c.dataToAngle(S, x) - _, E = a.dataToRadius(M);
                        Math.abs(O) < g && (O = (0 > O ? -1 : 1) * g), A = E + u, D = A + h, C = T, L = T + O, y && (i[s][M][I] = L)
                    }
                    e.setItemLayout(w, {
                        cx: d,
                        cy: f,
                        r0: A,
                        r: D,
                        startAngle: -C * Math.PI / 180,
                        endAngle: -L * Math.PI / 180
                    })
                }
            }
        }, this)
    }

    function a_(t) {
        var e = {};
        f(t, function (t) {
            var i = t.getData(), n = t.coordinateSystem, o = n.getBaseAxis(), a = n_(n, o), r = o.getExtent(),
                s = "category" === o.type ? o.getBandWidth() : Math.abs(r[1] - r[0]) / i.count(), l = e[a] || {
                    bandWidth: s,
                    remainedWidth: s,
                    autoWidthCount: 0,
                    categoryGap: "20%",
                    gap: "30%",
                    stacks: {}
                }, u = l.stacks;
            e[a] = l;
            var h = i_(t);
            u[h] || l.autoWidthCount++, u[h] = u[h] || {width: 0, maxWidth: 0};
            var c = Ir(t.get("barWidth"), s), d = Ir(t.get("barMaxWidth"), s), f = t.get("barGap"),
                p = t.get("barCategoryGap");
            c && !u[h].width && (c = Math.min(l.remainedWidth, c), u[h].width = c, l.remainedWidth -= c), d && (u[h].maxWidth = d), null != f && (l.gap = f), null != p && (l.categoryGap = p)
        });
        var i = {};
        return f(e, function (t, e) {
            i[e] = {};
            var n = t.stacks, o = t.bandWidth, a = Ir(t.categoryGap, o), r = Ir(t.gap, 1), s = t.remainedWidth,
                l = t.autoWidthCount, u = (s - a) / (l + (l - 1) * r);
            u = Math.max(u, 0), f(n, function (t) {
                var e = t.maxWidth;
                e && u > e && (e = Math.min(e, s), t.width && (e = Math.min(e, t.width)), s -= e, t.width = e, l--)
            }), u = (s - a) / (l + (l - 1) * r), u = Math.max(u, 0);
            var h, c = 0;
            f(n, function (t) {
                t.width || (t.width = u), h = t, c += t.width * (1 + r)
            }), h && (c -= h.width * r);
            var d = -c / 2;
            f(n, function (t, n) {
                i[e][n] = i[e][n] || {offset: d, width: t.width}, d += t.width * (1 + r)
            })
        }), i
    }

    function r_(t, e) {
        Zk.call(this, "radius", t, e), this.type = "category"
    }

    function s_(t, e) {
        e = e || [0, 360], Zk.call(this, "angle", t, e), this.type = "category"
    }

    function l_(t, e) {
        return e.type || (e.data ? "category" : "value")
    }

    function u_(t, e, i) {
        var n = e.get("center"), o = i.getWidth(), a = i.getHeight();
        t.cx = Ir(n[0], o), t.cy = Ir(n[1], a);
        var r = t.getRadiusAxis(), s = Math.min(o, a) / 2, l = e.get("radius");
        null == l ? l = [0, "100%"] : _(l) || (l = [0, l]), l = [Ir(l[0], s), Ir(l[1], s)], r.inverse ? r.setExtent(l[1], l[0]) : r.setExtent(l[0], l[1])
    }

    function h_(t) {
        var e = this, i = e.getAngleAxis(), n = e.getRadiusAxis();
        if (i.scale.setExtent(1 / 0, -1 / 0), n.scale.setExtent(1 / 0, -1 / 0), t.eachSeries(function (t) {
            if (t.coordinateSystem === e) {
                var o = t.getData();
                f(o.mapDimension("radius", !0), function (t) {
                    n.scale.unionExtentFromData(o, bh(o, t))
                }), f(o.mapDimension("angle", !0), function (t) {
                    i.scale.unionExtentFromData(o, bh(o, t))
                })
            }
        }), qh(i.scale, i.model), qh(n.scale, n.model), "category" === i.type && !i.onBand) {
            var o = i.getExtent(), a = 360 / i.scale.count();
            i.inverse ? o[1] += a : o[1] -= a, i.setExtent(o[0], o[1])
        }
    }

    function c_(t, e) {
        if (t.type = e.get("type"), t.scale = Kh(e), t.onBand = e.get("boundaryGap") && "category" === t.type, t.inverse = e.get("inverse"), "angleAxis" === e.mainType) {
            t.inverse ^= e.get("clockwise");
            var i = e.get("startAngle");
            t.setExtent(i, i + (t.inverse ? -360 : 360))
        }
        e.axis = t, t.model = e
    }

    function d_(t, e, i) {
        e[1] > e[0] && (e = e.slice().reverse());
        var n = t.coordToPoint([e[0], i]), o = t.coordToPoint([e[1], i]);
        return {x1: n[0], y1: n[1], x2: o[0], y2: o[1]}
    }

    function f_(t) {
        var e = t.getRadiusAxis();
        return e.inverse ? 0 : 1
    }

    function p_(t) {
        var e = t[0], i = t[t.length - 1];
        e && i && Math.abs(Math.abs(e.coord - i.coord) - 360) < 1e-4 && t.pop()
    }

    function g_(t, e, i) {
        return {
            position: [t.cx, t.cy],
            rotation: i / 180 * Math.PI,
            labelDirection: -1,
            tickDirection: -1,
            nameDirection: 1,
            labelRotate: e.getModel("axisLabel").get("rotate"),
            z2: 1
        }
    }

    function m_(t, e, i, n, o) {
        var a = e.axis, r = a.dataToCoord(t), s = n.getAngleAxis().getExtent()[0];
        s = s / 180 * Math.PI;
        var l, u, h, c = n.getRadiusAxis().getExtent();
        if ("radius" === a.dim) {
            var d = Oe();
            Be(d, d, s), ze(d, d, [n.cx, n.cy]), l = sr([r, -o], d);
            var f = e.getModel("axisLabel").get("rotate") || 0, p = yP.innerTextLayout(s, f * Math.PI / 180, -1);
            u = p.textAlign, h = p.textVerticalAlign
        } else {
            var g = c[1];
            l = n.coordToPoint([g + o, r]);
            var m = n.cx, v = n.cy;
            u = Math.abs(l[0] - m) / g < .3 ? "center" : l[0] > m ? "left" : "right", h = Math.abs(l[1] - v) / g < .3 ? "middle" : l[1] > v ? "top" : "bottom"
        }
        return {position: l, align: u, verticalAlign: h}
    }

    function v_(t, e) {
        e.update = "updateView", Pu(e, function (e, i) {
            var n = {};
            return i.eachComponent({mainType: "geo", query: e}, function (i) {
                i[t](e.name);
                var o = i.coordinateSystem;
                f(o.regions, function (t) {
                    n[t.name] = i.isSelected(t.name) || !1
                })
            }), {selected: n, name: e.name}
        })
    }

    function y_(t) {
        this._model = t
    }

    function x_(t, e, i, n) {
        var o = i.calendarModel, a = i.seriesModel, r = o ? o.coordinateSystem : a ? a.coordinateSystem : null;
        return r === this ? r[t](n) : null
    }

    function __(t, e) {
        var i = t.cellSize;
        _(i) ? 1 === i.length && (i[1] = i[0]) : i = t.cellSize = [i, i];
        var n = p([0, 1], function (t) {
            return ns(e, t) && (i[t] = "auto"), null != i[t] && "auto" !== i[t]
        });
        os(t, e, {type: "box", ignoreSize: n})
    }

    function w_(t, e, i) {
        var n, o = {}, a = "toggleSelected" === t;
        return i.eachComponent("legend", function (i) {
            a && null != n ? i[n ? "select" : "unSelect"](e.name) : "allSelect" === t || "inverseSelect" === t ? i[t]() : (i[t](e.name), n = i.isSelected(e.name));
            var r = i.getData();
            f(r, function (t) {
                var e = t.get("name");
                if ("\n" !== e && "" !== e) {
                    var n = i.isSelected(e);
                    o[e] = o.hasOwnProperty(e) ? o[e] && n : n
                }
            })
        }), "allSelect" === t || "inverseSelect" === t ? {selected: o} : {name: e.name, selected: o}
    }

    function b_(t, e, i) {
        var n = e.getBoxLayoutParams(), o = e.get("padding"), a = {width: i.getWidth(), height: i.getHeight()},
            r = es(n, a, o);
        bD(e.get("orient"), t, e.get("itemGap"), r.width, r.height), is(t, n, a, o)
    }

    function S_(t, e) {
        var i = dD(e.get("padding")), n = e.getItemStyle(["color", "opacity"]);
        n.fill = e.get("backgroundColor");
        var t = new CA({
            shape: {
                x: t.x - i[3],
                y: t.y - i[0],
                width: t.width + i[1] + i[3],
                height: t.height + i[0] + i[2],
                r: e.get("borderRadius")
            }, style: n, silent: !0, z2: -1
        });
        return t
    }

    function M_(t, e, i, n, o, a) {
        var r;
        return "line" !== e && e.indexOf("empty") < 0 ? (r = i.getItemStyle(), t.style.stroke = n, a || (r.stroke = o)) : r = i.getItemStyle(["borderWidth", "borderColor"]), t.setStyle(r)
    }

    function I_(t, e, i, n) {
        A_(t, e, i, n), i.dispatchAction({type: "legendToggleSelect", name: null != t ? t : e}), T_(t, e, i, n)
    }

    function T_(t, e, i, n) {
        var o = i.getZr().storage.getDisplayList()[0];
        o && o.useHoverLayer || i.dispatchAction({type: "highlight", seriesName: t, name: e, excludeSeriesId: n})
    }

    function A_(t, e, i, n) {
        var o = i.getZr().storage.getDisplayList()[0];
        o && o.useHoverLayer || i.dispatchAction({type: "downplay", seriesName: t, name: e, excludeSeriesId: n})
    }

    function D_(t, e, i) {
        var n = t.getOrient(), o = [1, 1];
        o[n.index] = 0, os(e, i, {type: "box", ignoreSize: o})
    }

    function C_(t) {
        var e = "cubic-bezier(0.23, 1, 0.32, 1)", i = "left " + t + "s " + e + ",top " + t + "s " + e;
        return p(PB, function (t) {
            return t + "transition:" + i
        }).join(";")
    }

    function L_(t) {
        var e = [], i = t.get("fontSize"), n = t.getTextColor();
        n && e.push("color:" + n), e.push("font:" + t.getFont());
        var o = t.get("lineHeight");
        null == o && (o = Math.round(3 * i / 2)), i && e.push("line-height:" + o + "px");
        var a = t.get("textShadowColor"), r = t.get("textShadowBlur") || 0, s = t.get("textShadowOffsetX") || 0,
            l = t.get("textShadowOffsetY") || 0;
        return r && e.push("text-shadow:" + s + "px " + l + "px " + r + "px " + a), LB(["decoration", "align"], function (i) {
            var n = t.get(i);
            n && e.push("text-" + i + ":" + n)
        }), e.join(";")
    }

    function k_(t) {
        var e = [], i = t.get("transitionDuration"), n = t.get("backgroundColor"), o = t.getModel("textStyle"),
            a = t.get("padding");
        return i && e.push(C_(i)), n && (WS.canvasSupported ? e.push("background-Color:" + n) : (e.push("background-Color:#" + oi(n)), e.push("filter:alpha(opacity=70)"))), LB(["width", "color", "radius"], function (i) {
            var n = "border-" + i, o = kB(n), a = t.get(o);
            null != a && e.push(n + ":" + a + ("color" === i ? "" : "px"))
        }), e.push(L_(o)), null != a && e.push("padding:" + dD(a).join("px ") + "px"), e.join(";") + ";"
    }

    function P_(t, e, i, n, o) {
        var a = e && e.painter;
        if (i) {
            var r = a && a.getViewportRoot();
            r && pe(t, r, document.body, n, o)
        } else {
            t[0] = n, t[1] = o;
            var s = a && a.getViewportRootOffset();
            s && (t[0] += s.offsetLeft, t[1] += s.offsetTop)
        }
        t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight()
    }

    function O_(t, e, i) {
        if (WS.wxa) return null;
        var n = document.createElement("div");
        n.domBelongToZr = !0, this.el = n;
        var o = this._zr = e.getZr(), a = this._appendToBody = i && i.appendToBody;
        this._styleCoord = [0, 0, 0, 0], P_(this._styleCoord, o, a, e.getWidth() / 2, e.getHeight() / 2), a ? document.body.appendChild(n) : t.appendChild(n), this._container = t, this._show = !1, this._hideTimeout;
        var r = this;
        n.onmouseenter = function () {
            r._enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0
        }, n.onmousemove = function (t) {
            if (t = t || window.event, !r._enterable) {
                var e = o.handler, i = o.painter.getViewportRoot();
                be(i, t, !0), e.dispatch("mousemove", t)
            }
        }, n.onmouseleave = function () {
            r._enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1
        }
    }

    function E_(t, e, i, n) {
        t[0] = i, t[1] = n, t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight()
    }

    function N_(t) {
        var e = this._zr = t.getZr();
        this._styleCoord = [0, 0, 0, 0], E_(this._styleCoord, e, t.getWidth() / 2, t.getHeight() / 2), this._show = !1, this._hideTimeout
    }

    function R_(t) {
        for (var e = t.pop(); t.length;) {
            var i = t.pop();
            i && (vr.isInstance(i) && (i = i.get("tooltip", !0)), "string" == typeof i && (i = {formatter: i}), e = new vr(i, e, e.ecModel))
        }
        return e
    }

    function z_(t, e) {
        return t.dispatchAction || y(e.dispatchAction, e)
    }

    function B_(t, e, i, n, o, a, r) {
        var s = i.getOuterSize(), l = s.width, u = s.height;
        return null != a && (t + l + a > n ? t -= l + a : t += a), null != r && (e + u + r > o ? e -= u + r : e += r), [t, e]
    }

    function V_(t, e, i, n, o) {
        var a = i.getOuterSize(), r = a.width, s = a.height;
        return t = Math.min(t + r, n) - r, e = Math.min(e + s, o) - s, t = Math.max(t, 0), e = Math.max(e, 0), [t, e]
    }

    function G_(t, e, i) {
        var n = i[0], o = i[1], a = 5, r = 0, s = 0, l = e.width, u = e.height;
        switch (t) {
            case"inside":
                r = e.x + l / 2 - n / 2, s = e.y + u / 2 - o / 2;
                break;
            case"top":
                r = e.x + l / 2 - n / 2, s = e.y - o - a;
                break;
            case"bottom":
                r = e.x + l / 2 - n / 2, s = e.y + u + a;
                break;
            case"left":
                r = e.x - n - a, s = e.y + u / 2 - o / 2;
                break;
            case"right":
                r = e.x + l + a, s = e.y + u / 2 - o / 2
        }
        return [r, s]
    }

    function F_(t) {
        return "center" === t || "middle" === t
    }

    function W_(t) {
        io(t, "label", ["show"])
    }

    function H_(t) {
        return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)))
    }

    function Z_(t) {
        return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y))
    }

    function U_(t, e, i, n, o, a) {
        var r = [], s = wh(e, n), l = s ? e.getCalculationInfo("stackResultDimension") : n, u = $_(e, l, t),
            h = e.indicesOfNearest(l, u)[0];
        r[o] = e.get(i, h), r[a] = e.get(l, h);
        var c = e.get(n, h), d = Dr(e.get(n, h));
        return d = Math.min(d, 20), d >= 0 && (r[a] = +r[a].toFixed(d)), [r, c]
    }

    function X_(t, e) {
        var i = t.getData(), o = t.coordinateSystem;
        if (e && !Z_(e) && !_(e.coord) && o) {
            var a = o.dimensions, r = Y_(e, i, o, t);
            if (e = n(e), e.type && HB[e.type] && r.baseAxis && r.valueAxis) {
                var s = FB(a, r.baseAxis.dim), l = FB(a, r.valueAxis.dim),
                    u = HB[e.type](i, r.baseDataDim, r.valueDataDim, s, l);
                e.coord = u[0], e.value = u[1]
            } else {
                for (var h = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], c = 0; 2 > c; c++) HB[h[c]] && (h[c] = $_(i, i.mapDimension(a[c]), h[c]));
                e.coord = h
            }
        }
        return e
    }

    function Y_(t, e, i, n) {
        var o = {};
        return null != t.valueIndex || null != t.valueDim ? (o.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, o.valueAxis = i.getAxis(j_(n, o.valueDataDim)), o.baseAxis = i.getOtherAxis(o.valueAxis), o.baseDataDim = e.mapDimension(o.baseAxis.dim)) : (o.baseAxis = n.getBaseAxis(), o.valueAxis = i.getOtherAxis(o.baseAxis), o.baseDataDim = e.mapDimension(o.baseAxis.dim), o.valueDataDim = e.mapDimension(o.valueAxis.dim)), o
    }

    function j_(t, e) {
        var i = t.getData(), n = i.dimensions;
        e = i.getDimension(e);
        for (var o = 0; o < n.length; o++) {
            var a = i.getDimensionInfo(n[o]);
            if (a.name === e) return a.coordDim
        }
    }

    function q_(t, e) {
        return t && t.containData && e.coord && !H_(e) ? t.containData(e.coord) : !0
    }

    function K_(t, e, i, n) {
        return 2 > n ? t.coord && t.coord[n] : t.value
    }

    function $_(t, e, i) {
        if ("average" === i) {
            var n = 0, o = 0;
            return t.each(e, function (t) {
                isNaN(t) || (n += t, o++)
            }), n / o
        }
        return "median" === i ? t.getMedian(e) : t.getDataExtent(e, !0)["max" === i ? 1 : 0]
    }

    function J_(t, e, i) {
        var n = e.coordinateSystem;
        t.each(function (o) {
            var a, r = t.getItemModel(o), s = Ir(r.get("x"), i.getWidth()), l = Ir(r.get("y"), i.getHeight());
            if (isNaN(s) || isNaN(l)) {
                if (e.getMarkerPosition) a = e.getMarkerPosition(t.getValues(t.dimensions, o)); else if (n) {
                    var u = t.get(n.dimensions[0], o), h = t.get(n.dimensions[1], o);
                    a = n.dataToPoint([u, h])
                }
            } else a = [s, l];
            isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), t.setItemLayout(o, a)
        })
    }

    function Q_(t, e, i) {
        var n;
        n = t ? p(t && t.dimensions, function (t) {
            var i = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {};
            return s({name: t}, i)
        }) : [{name: "value", type: "float"}];
        var o = new qL(n, i), a = p(i.get("data"), x(X_, e));
        return t && (a = m(a, x(q_, t))), o.initData(a, null, t ? K_ : function (t) {
            return t.value
        }), o
    }

    function tw(t) {
        return !isNaN(t) && !isFinite(t)
    }

    function ew(t, e, i, n) {
        var o = 1 - t, a = n.dimensions[t];
        return tw(e[o]) && tw(i[o]) && e[t] === i[t] && n.getAxis(a).containData(e[t])
    }

    function iw(t, e) {
        if ("cartesian2d" === t.type) {
            var i = e[0].coord, n = e[1].coord;
            if (i && n && (ew(1, i, n, t) || ew(0, i, n, t))) return !0
        }
        return q_(t, e[0]) && q_(t, e[1])
    }

    function nw(t, e, i, n, o) {
        var a, r = n.coordinateSystem, s = t.getItemModel(e), l = Ir(s.get("x"), o.getWidth()),
            u = Ir(s.get("y"), o.getHeight());
        if (isNaN(l) || isNaN(u)) {
            if (n.getMarkerPosition) a = n.getMarkerPosition(t.getValues(t.dimensions, e)); else {
                var h = r.dimensions, c = t.get(h[0], e), d = t.get(h[1], e);
                a = r.dataToPoint([c, d])
            }
            if ("cartesian2d" === r.type) {
                var f = r.getAxis("x"), p = r.getAxis("y"), h = r.dimensions;
                tw(t.get(h[0], e)) ? a[0] = f.toGlobalCoord(f.getExtent()[i ? 0 : 1]) : tw(t.get(h[1], e)) && (a[1] = p.toGlobalCoord(p.getExtent()[i ? 0 : 1]))
            }
            isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u)
        } else a = [l, u];
        t.setItemLayout(e, a)
    }

    function ow(t, e, i) {
        var n;
        n = t ? p(t && t.dimensions, function (t) {
            var i = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {};
            return s({name: t}, i)
        }) : [{name: "value", type: "float"}];
        var o = new qL(n, i), a = new qL(n, i), r = new qL([], i), l = p(i.get("data"), x(UB, e, t, i));
        t && (l = m(l, x(iw, t)));
        var u = t ? K_ : function (t) {
            return t.value
        };
        return o.initData(p(l, function (t) {
            return t[0]
        }), null, u), a.initData(p(l, function (t) {
            return t[1]
        }), null, u), r.initData(p(l, function (t) {
            return t[2]
        })), r.hasItemOption = !0, {from: o, to: a, line: r}
    }

    function aw(t) {
        return !isNaN(t) && !isFinite(t)
    }

    function rw(t, e, i) {
        var n = 1 - t;
        return aw(e[n]) && aw(i[n])
    }

    function sw(t, e) {
        var i = e.coord[0], n = e.coord[1];
        return "cartesian2d" === t.type && i && n && (rw(1, i, n, t) || rw(0, i, n, t)) ? !0 : q_(t, {
            coord: i,
            x: e.x0,
            y: e.y0
        }) || q_(t, {coord: n, x: e.x1, y: e.y1})
    }

    function lw(t, e, i, n, o) {
        var a, r = n.coordinateSystem, s = t.getItemModel(e), l = Ir(s.get(i[0]), o.getWidth()),
            u = Ir(s.get(i[1]), o.getHeight());
        if (isNaN(l) || isNaN(u)) {
            if (n.getMarkerPosition) a = n.getMarkerPosition(t.getValues(i, e)); else {
                var h = t.get(i[0], e), c = t.get(i[1], e), d = [h, c];
                r.clampData && r.clampData(d, d), a = r.dataToPoint(d, !0)
            }
            if ("cartesian2d" === r.type) {
                var f = r.getAxis("x"), p = r.getAxis("y"), h = t.get(i[0], e), c = t.get(i[1], e);
                aw(h) ? a[0] = f.toGlobalCoord(f.getExtent()["x0" === i[0] ? 0 : 1]) : aw(c) && (a[1] = p.toGlobalCoord(p.getExtent()["y0" === i[1] ? 0 : 1]))
            }
            isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u)
        } else a = [l, u];
        return a
    }

    function uw(t, e, i) {
        var n, o, a = ["x0", "y0", "x1", "y1"];
        t ? (n = p(t && t.dimensions, function (t) {
            var i = e.getData(), n = i.getDimensionInfo(i.mapDimension(t)) || {};
            return s({name: t}, n)
        }), o = new qL(p(a, function (t, e) {
            return {name: t, type: n[e % 2].type}
        }), i)) : (n = [{name: "value", type: "float"}], o = new qL(n, i));
        var r = p(i.get("data"), x(XB, e, t, i));
        t && (r = m(r, x(sw, t)));
        var l = t ? function (t, e, i, n) {
            return t.coord[Math.floor(n / 2)][n % 2]
        } : function (t) {
            return t.value
        };
        return o.initData(r, null, l), o.hasItemOption = !0, o
    }

    function hw(t) {
        var e = t.type, i = {number: "value", time: "time"};
        if (i[e] && (t.axisType = i[e], delete t.type), cw(t), dw(t, "controlPosition")) {
            var n = t.controlStyle || (t.controlStyle = {});
            dw(n, "position") || (n.position = t.controlPosition), "none" !== n.position || dw(n, "show") || (n.show = !1, delete n.position), delete t.controlPosition
        }
        f(t.data || [], function (t) {
            S(t) && !_(t) && (!dw(t, "value") && dw(t, "name") && (t.value = t.name), cw(t))
        })
    }

    function cw(t) {
        var e = t.itemStyle || (t.itemStyle = {}), i = e.emphasis || (e.emphasis = {}), n = t.label || t.label || {},
            o = n.normal || (n.normal = {}), a = {normal: 1, emphasis: 1};
        f(n, function (t, e) {
            a[e] || dw(o, e) || (o[e] = t)
        }), i.label && !dw(n, "emphasis") && (n.emphasis = i.label, delete i.label)
    }

    function dw(t, e) {
        return t.hasOwnProperty(e)
    }

    function fw(t, e) {
        return es(t.getBoxLayoutParams(), {width: e.getWidth(), height: e.getHeight()}, t.get("padding"))
    }

    function pw(t, e, i, n) {
        var o = n.style, a = dr(t.get(e), n || {}, new Ti(i[0], i[1], i[2], i[3]));
        return o && a.setStyle(o), a
    }

    function gw(t, e, i, n, a, r) {
        var s = e.get("color");
        if (a) a.setColor(s), i.add(a), r && r.onUpdate(a); else {
            var l = t.get("symbol");
            a = ac(l, -1, -1, 2, 2, s), a.setStyle("strokeNoScale", !0), i.add(a), r && r.onCreate(a)
        }
        var u = e.getItemStyle(["color", "symbol", "symbolSize"]);
        a.setStyle(u), n = o({rectHover: !0, z2: 100}, n, !0);
        var h = t.get("symbolSize");
        h = h instanceof Array ? h.slice() : [+h, +h], h[0] /= 2, h[1] /= 2, n.scale = h;
        var c = t.get("symbolOffset");
        if (c) {
            var d = n.position = n.position || [0, 0];
            d[0] += Ir(c[0], h[0]), d[1] += Ir(c[1], h[1])
        }
        var f = t.get("symbolRotate");
        return n.rotation = (f || 0) * Math.PI / 180 || 0, a.attr(n), a.updateTransform(), a
    }

    function mw(t, e, i, n, o) {
        if (!t.dragging) {
            var a = n.getModel("checkpointStyle"), r = i.dataToCoord(n.getData().get(["value"], e));
            o || !a.get("animation", !0) ? t.attr({position: [r, 0]}) : (t.stopAnimation(!0), t.animateTo({position: [r, 0]}, a.get("animationDuration", !0), a.get("animationEasing", !0)))
        }
    }

    function vw(t) {
        return u(nV, t) >= 0
    }

    function yw(t, e) {
        t = t.slice();
        var i = p(t, qr);
        e = (e || []).slice();
        var n = p(e, qr);
        return function (o, a) {
            f(t, function (t, r) {
                for (var s = {name: t, capital: i[r]}, l = 0; l < e.length; l++) s[e[l]] = t + n[l];
                o.call(a, s)
            })
        }
    }

    function xw(t, e, i) {
        function n(t, e) {
            return u(e.nodes, t) >= 0
        }

        function o(t, n) {
            var o = !1;
            return e(function (e) {
                f(i(t, e) || [], function (t) {
                    n.records[e.name][t] && (o = !0)
                })
            }), o
        }

        function a(t, n) {
            n.nodes.push(t), e(function (e) {
                f(i(t, e) || [], function (t) {
                    n.records[e.name][t] = !0
                })
            })
        }

        return function (i) {
            function r(t) {
                !n(t, s) && o(t, s) && (a(t, s), l = !0)
            }

            var s = {nodes: [], records: {}};
            if (e(function (t) {
                s.records[t.name] = {}
            }), !i) return s;
            a(i, s);
            var l;
            do l = !1, t(r); while (l);
            return s
        }
    }

    function _w(t, e, i) {
        var n = [1 / 0, -1 / 0];
        return aV(i, function (t) {
            var i = t.getData();
            i && aV(i.mapDimension(e, !0), function (t) {
                var e = i.getApproximateExtent(t);
                e[0] < n[0] && (n[0] = e[0]), e[1] > n[1] && (n[1] = e[1])
            })
        }), n[1] < n[0] && (n = [0 / 0, 0 / 0]), ww(t, n), n
    }

    function ww(t, e) {
        var i = t.getAxisModel(), n = i.getMin(!0), o = "category" === i.get("type"), a = o && i.getCategories().length;
        null != n && "dataMin" !== n && "function" != typeof n ? e[0] = n : o && (e[0] = a > 0 ? 0 : 0 / 0);
        var r = i.getMax(!0);
        return null != r && "dataMax" !== r && "function" != typeof r ? e[1] = r : o && (e[1] = a > 0 ? a - 1 : 0 / 0), i.get("scale", !0) || (e[0] > 0 && (e[0] = 0), e[1] < 0 && (e[1] = 0)), e
    }

    function bw(t, e) {
        var i = t.getAxisModel(), n = t._percentWindow, o = t._valueWindow;
        if (n) {
            var a = Lr(o, [0, 500]);
            a = Math.min(a, 20);
            var r = e || 0 === n[0] && 100 === n[1];
            i.setRange(r ? null : +o[0].toFixed(a), r ? null : +o[1].toFixed(a))
        }
    }

    function Sw(t) {
        var e = t._minMaxSpan = {}, i = t._dataZoomModel, n = t._dataExtent;
        aV(["min", "max"], function (o) {
            var a = i.get(o + "Span"), r = i.get(o + "ValueSpan");
            null != r && (r = t.getAxisModel().axis.scale.parse(r)), null != r ? a = Mr(n[0] + r, n, [0, 100], !0) : null != a && (r = Mr(a, [0, 100], n, !0) - n[0]), e[o + "Span"] = a, e[o + "ValueSpan"] = r
        })
    }

    function Mw(t) {
        var e = {};
        return lV(["start", "end", "startValue", "endValue", "throttle"], function (i) {
            t.hasOwnProperty(i) && (e[i] = t[i])
        }), e
    }

    function Iw(t, e) {
        var i = t._rangePropMode, n = t.get("rangeMode");
        lV([["start", "startValue"], ["end", "endValue"]], function (t, o) {
            var a = null != e[t[0]], r = null != e[t[1]];
            a && !r ? i[o] = "percent" : !a && r ? i[o] = "value" : n ? i[o] = n[o] : a && (i[o] = "percent")
        })
    }

    function Tw(t) {
        var e = {x: "y", y: "x", radius: "angle", angle: "radius"};
        return e[t]
    }

    function Aw(t) {
        return "vertical" === t ? "ns-resize" : "ew-resize"
    }

    function Dw(t, e) {
        var i = kw(t), n = e.dataZoomId, o = e.coordId;
        f(i, function (t) {
            var i = t.dataZoomInfos;
            i[n] && u(e.allCoordIds, o) < 0 && (delete i[n], t.count--)
        }), Ow(i);
        var a = i[o];
        a || (a = i[o] = {
            coordId: o,
            dataZoomInfos: {},
            count: 0
        }, a.controller = Pw(t, a), a.dispatchAction = x(Ew, t)), !a.dataZoomInfos[n] && a.count++, a.dataZoomInfos[n] = e;
        var r = Nw(a.dataZoomInfos);
        a.controller.enable(r.controlType, r.opt), a.controller.setPointerChecker(e.containsPoint), Ml(a, "dispatchAction", e.dataZoomModel.get("throttle", !0), "fixRate")
    }

    function Cw(t, e) {
        var i = kw(t);
        f(i, function (t) {
            t.controller.dispose();
            var i = t.dataZoomInfos;
            i[e] && (delete i[e], t.count--)
        }), Ow(i)
    }

    function Lw(t) {
        return t.type + "\x00_" + t.id
    }

    function kw(t) {
        var e = t.getZr();
        return e[IV] || (e[IV] = {})
    }

    function Pw(t, e) {
        var i = new hp(t.getZr());
        return f(["pan", "zoom", "scrollMove"], function (t) {
            i.on(t, function (i) {
                var n = [];
                f(e.dataZoomInfos, function (o) {
                    if (i.isAvailableBehavior(o.dataZoomModel.option)) {
                        var a = (o.getRange || {})[t], r = a && a(e.controller, i);
                        !o.dataZoomModel.get("disabled", !0) && r && n.push({
                            dataZoomId: o.dataZoomId,
                            start: r[0],
                            end: r[1]
                        })
                    }
                }), n.length && e.dispatchAction(n)
            })
        }), i
    }

    function Ow(t) {
        f(t, function (e, i) {
            e.count || (e.controller.dispose(), delete t[i])
        })
    }

    function Ew(t, e) {
        t.dispatchAction({type: "dataZoom", batch: e})
    }

    function Nw(t) {
        var e, i = "type_", n = {type_true: 2, type_move: 1, type_false: 0, type_undefined: -1}, o = !0;
        return f(t, function (t) {
            var a = t.dataZoomModel, r = a.get("disabled", !0) ? !1 : a.get("zoomLock", !0) ? "move" : !0;
            n[i + r] > n[i + e] && (e = r), o &= a.get("preventDefaultMouseMove", !0)
        }), {
            controlType: e,
            opt: {zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !0, preventDefaultMouseMove: !!o}
        }
    }

    function Rw(t) {
        return function (e, i, n, o) {
            var a = this._range, r = a.slice(), s = e.axisModels[0];
            if (s) {
                var l = t(r, s, e, i, n, o);
                return xR(l, r, [0, 100], "all"), this._range = r, a[0] !== r[0] || a[1] !== r[1] ? r : void 0
            }
        }
    }

    function zw(t) {
        var e = {};
        f(t, function (t) {
            e[t] = 1
        }), t.length = 0, f(e, function (e, i) {
            t.push(i)
        })
    }

    function Bw(t) {
        if (t) for (var e in t) if (t.hasOwnProperty(e)) return !0
    }

    function Vw(t, e, i) {
        function o() {
            var t = function () {
            };
            t.prototype.__hidden = t.prototype;
            var e = new t;
            return e
        }

        var a = {};
        return PV(e, function (e) {
            var r = a[e] = o();
            PV(t[e], function (t, o) {
                if (pE.isValidType(o)) {
                    var a = {type: o, visual: t};
                    i && i(a, e), r[o] = new pE(a), "opacity" === o && (a = n(a), a.type = "colorAlpha", r.__hidden.__alphaForOpacity = new pE(a))
                }
            })
        }), a
    }

    function Gw(t, e, i) {
        var o;
        f(i, function (t) {
            e.hasOwnProperty(t) && Bw(e[t]) && (o = !0)
        }), o && f(i, function (i) {
            e.hasOwnProperty(i) && Bw(e[i]) ? t[i] = n(e[i]) : delete t[i]
        })
    }

    function Fw(t, e, i, n, o, a) {
        function r(t) {
            return i.getItemVisual(h, t)
        }

        function s(t, e) {
            i.setItemVisual(h, t, e)
        }

        function l(t, l) {
            h = null == a ? t : l;
            var c = i.getRawDataItem(h);
            if (!c || c.visualMap !== !1) for (var d = n.call(o, t), f = e[d], p = u[d], g = 0, m = p.length; m > g; g++) {
                var v = p[g];
                f[v] && f[v].applyVisual(t, r, s)
            }
        }

        var u = {};
        f(t, function (t) {
            var i = pE.prepareVisualTypes(e[t]);
            u[t] = i
        });
        var h;
        null == a ? i.each(l) : i.each([a], l)
    }

    function Ww(t, e, i, n) {
        function o(t, o) {
            function r(t) {
                return o.getItemVisual(l, t)
            }

            function s(t, e) {
                o.setItemVisual(l, t, e)
            }

            null != n && (n = o.getDimension(n));
            for (var l; null != (l = t.next());) {
                var u = o.getRawDataItem(l);
                if (!u || u.visualMap !== !1) for (var h = null != n ? o.get(n, l, !0) : l, c = i(h), d = e[c], f = a[c], p = 0, g = f.length; g > p; p++) {
                    var m = f[p];
                    d[m] && d[m].applyVisual(h, r, s)
                }
            }
        }

        var a = {};
        return f(t, function (t) {
            var i = pE.prepareVisualTypes(e[t]);
            a[t] = i
        }), {progress: o}
    }

    function Hw(t) {
        var e = ["x", "y"], i = ["width", "height"];
        return {
            point: function (e, i, n) {
                if (e) {
                    var o = n.range, a = e[t];
                    return Zw(a, o)
                }
            }, rect: function (n, o, a) {
                if (n) {
                    var r = a.range, s = [n[e[t]], n[e[t]] + n[i[t]]];
                    return s[1] < s[0] && s.reverse(), Zw(s[0], r) || Zw(s[1], r) || Zw(r[0], s) || Zw(r[1], s)
                }
            }
        }
    }

    function Zw(t, e) {
        return e[0] <= t && t <= e[1]
    }

    function Uw(t, e, i) {
        var n = this._targetInfoList = [], o = {}, a = Yw(e, t);
        EV(GV, function (t, e) {
            (!i || !i.include || NV(i.include, e) >= 0) && t(a, n, o)
        })
    }

    function Xw(t) {
        return t[0] > t[1] && t.reverse(), t
    }

    function Yw(t, e) {
        return fo(t, e, {includeMainTypes: BV})
    }

    function jw(t, e, i, n) {
        BS && O("cartesian2d" === i.type, "lineX/lineY brush is available only in cartesian2d.");
        var o = i.getAxis(["x", "y"][t]), a = Xw(p([0, 1], function (t) {
            return e ? o.coordToData(o.toLocalCoord(n[t])) : o.toGlobalCoord(o.dataToCoord(n[t]))
        })), r = [];
        return r[t] = a, r[1 - t] = [0 / 0, 0 / 0], {values: a, xyMinMax: r}
    }

    function qw(t, e, i, n) {
        return [e[0] - n[t] * i[0], e[1] - n[t] * i[1]]
    }

    function Kw(t, e) {
        var i = $w(t), n = $w(e), o = [i[0] / n[0], i[1] / n[1]];
        return isNaN(o[0]) && (o[0] = 1), isNaN(o[1]) && (o[1] = 1), o
    }

    function $w(t) {
        return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [0 / 0, 0 / 0]
    }

    function Jw(t) {
        t.eachComponent({mainType: "brush"}, function (e) {
            var i = e.brushTargetManager = new Uw(e.option, t);
            i.setInputRanges(e.areas, t)
        })
    }

    function Qw(t, e, i, n, o) {
        if (o) {
            var a = t.getZr();
            if (!a[YV]) {
                a[XV] || (a[XV] = tb);
                var r = Ml(a, XV, i, e);
                r(t, n)
            }
        }
    }

    function tb(t, e) {
        if (!t.isDisposed()) {
            var i = t.getZr();
            i[YV] = !0, t.dispatchAction({type: "brushSelect", batch: e}), i[YV] = !1
        }
    }

    function eb(t, e, i, n) {
        for (var o = 0, a = e.length; a > o; o++) {
            var r = e[o];
            if (t[r.brushType](n, i, r.selectors, r)) return !0
        }
    }

    function ib(t) {
        var e = t.brushSelector;
        if (b(e)) {
            var i = [];
            return f(OV, function (t, n) {
                i[n] = function (i, n, o, a) {
                    var r = n.getItemLayout(i);
                    return t[e](r, o, a)
                }
            }), i
        }
        if (w(e)) {
            var n = {};
            return f(OV, function (t, i) {
                n[i] = e
            }), n
        }
        return e
    }

    function nb(t, e) {
        var i = t.option.seriesIndex;
        return null != i && "all" !== i && (_(i) ? u(i, e) < 0 : e !== i)
    }

    function ob(t) {
        var e = t.selectors = {};
        return f(OV[t.brushType], function (i, n) {
            e[n] = function (n) {
                return i(n, e, t)
            }
        }), t
    }

    function ab(t) {
        return new Ti(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0])
    }

    function rb(t, e) {
        return o({
            brushType: t.brushType,
            brushMode: t.brushMode,
            transformable: t.transformable,
            brushStyle: new vr(t.brushStyle).getItemStyle(),
            removeOnClick: t.removeOnClick,
            z: t.z
        }, e, !0)
    }

    function sb(t, e, i, n) {
        (!n || n.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice())
    }

    function lb(t, e) {
        $V[t] = e
    }

    function ub(t) {
        return $V[t]
    }

    function hb(t, e, i) {
        this.model = t, this.ecModel = e, this.api = i, this._brushType, this._brushMode
    }

    function cb(t, e) {
        return t && t.hasOwnProperty && t.hasOwnProperty(e)
    }

    function db(t, e, i, n) {
        function o(t) {
            return l[t]
        }

        function a(t, e) {
            l[t] = e
        }

        for (var r = e.targetVisuals[n], s = pE.prepareVisualTypes(r), l = {color: t.getData().getVisual("color")}, u = 0, h = s.length; h > u; u++) {
            var c = s[u], d = r["opacity" === c ? "__alphaForOpacity" : c];
            d && d.applyVisual(i, o, a)
        }
        return l.color
    }

    function fb(t, e, i) {
        if (i[0] === i[1]) return i.slice();
        for (var n = 200, o = (i[1] - i[0]) / n, a = i[0], r = [], s = 0; n >= s && a < i[1]; s++) r.push(a), a += o;
        return r.push(i[1]), r
    }

    function pb(t, e, i) {
        var n = t.option, o = n.align;
        if (null != o && "auto" !== o) return o;
        for (var a = {
            width: e.getWidth(),
            height: e.getHeight()
        }, r = "horizontal" === n.orient ? 1 : 0, s = [["left", "right", "width"], ["top", "bottom", "height"]], l = s[r], u = [0, null, 10], h = {}, c = 0; 3 > c; c++) h[s[1 - r][c]] = u[c], h[l[c]] = 2 === c ? i[0] : n[l[c]];
        var d = [["x", "width", 3], ["y", "height", 0]][r], f = es(h, a, n.padding);
        return l[(f.margin[d[2]] || 0) + f[d[0]] + .5 * f[d[1]] < .5 * a[d[1]] ? 0 : 1]
    }

    function gb(t, e) {
        return f(t || [], function (t) {
            null != t.dataIndex && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "")
        }), t
    }

    function mb(t, e, i, n) {
        return new IA({
            shape: {points: t}, draggable: !!i, cursor: e, drift: i, onmousemove: function (t) {
                vM(t.event)
            }, ondragend: n
        })
    }

    function vb(t, e) {
        return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]]
    }

    function yb(t, e, i, n) {
        return t ? [[0, -yG(e, xG(i, 0))], [wG, 0], [0, yG(e, xG(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]]
    }

    function xb(t, e, i) {
        var n = _G / 2, o = t.get("hoverLinkDataSize");
        return o && (n = mG(o, e, i, !0) / 2), n
    }

    function _b(t) {
        var e = t.get("hoverLinkOnHandle");
        return !!(null == e ? t.get("realtime") : e)
    }

    function wb(t) {
        return "vertical" === t ? "ns-resize" : "ew-resize"
    }

    function bb(t, e) {
        var i = t.inverse;
        ("vertical" === t.orient ? !i : i) && e.reverse()
    }

    function Sb(t) {
        return 0 === t.indexOf("my")
    }

    function Mb(t) {
        this.model = t
    }

    function Ib(t) {
        this.model = t
    }

    function Tb(t) {
        var e = {}, i = [], n = [];
        return t.eachRawSeries(function (t) {
            var o = t.coordinateSystem;
            if (!o || "cartesian2d" !== o.type && "polar" !== o.type) i.push(t); else {
                var a = o.getBaseAxis();
                if ("category" === a.type) {
                    var r = a.dim + "_" + a.index;
                    e[r] || (e[r] = {categoryAxis: a, valueAxis: o.getOtherAxis(a), series: []}, n.push({
                        axisDim: a.dim,
                        axisIndex: a.index
                    })), e[r].series.push(t)
                } else i.push(t)
            }
        }), {seriesGroupByCategoryAxis: e, other: i, meta: n}
    }

    function Ab(t) {
        var e = [];
        return f(t, function (t) {
            var i = t.categoryAxis, n = t.valueAxis, o = n.dim, a = [" "].concat(p(t.series, function (t) {
                return t.name
            })), r = [i.model.getCategories()];
            f(t.series, function (t) {
                var e = t.getRawData();
                r.push(t.getRawData().mapArray(e.mapDimension(o), function (t) {
                    return t
                }))
            });
            for (var s = [a.join(RG)], l = 0; l < r[0].length; l++) {
                for (var u = [], h = 0; h < r.length; h++) u.push(r[h][l]);
                s.push(u.join(RG))
            }
            e.push(s.join("\n"))
        }), e.join("\n\n" + NG + "\n\n")
    }

    function Db(t) {
        return p(t, function (t) {
            var e = t.getRawData(), i = [t.name], n = [];
            return e.each(e.dimensions, function () {
                for (var t = arguments.length, o = arguments[t - 1], a = e.getName(o), r = 0; t - 1 > r; r++) n[r] = arguments[r];
                i.push((a ? a + RG : "") + n.join(RG))
            }), i.join("\n")
        }).join("\n\n" + NG + "\n\n")
    }

    function Cb(t) {
        var e = Tb(t);
        return {
            value: m([Ab(e.seriesGroupByCategoryAxis), Db(e.other)], function (t) {
                return t.replace(/[\n\t\s]/g, "")
            }).join("\n\n" + NG + "\n\n"), meta: e.meta
        }
    }

    function Lb(t) {
        return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    }

    function kb(t) {
        var e = t.slice(0, t.indexOf("\n"));
        return e.indexOf(RG) >= 0 ? !0 : void 0
    }

    function Pb(t) {
        for (var e = t.split(/\n+/g), i = Lb(e.shift()).split(zG), n = [], o = p(i, function (t) {
            return {name: t, data: []}
        }), a = 0; a < e.length; a++) {
            var r = Lb(e[a]).split(zG);
            n.push(r.shift());
            for (var s = 0; s < r.length; s++) o[s] && (o[s].data[a] = r[s])
        }
        return {series: o, categories: n}
    }

    function Ob(t) {
        for (var e = t.split(/\n+/g), i = Lb(e.shift()), n = [], o = 0; o < e.length; o++) {
            var a = Lb(e[o]);
            if (a) {
                var r, s = a.split(zG), l = "", u = !1;
                isNaN(s[0]) ? (u = !0, l = s[0], s = s.slice(1), n[o] = {
                    name: l,
                    value: []
                }, r = n[o].value) : r = n[o] = [];
                for (var h = 0; h < s.length; h++) r.push(+s[h]);
                1 === r.length && (u ? n[o].value = r[0] : n[o] = r[0])
            }
        }
        return {name: i, data: n}
    }

    function Eb(t, e) {
        var i = t.split(new RegExp("\n*" + NG + "\n*", "g")), n = {series: []};
        return f(i, function (t, i) {
            if (kb(t)) {
                var o = Pb(t), a = e[i], r = a.axisDim + "Axis";
                a && (n[r] = n[r] || [], n[r][a.axisIndex] = {data: o.categories}, n.series = n.series.concat(o.series))
            } else {
                var o = Ob(t);
                n.series.push(o)
            }
        }), n
    }

    function Nb(t) {
        this._dom = null, this.model = t
    }

    function Rb(t, e) {
        return p(t, function (t, i) {
            var n = e && e[i];
            if (S(n) && !_(n)) {
                var o = S(t) && !_(t);
                o || (t = {value: t});
                var a = null != n.name && null == t.name;
                return t = s(t, n), a && delete t.name, t
            }
            return t
        })
    }

    function zb(t, e) {
        var i = Fb(t);
        BG(e, function (e, n) {
            for (var o = i.length - 1; o >= 0; o--) {
                var a = i[o];
                if (a[n]) break
            }
            if (0 > o) {
                var r = t.queryComponents({mainType: "dataZoom", subType: "select", id: n})[0];
                if (r) {
                    var s = r.getPercentRange();
                    i[0][n] = {dataZoomId: n, start: s[0], end: s[1]}
                }
            }
        }), i.push(e)
    }

    function Bb(t) {
        var e = Fb(t), i = e[e.length - 1];
        e.length > 1 && e.pop();
        var n = {};
        return BG(i, function (t, i) {
            for (var o = e.length - 1; o >= 0; o--) {
                var t = e[o][i];
                if (t) {
                    n[i] = t;
                    break
                }
            }
        }), n
    }

    function Vb(t) {
        t[VG] = null
    }

    function Gb(t) {
        return Fb(t).length
    }

    function Fb(t) {
        var e = t[VG];
        return e || (e = t[VG] = [{}]), e
    }

    function Wb(t, e, i) {
        (this._brushController = new Zm(i.getZr())).on("brush", y(this._onBrush, this)).mount(), this._isZoomActive
    }

    function Hb(t) {
        var e = {};
        return f(["xAxisIndex", "yAxisIndex"], function (i) {
            e[i] = t[i], null == e[i] && (e[i] = "all"), (e[i] === !1 || "none" === e[i]) && (e[i] = [])
        }), e
    }

    function Zb(t, e) {
        t.setIconStatus("back", Gb(e) > 1 ? "emphasis" : "normal")
    }

    function Ub(t, e, i, n, o) {
        var a = i._isZoomActive;
        n && "takeGlobalCursor" === n.type && (a = "dataZoomSelect" === n.key ? n.dataZoomSelectActive : !1), i._isZoomActive = a, t.setIconStatus("zoom", a ? "emphasis" : "normal");
        var r = new Uw(Hb(t.option), e, {include: ["grid"]});
        i._brushController.setPanels(r.makePanelOpts(o, function (t) {
            return t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect"
        })).enableBrush(a ? {brushType: "auto", brushStyle: t.getModel("brushStyle").getItemStyle()} : !1)
    }

    function Xb(t) {
        this.model = t
    }

    function Yb(t, e, i, n) {
        var o = i.type;
        BS && O(o, "graphic type MUST be set");
        var a = YG.hasOwnProperty(o) ? YG[o] : ba(o);
        BS && O(a, "graphic type can not be found");
        var r = new a(i);
        e.add(r), n.set(t, r), r.__ecGraphicId = t
    }

    function jb(t, e) {
        var i = t && t.parent;
        i && ("group" === t.type && t.traverse(function (t) {
            jb(t, e)
        }), e.removeKey(t.__ecGraphicId), i.remove(t))
    }

    function qb(t) {
        return t = r({}, t), f(["id", "parentId", "$action", "hv", "bounding"].concat(_D), function (e) {
            delete t[e]
        }), t
    }

    function Kb(t, e) {
        var i;
        return f(e, function (e) {
            null != t[e] && "auto" !== t[e] && (i = !0)
        }), i
    }

    function $b(t, e) {
        var i = t.exist;
        if (e.id = t.keyInfo.id, !e.type && i && (e.type = i.type), null == e.parentId) {
            var n = e.parentOption;
            n ? e.parentId = n.id : i && (e.parentId = i.parentId)
        }
        e.parentOption = null
    }

    function Jb(t, e, i) {
        var n = r({}, i), a = t[e], s = i.$action || "merge";
        if ("merge" === s) if (a) {
            if (BS) {
                var l = i.type;
                O(!l || a.type === l, 'Please set $action: "replace" to change `type`')
            }
            o(a, n, !0), os(a, n, {ignoreSize: !0}), rs(i, a)
        } else t[e] = n; else "replace" === s ? t[e] = n : "remove" === s && a && (t[e] = null)
    }

    function Qb(t, e) {
        t && (t.hv = e.hv = [Kb(e, ["left", "right"]), Kb(e, ["top", "bottom"])], "group" === t.type && (null == t.width && (t.width = e.width = 0), null == t.height && (t.height = e.height = 0)))
    }

    function tS(t, e) {
        var i = t.eventData;
        t.silent || t.ignore || i || (i = t.eventData = {
            componentType: "graphic",
            componentIndex: e.componentIndex,
            name: t.name
        }), i && (i.info = t.info)
    }

    function eS(t) {
        return qG(t)
    }

    function iS() {
        if (!JG && QG) {
            JG = !0;
            var t = QG.styleSheets;
            t.length < 31 ? QG.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
        }
    }

    function nS(t) {
        return parseInt(t, 10)
    }

    function oS(t, e) {
        iS(), this.root = t, this.storage = e;
        var i = document.createElement("div"), n = document.createElement("div");
        i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this.resize();
        var o = e.delFromStorage, a = e.addToStorage;
        e.delFromStorage = function (t) {
            o.call(e, t), t && t.onRemove && t.onRemove(n)
        }, e.addToStorage = function (t) {
            t.onAdd && t.onAdd(n), a.call(e, t)
        }, this._firstPaint = !0
    }

    function aS(t) {
        return function () {
            KM('In IE8.0 VML mode painter not support method "' + t + '"')
        }
    }

    function rS(t) {
        return document.createElementNS(HF, t)
    }

    function sS(t) {
        return YF(1e4 * t) / 1e4
    }

    function lS(t) {
        return QF > t && t > -QF
    }

    function uS(t, e) {
        var i = e ? t.textFill : t.fill;
        return null != i && i !== XF
    }

    function hS(t, e) {
        var i = e ? t.textStroke : t.stroke;
        return null != i && i !== XF
    }

    function cS(t, e) {
        e && dS(t, "transform", "matrix(" + UF.call(e, ",") + ")")
    }

    function dS(t, e, i) {
        (!i || "linear" !== i.type && "radial" !== i.type) && t.setAttribute(e, i)
    }

    function fS(t, e, i) {
        t.setAttributeNS("http://www.w3.org/1999/xlink", e, i)
    }

    function pS(t, e, i, n) {
        if (uS(e, i)) {
            var o = i ? e.textFill : e.fill;
            o = "transparent" === o ? XF : o, dS(t, "fill", o), dS(t, "fill-opacity", null != e.fillOpacity ? e.fillOpacity * e.opacity : e.opacity)
        } else dS(t, "fill", XF);
        if (hS(e, i)) {
            var a = i ? e.textStroke : e.stroke;
            a = "transparent" === a ? XF : a, dS(t, "stroke", a);
            var r = i ? e.textStrokeWidth : e.lineWidth, s = !i && e.strokeNoScale ? n.getLineScale() : 1;
            dS(t, "stroke-width", r / s), dS(t, "paint-order", i ? "stroke" : "fill"), dS(t, "stroke-opacity", null != e.strokeOpacity ? e.strokeOpacity : e.opacity);
            var l = e.lineDash;
            l ? (dS(t, "stroke-dasharray", e.lineDash.join(",")), dS(t, "stroke-dashoffset", YF(e.lineDashOffset || 0))) : dS(t, "stroke-dasharray", ""), e.lineCap && dS(t, "stroke-linecap", e.lineCap), e.lineJoin && dS(t, "stroke-linejoin", e.lineJoin), e.miterLimit && dS(t, "stroke-miterlimit", e.miterLimit)
        } else dS(t, "stroke", XF)
    }

    function gS(t) {
        for (var e = [], i = t.data, n = t.len(), o = 0; n > o;) {
            var a = i[o++], r = "", s = 0;
            switch (a) {
                case ZF.M:
                    r = "M", s = 2;
                    break;
                case ZF.L:
                    r = "L", s = 2;
                    break;
                case ZF.Q:
                    r = "Q", s = 4;
                    break;
                case ZF.C:
                    r = "C", s = 6;
                    break;
                case ZF.A:
                    var l = i[o++], u = i[o++], h = i[o++], c = i[o++], d = i[o++], f = i[o++], p = i[o++], g = i[o++],
                        m = Math.abs(f), v = lS(m - $F) || (g ? f >= $F : -f >= $F), y = f > 0 ? f % $F : f % $F + $F,
                        x = !1;
                    x = v ? !0 : lS(m) ? !1 : y >= KF == !!g;
                    var _ = sS(l + h * qF(d)), w = sS(u + c * jF(d));
                    v && (f = g ? $F - 1e-4 : -$F + 1e-4, x = !0, 9 === o && e.push("M", _, w));
                    var b = sS(l + h * qF(d + f)), S = sS(u + c * jF(d + f));
                    e.push("A", sS(h), sS(c), YF(p * JF), +x, +g, b, S);
                    break;
                case ZF.Z:
                    r = "Z";
                    break;
                case ZF.R:
                    var b = sS(i[o++]), S = sS(i[o++]), M = sS(i[o++]), I = sS(i[o++]);
                    e.push("M", b, S, "L", b + M, S, "L", b + M, S + I, "L", b, S + I, "L", b, S)
            }
            r && e.push(r);
            for (var T = 0; s > T; T++) e.push(sS(i[o++]))
        }
        return e.join(" ")
    }

    function mS(t, e, i, n, o, a, r) {
        Ee(aW), e && i && Ne(aW, i);
        var s = n.textRotation;
        if (o && s) {
            var l = n.textOrigin;
            "center" === l ? (a = o.width / 2 + o.x, r = o.height / 2 + o.y) : l && (a = l[0] + o.x, r = l[1] + o.y), aW[4] -= a, aW[5] -= r, Be(aW, aW, s), aW[4] += a, aW[5] += r
        }
        cS(t, aW)
    }

    function vS(t, e, i) {
        return "right" === e ? t - i[1] : "center" === e ? t + i[3] / 2 - i[1] / 2 : t + i[3]
    }

    function yS(t, e, i, n) {
        dS(t, "dominant-baseline", "middle"), dS(t, "text-anchor", rW[e]), dS(t, "x", i), dS(t, "y", n)
    }

    function xS(t) {
        t && t.__textSvgEl && (t.__textSvgEl.parentNode && t.__textSvgEl.parentNode.removeChild(t.__textSvgEl), t.__textSvgEl = null, t.__tspanList = [], t.__text = null)
    }

    function _S() {
    }

    function wS(t, e) {
        for (var i = 0, n = e.length, o = 0, a = 0; n > i; i++) {
            var r = e[i];
            if (r.removed) {
                for (var s = [], l = a; l < a + r.count; l++) s.push(l);
                r.indices = s, a += r.count
            } else {
                for (var s = [], l = o; l < o + r.count; l++) s.push(l);
                r.indices = s, o += r.count, r.added || (a += r.count)
            }
        }
        return e
    }

    function bS(t) {
        return {newPos: t.newPos, components: t.components.slice(0)}
    }

    function SS(t, e, i, n, o) {
        this._zrId = t, this._svgRoot = e, this._tagNames = "string" == typeof i ? [i] : i, this._markLabel = n, this._domName = o || "_dom", this.nextId = 0
    }

    function MS(t, e) {
        SS.call(this, t, e, ["linearGradient", "radialGradient"], "__gradient_in_use__")
    }

    function IS(t, e) {
        SS.call(this, t, e, "clipPath", "__clippath_in_use__")
    }

    function TS(t, e) {
        SS.call(this, t, e, ["filter"], "__filter_in_use__", "_shadowDom")
    }

    function AS(t) {
        return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY || t.textShadowBlur || t.textShadowOffsetX || t.textShadowOffsetY)
    }

    function DS(t) {
        return parseInt(t, 10)
    }

    function CS(t) {
        return t instanceof aa ? tW : t instanceof Cn ? eW : t instanceof vA ? iW : tW
    }

    function LS(t, e) {
        return e && t && e.parentNode !== t
    }

    function kS(t, e, i) {
        if (LS(t, e) && i) {
            var n = i.nextSibling;
            n ? t.insertBefore(e, n) : t.appendChild(e)
        }
    }

    function PS(t, e) {
        if (LS(t, e)) {
            var i = t.firstChild;
            i ? t.insertBefore(e, i) : t.appendChild(e)
        }
    }

    function OS(t, e) {
        e && t && e.parentNode === t && t.removeChild(e)
    }

    function ES(t) {
        return t.__textSvgEl
    }

    function NS(t) {
        return t.__svgEl
    }

    function RS(t) {
        return function () {
            KM('In SVG mode painter not support method "' + t + '"')
        }
    }

    var zS;
    "undefined" != typeof window ? zS = window.__DEV__ : "undefined" != typeof global && (zS = global.__DEV__), "undefined" == typeof zS && (zS = !0);
    var BS = zS, VS = 2311, GS = function () {
        return VS++
    }, FS = {};
    FS = "object" == typeof wx && "function" == typeof wx.getSystemInfoSync ? {
        browser: {},
        os: {},
        node: !1,
        wxa: !0,
        canvasSupported: !0,
        svgSupported: !1,
        touchEventsSupported: !0,
        domSupported: !1
    } : "undefined" == typeof document && "undefined" != typeof self ? {
        browser: {},
        os: {},
        node: !1,
        worker: !0,
        canvasSupported: !0,
        domSupported: !1
    } : "undefined" == typeof navigator ? {
        browser: {},
        os: {},
        node: !0,
        worker: !1,
        canvasSupported: !0,
        svgSupported: !0,
        domSupported: !1
    } : e(navigator.userAgent);
    var WS = FS, HS = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1,
            "[object CanvasPattern]": 1,
            "[object Image]": 1,
            "[object Canvas]": 1
        }, ZS = {
            "[object Int8Array]": 1,
            "[object Uint8Array]": 1,
            "[object Uint8ClampedArray]": 1,
            "[object Int16Array]": 1,
            "[object Uint16Array]": 1,
            "[object Int32Array]": 1,
            "[object Uint32Array]": 1,
            "[object Float32Array]": 1,
            "[object Float64Array]": 1
        }, US = Object.prototype.toString, XS = Array.prototype, YS = XS.forEach, jS = XS.filter, qS = XS.slice,
        KS = XS.map, $S = XS.reduce, JS = {}, QS = function () {
            return JS.createCanvas()
        };
    JS.createCanvas = function () {
        return document.createElement("canvas")
    };
    var tM, eM = "__ec_primitive__";
    z.prototype = {
        constructor: z, get: function (t) {
            return this.data.hasOwnProperty(t) ? this.data[t] : null
        }, set: function (t, e) {
            return this.data[t] = e
        }, each: function (t, e) {
            void 0 !== e && (t = y(t, e));
            for (var i in this.data) this.data.hasOwnProperty(i) && t(this.data[i], i)
        }, removeKey: function (t) {
            delete this.data[t]
        }
    };
    var iM = (Object.freeze || Object)({
            $override: i,
            clone: n,
            merge: o,
            mergeAll: a,
            extend: r,
            defaults: s,
            createCanvas: QS,
            getContext: l,
            indexOf: u,
            inherits: h,
            mixin: c,
            isArrayLike: d,
            each: f,
            map: p,
            reduce: g,
            filter: m,
            find: v,
            bind: y,
            curry: x,
            isArray: _,
            isFunction: w,
            isString: b,
            isObject: S,
            isBuiltInObject: M,
            isTypedArray: I,
            isDom: T,
            eqNaN: A,
            retrieve: D,
            retrieve2: C,
            retrieve3: L,
            slice: k,
            normalizeCssArray: P,
            assert: O,
            trim: E,
            setAsPrimitive: N,
            isPrimitive: R,
            createHashMap: B,
            concatArray: V,
            noop: G
        }), nM = "undefined" == typeof Float32Array ? Array : Float32Array, oM = j, aM = q, rM = ee, sM = ie,
        lM = (Object.freeze || Object)({
            create: F,
            copy: W,
            clone: H,
            set: Z,
            add: U,
            scaleAndAdd: X,
            sub: Y,
            len: j,
            length: oM,
            lenSquare: q,
            lengthSquare: aM,
            mul: K,
            div: $,
            dot: J,
            scale: Q,
            normalize: te,
            distance: ee,
            dist: rM,
            distanceSquare: ie,
            distSquare: sM,
            negate: ne,
            lerp: oe,
            applyTransform: ae,
            min: re,
            max: se
        });
    le.prototype = {
        constructor: le, _dragStart: function (t) {
            for (var e = t.target; e && !e.draggable;) e = e.parent;
            e && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(ue(e, t), "dragstart", t.event))
        }, _drag: function (t) {
            var e = this._draggingTarget;
            if (e) {
                var i = t.offsetX, n = t.offsetY, o = i - this._x, a = n - this._y;
                this._x = i, this._y = n, e.drift(o, a, t), this.dispatchToElement(ue(e, t), "drag", t.event);
                var r = this.findHover(i, n, e).target, s = this._dropTarget;
                this._dropTarget = r, e !== r && (s && r !== s && this.dispatchToElement(ue(s, t), "dragleave", t.event), r && r !== s && this.dispatchToElement(ue(r, t), "dragenter", t.event))
            }
        }, _dragEnd: function (t) {
            var e = this._draggingTarget;
            e && (e.dragging = !1), this.dispatchToElement(ue(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(ue(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null
        }
    };
    var uM = Array.prototype.slice, hM = function (t) {
        this._$handlers = {}, this._$eventProcessor = t
    };
    hM.prototype = {
        constructor: hM, one: function (t, e, i, n) {
            return ce(this, t, e, i, n, !0)
        }, on: function (t, e, i, n) {
            return ce(this, t, e, i, n, !1)
        }, isSilent: function (t) {
            var e = this._$handlers;
            return !e[t] || !e[t].length
        }, off: function (t, e) {
            var i = this._$handlers;
            if (!t) return this._$handlers = {}, this;
            if (e) {
                if (i[t]) {
                    for (var n = [], o = 0, a = i[t].length; a > o; o++) i[t][o].h !== e && n.push(i[t][o]);
                    i[t] = n
                }
                i[t] && 0 === i[t].length && delete i[t]
            } else delete i[t];
            return this
        }, trigger: function (t) {
            var e = this._$handlers[t], i = this._$eventProcessor;
            if (e) {
                var n = arguments, o = n.length;
                o > 3 && (n = uM.call(n, 1));
                for (var a = e.length, r = 0; a > r;) {
                    var s = e[r];
                    if (i && i.filter && null != s.query && !i.filter(t, s.query)) r++; else {
                        switch (o) {
                            case 1:
                                s.h.call(s.ctx);
                                break;
                            case 2:
                                s.h.call(s.ctx, n[1]);
                                break;
                            case 3:
                                s.h.call(s.ctx, n[1], n[2]);
                                break;
                            default:
                                s.h.apply(s.ctx, n)
                        }
                        s.one ? (e.splice(r, 1), a--) : r++
                    }
                }
            }
            return i && i.afterTrigger && i.afterTrigger(t), this
        }, triggerWithContext: function (t) {
            var e = this._$handlers[t], i = this._$eventProcessor;
            if (e) {
                var n = arguments, o = n.length;
                o > 4 && (n = uM.call(n, 1, n.length - 1));
                for (var a = n[n.length - 1], r = e.length, s = 0; r > s;) {
                    var l = e[s];
                    if (i && i.filter && null != l.query && !i.filter(t, l.query)) s++; else {
                        switch (o) {
                            case 1:
                                l.h.call(a);
                                break;
                            case 2:
                                l.h.call(a, n[1]);
                                break;
                            case 3:
                                l.h.call(a, n[1], n[2]);
                                break;
                            default:
                                l.h.apply(a, n)
                        }
                        l.one ? (e.splice(s, 1), r--) : s++
                    }
                }
            }
            return i && i.afterTrigger && i.afterTrigger(t), this
        }
    };
    var cM = Math.log(2), dM = "___zrEVENTSAVED", fM = [],
        pM = "undefined" != typeof window && !!window.addEventListener,
        gM = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, mM = [], vM = pM ? function (t) {
            t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
        } : function (t) {
            t.returnValue = !1, t.cancelBubble = !0
        }, yM = function () {
            this._track = []
        };
    yM.prototype = {
        constructor: yM, recognize: function (t, e, i) {
            return this._doTrack(t, e, i), this._recognize(t)
        }, clear: function () {
            return this._track.length = 0, this
        }, _doTrack: function (t, e, i) {
            var n = t.touches;
            if (n) {
                for (var o = {points: [], touches: [], target: e, event: t}, a = 0, r = n.length; r > a; a++) {
                    var s = n[a], l = xe(i, s, {});
                    o.points.push([l.zrX, l.zrY]), o.touches.push(s)
                }
                this._track.push(o)
            }
        }, _recognize: function (t) {
            for (var e in xM) if (xM.hasOwnProperty(e)) {
                var i = xM[e](this._track, t);
                if (i) return i
            }
        }
    };
    var xM = {
        pinch: function (t, e) {
            var i = t.length;
            if (i) {
                var n = (t[i - 1] || {}).points, o = (t[i - 2] || {}).points || n;
                if (o && o.length > 1 && n && n.length > 1) {
                    var a = Te(n) / Te(o);
                    !isFinite(a) && (a = 1), e.pinchScale = a;
                    var r = Ae(n);
                    return e.pinchX = r[0], e.pinchY = r[1], {type: "pinch", target: t[0].target, event: e}
                }
            }
        }
    }, _M = "silent";
    Le.prototype.dispose = function () {
    };
    var wM = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
        bM = function (t, e, i, n) {
            hM.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new Le, this.proxy = null, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, this._gestureMgr, le.call(this), this.setHandlerProxy(i)
        };
    bM.prototype = {
        constructor: bM, setHandlerProxy: function (t) {
            this.proxy && this.proxy.dispose(), t && (f(wM, function (e) {
                t.on && t.on(e, this[e], this)
            }, this), t.handler = this), this.proxy = t
        }, mousemove: function (t) {
            var e = t.zrX, i = t.zrY, n = Pe(this, e, i), o = this._hovered, a = o.target;
            a && !a.__zr && (o = this.findHover(o.x, o.y), a = o.target);
            var r = this._hovered = n ? {x: e, y: i} : this.findHover(e, i), s = r.target, l = this.proxy;
            l.setCursor && l.setCursor(s ? s.cursor : "default"), a && s !== a && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(r, "mousemove", t), s && s !== a && this.dispatchToElement(r, "mouseover", t)
        }, mouseout: function (t) {
            var e = t.zrEventControl, i = t.zrIsToLocalDOM;
            "only_globalout" !== e && this.dispatchToElement(this._hovered, "mouseout", t), "no_globalout" !== e && !i && this.trigger("globalout", {
                type: "globalout",
                event: t
            })
        }, resize: function () {
            this._hovered = {}
        }, dispatch: function (t, e) {
            var i = this[t];
            i && i.call(this, e)
        }, dispose: function () {
            this.proxy.dispose(), this.storage = this.proxy = this.painter = null
        }, setCursorStyle: function (t) {
            var e = this.proxy;
            e.setCursor && e.setCursor(t)
        }, dispatchToElement: function (t, e, i) {
            t = t || {};
            var n = t.target;
            if (!n || !n.silent) {
                for (var o = "on" + e, a = De(e, t, i); n && (n[o] && (a.cancelBubble = n[o].call(n, a)), n.trigger(e, a), n = n.parent, !a.cancelBubble);) ;
                a.cancelBubble || (this.trigger(e, a), this.painter && this.painter.eachOtherLayer(function (t) {
                    "function" == typeof t[o] && t[o].call(t, a), t.trigger && t.trigger(e, a)
                }))
            }
        }, findHover: function (t, e, i) {
            for (var n = this.storage.getDisplayList(), o = {x: t, y: e}, a = n.length - 1; a >= 0; a--) {
                var r;
                if (n[a] !== i && !n[a].ignore && (r = ke(n[a], t, e)) && (!o.topTarget && (o.topTarget = n[a]), r !== _M)) {
                    o.target = n[a];
                    break
                }
            }
            return o
        }, processGesture: function (t, e) {
            this._gestureMgr || (this._gestureMgr = new yM);
            var i = this._gestureMgr;
            "start" === e && i.clear();
            var n = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
            if ("end" === e && i.clear(), n) {
                var o = n.type;
                t.gestureEvent = o, this.dispatchToElement({target: n.target}, o, n.event)
            }
        }
    }, f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) {
        bM.prototype[t] = function (e) {
            var i, n, o = e.zrX, a = e.zrY, r = Pe(this, o, a);
            if ("mouseup" === t && r || (i = this.findHover(o, a), n = i.target), "mousedown" === t) this._downEl = n, this._downPoint = [e.zrX, e.zrY], this._upEl = n; else if ("mouseup" === t) this._upEl = n; else if ("click" === t) {
                if (this._downEl !== this._upEl || !this._downPoint || rM(this._downPoint, [e.zrX, e.zrY]) > 4) return;
                this._downPoint = null
            }
            this.dispatchToElement(i, t, e)
        }
    }), c(bM, hM), c(bM, le);
    var SM = "undefined" == typeof Float32Array ? Array : Float32Array, MM = (Object.freeze || Object)({
        create: Oe,
        identity: Ee,
        copy: Ne,
        mul: Re,
        translate: ze,
        rotate: Be,
        scale: Ve,
        invert: Ge,
        clone: Fe
    }), IM = Ee, TM = 5e-5, AM = function (t) {
        t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
    }, DM = AM.prototype;
    DM.transform = null, DM.needLocalTransform = function () {
        return We(this.rotation) || We(this.position[0]) || We(this.position[1]) || We(this.scale[0] - 1) || We(this.scale[1] - 1)
    };
    var CM = [];
    DM.updateTransform = function () {
        var t = this.parent, e = t && t.transform, i = this.needLocalTransform(), n = this.transform;
        if (!i && !e) return void (n && IM(n));
        n = n || Oe(), i ? this.getLocalTransform(n) : IM(n), e && (i ? Re(n, t.transform, n) : Ne(n, t.transform)), this.transform = n;
        var o = this.globalScaleRatio;
        if (null != o && 1 !== o) {
            this.getGlobalScale(CM);
            var a = CM[0] < 0 ? -1 : 1, r = CM[1] < 0 ? -1 : 1, s = ((CM[0] - a) * o + a) / CM[0] || 0,
                l = ((CM[1] - r) * o + r) / CM[1] || 0;
            n[0] *= s, n[1] *= s, n[2] *= l, n[3] *= l
        }
        this.invTransform = this.invTransform || Oe(), Ge(this.invTransform, n)
    }, DM.getLocalTransform = function (t) {
        return AM.getLocalTransform(this, t)
    }, DM.setTransform = function (t) {
        var e = this.transform, i = t.dpr || 1;
        e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0)
    }, DM.restoreTransform = function (t) {
        var e = t.dpr || 1;
        t.setTransform(e, 0, 0, e, 0, 0)
    };
    var LM = [], kM = Oe();
    DM.setLocalTransform = function (t) {
        if (t) {
            var e = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], n = this.position, o = this.scale;
            We(e - 1) && (e = Math.sqrt(e)), We(i - 1) && (i = Math.sqrt(i)), t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), n[0] = t[4], n[1] = t[5], o[0] = e, o[1] = i, this.rotation = Math.atan2(-t[1] / i, t[0] / e)
        }
    }, DM.decomposeTransform = function () {
        if (this.transform) {
            var t = this.parent, e = this.transform;
            t && t.transform && (Re(LM, t.invTransform, e), e = LM);
            var i = this.origin;
            i && (i[0] || i[1]) && (kM[4] = i[0], kM[5] = i[1], Re(LM, e, kM), LM[4] -= i[0], LM[5] -= i[1], e = LM), this.setLocalTransform(e)
        }
    }, DM.getGlobalScale = function (t) {
        var e = this.transform;
        return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t)
    }, DM.transformCoordToLocal = function (t, e) {
        var i = [t, e], n = this.invTransform;
        return n && ae(i, i, n), i
    }, DM.transformCoordToGlobal = function (t, e) {
        var i = [t, e], n = this.transform;
        return n && ae(i, i, n), i
    }, AM.getLocalTransform = function (t, e) {
        e = e || [], IM(e);
        var i = t.origin, n = t.scale || [1, 1], o = t.rotation || 0, a = t.position || [0, 0];
        return i && (e[4] -= i[0], e[5] -= i[1]), Ve(e, e, n), o && Be(e, e, o), i && (e[4] += i[0], e[5] += i[1]), e[4] += a[0], e[5] += a[1], e
    };
    var PM = {
        linear: function (t) {
            return t
        }, quadraticIn: function (t) {
            return t * t
        }, quadraticOut: function (t) {
            return t * (2 - t)
        }, quadraticInOut: function (t) {
            return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
        }, cubicIn: function (t) {
            return t * t * t
        }, cubicOut: function (t) {
            return --t * t * t + 1
        }, cubicInOut: function (t) {
            return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
        }, quarticIn: function (t) {
            return t * t * t * t
        }, quarticOut: function (t) {
            return 1 - --t * t * t * t
        }, quarticInOut: function (t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
        }, quinticIn: function (t) {
            return t * t * t * t * t
        }, quinticOut: function (t) {
            return --t * t * t * t * t + 1
        }, quinticInOut: function (t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
        }, sinusoidalIn: function (t) {
            return 1 - Math.cos(t * Math.PI / 2)
        }, sinusoidalOut: function (t) {
            return Math.sin(t * Math.PI / 2)
        }, sinusoidalInOut: function (t) {
            return .5 * (1 - Math.cos(Math.PI * t))
        }, exponentialIn: function (t) {
            return 0 === t ? 0 : Math.pow(1024, t - 1)
        }, exponentialOut: function (t) {
            return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
        }, exponentialInOut: function (t) {
            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
        }, circularIn: function (t) {
            return 1 - Math.sqrt(1 - t * t)
        }, circularOut: function (t) {
            return Math.sqrt(1 - --t * t)
        }, circularInOut: function (t) {
            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
        }, elasticIn: function (t) {
            var e, i = .1, n = .4;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
        }, elasticOut: function (t) {
            var e, i = .1, n = .4;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
        }, elasticInOut: function (t) {
            var e, i = .1, n = .4;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
        }, backIn: function (t) {
            var e = 1.70158;
            return t * t * ((e + 1) * t - e)
        }, backOut: function (t) {
            var e = 1.70158;
            return --t * t * ((e + 1) * t + e) + 1
        }, backInOut: function (t) {
            var e = 2.5949095;
            return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
        }, bounceIn: function (t) {
            return 1 - PM.bounceOut(1 - t)
        }, bounceOut: function (t) {
            return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        }, bounceInOut: function (t) {
            return .5 > t ? .5 * PM.bounceIn(2 * t) : .5 * PM.bounceOut(2 * t - 1) + .5
        }
    };
    He.prototype = {
        constructor: He, step: function (t, e) {
            if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) return void (this._pausedTime += e);
            var i = (t - this._startTime - this._pausedTime) / this._life;
            if (!(0 > i)) {
                i = Math.min(i, 1);
                var n = this.easing, o = "string" == typeof n ? PM[n] : n, a = "function" == typeof o ? o(i) : i;
                return this.fire("frame", a), 1 === i ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null
            }
        }, restart: function (t) {
            var e = (t - this._startTime - this._pausedTime) % this._life;
            this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1
        }, fire: function (t, e) {
            t = "on" + t, this[t] && this[t](this._target, e)
        }, pause: function () {
            this._paused = !0
        }, resume: function () {
            this._paused = !1
        }
    };
    var OM = function () {
        this.head = null, this.tail = null, this._len = 0
    }, EM = OM.prototype;
    EM.insert = function (t) {
        var e = new NM(t);
        return this.insertEntry(e), e
    }, EM.insertEntry = function (t) {
        this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++
    }, EM.remove = function (t) {
        var e = t.prev, i = t.next;
        e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
    }, EM.len = function () {
        return this._len
    }, EM.clear = function () {
        this.head = this.tail = null, this._len = 0
    };
    var NM = function (t) {
        this.value = t, this.next, this.prev
    }, RM = function (t) {
        this._list = new OM, this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null
    }, zM = RM.prototype;
    zM.put = function (t, e) {
        var i = this._list, n = this._map, o = null;
        if (null == n[t]) {
            var a = i.len(), r = this._lastRemovedEntry;
            if (a >= this._maxSize && a > 0) {
                var s = i.head;
                i.remove(s), delete n[s.key], o = s.value, this._lastRemovedEntry = s
            }
            r ? r.value = e : r = new NM(e), r.key = t, i.insertEntry(r), n[t] = r
        }
        return o
    }, zM.get = function (t) {
        var e = this._map[t], i = this._list;
        return null != e ? (e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value) : void 0
    }, zM.clear = function () {
        this._list.clear(), this._map = {}
    };
    var BM = {
        transparent: [0, 0, 0, 0],
        aliceblue: [240, 248, 255, 1],
        antiquewhite: [250, 235, 215, 1],
        aqua: [0, 255, 255, 1],
        aquamarine: [127, 255, 212, 1],
        azure: [240, 255, 255, 1],
        beige: [245, 245, 220, 1],
        bisque: [255, 228, 196, 1],
        black: [0, 0, 0, 1],
        blanchedalmond: [255, 235, 205, 1],
        blue: [0, 0, 255, 1],
        blueviolet: [138, 43, 226, 1],
        brown: [165, 42, 42, 1],
        burlywood: [222, 184, 135, 1],
        cadetblue: [95, 158, 160, 1],
        chartreuse: [127, 255, 0, 1],
        chocolate: [210, 105, 30, 1],
        coral: [255, 127, 80, 1],
        cornflowerblue: [100, 149, 237, 1],
        cornsilk: [255, 248, 220, 1],
        crimson: [220, 20, 60, 1],
        cyan: [0, 255, 255, 1],
        darkblue: [0, 0, 139, 1],
        darkcyan: [0, 139, 139, 1],
        darkgoldenrod: [184, 134, 11, 1],
        darkgray: [169, 169, 169, 1],
        darkgreen: [0, 100, 0, 1],
        darkgrey: [169, 169, 169, 1],
        darkkhaki: [189, 183, 107, 1],
        darkmagenta: [139, 0, 139, 1],
        darkolivegreen: [85, 107, 47, 1],
        darkorange: [255, 140, 0, 1],
        darkorchid: [153, 50, 204, 1],
        darkred: [139, 0, 0, 1],
        darksalmon: [233, 150, 122, 1],
        darkseagreen: [143, 188, 143, 1],
        darkslateblue: [72, 61, 139, 1],
        darkslategray: [47, 79, 79, 1],
        darkslategrey: [47, 79, 79, 1],
        darkturquoise: [0, 206, 209, 1],
        darkviolet: [148, 0, 211, 1],
        deeppink: [255, 20, 147, 1],
        deepskyblue: [0, 191, 255, 1],
        dimgray: [105, 105, 105, 1],
        dimgrey: [105, 105, 105, 1],
        dodgerblue: [30, 144, 255, 1],
        firebrick: [178, 34, 34, 1],
        floralwhite: [255, 250, 240, 1],
        forestgreen: [34, 139, 34, 1],
        fuchsia: [255, 0, 255, 1],
        gainsboro: [220, 220, 220, 1],
        ghostwhite: [248, 248, 255, 1],
        gold: [255, 215, 0, 1],
        goldenrod: [218, 165, 32, 1],
        gray: [128, 128, 128, 1],
        green: [0, 128, 0, 1],
        greenyellow: [173, 255, 47, 1],
        grey: [128, 128, 128, 1],
        honeydew: [240, 255, 240, 1],
        hotpink: [255, 105, 180, 1],
        indianred: [205, 92, 92, 1],
        indigo: [75, 0, 130, 1],
        ivory: [255, 255, 240, 1],
        khaki: [240, 230, 140, 1],
        lavender: [230, 230, 250, 1],
        lavenderblush: [255, 240, 245, 1],
        lawngreen: [124, 252, 0, 1],
        lemonchiffon: [255, 250, 205, 1],
        lightblue: [173, 216, 230, 1],
        lightcoral: [240, 128, 128, 1],
        lightcyan: [224, 255, 255, 1],
        lightgoldenrodyellow: [250, 250, 210, 1],
        lightgray: [211, 211, 211, 1],
        lightgreen: [144, 238, 144, 1],
        lightgrey: [211, 211, 211, 1],
        lightpink: [255, 182, 193, 1],
        lightsalmon: [255, 160, 122, 1],
        lightseagreen: [32, 178, 170, 1],
        lightskyblue: [135, 206, 250, 1],
        lightslategray: [119, 136, 153, 1],
        lightslategrey: [119, 136, 153, 1],
        lightsteelblue: [176, 196, 222, 1],
        lightyellow: [255, 255, 224, 1],
        lime: [0, 255, 0, 1],
        limegreen: [50, 205, 50, 1],
        linen: [250, 240, 230, 1],
        magenta: [255, 0, 255, 1],
        maroon: [128, 0, 0, 1],
        mediumaquamarine: [102, 205, 170, 1],
        mediumblue: [0, 0, 205, 1],
        mediumorchid: [186, 85, 211, 1],
        mediumpurple: [147, 112, 219, 1],
        mediumseagreen: [60, 179, 113, 1],
        mediumslateblue: [123, 104, 238, 1],
        mediumspringgreen: [0, 250, 154, 1],
        mediumturquoise: [72, 209, 204, 1],
        mediumvioletred: [199, 21, 133, 1],
        midnightblue: [25, 25, 112, 1],
        mintcream: [245, 255, 250, 1],
        mistyrose: [255, 228, 225, 1],
        moccasin: [255, 228, 181, 1],
        navajowhite: [255, 222, 173, 1],
        navy: [0, 0, 128, 1],
        oldlace: [253, 245, 230, 1],
        olive: [128, 128, 0, 1],
        olivedrab: [107, 142, 35, 1],
        orange: [255, 165, 0, 1],
        orangered: [255, 69, 0, 1],
        orchid: [218, 112, 214, 1],
        palegoldenrod: [238, 232, 170, 1],
        palegreen: [152, 251, 152, 1],
        paleturquoise: [175, 238, 238, 1],
        palevioletred: [219, 112, 147, 1],
        papayawhip: [255, 239, 213, 1],
        peachpuff: [255, 218, 185, 1],
        peru: [205, 133, 63, 1],
        pink: [255, 192, 203, 1],
        plum: [221, 160, 221, 1],
        powderblue: [176, 224, 230, 1],
        purple: [128, 0, 128, 1],
        red: [255, 0, 0, 1],
        rosybrown: [188, 143, 143, 1],
        royalblue: [65, 105, 225, 1],
        saddlebrown: [139, 69, 19, 1],
        salmon: [250, 128, 114, 1],
        sandybrown: [244, 164, 96, 1],
        seagreen: [46, 139, 87, 1],
        seashell: [255, 245, 238, 1],
        sienna: [160, 82, 45, 1],
        silver: [192, 192, 192, 1],
        skyblue: [135, 206, 235, 1],
        slateblue: [106, 90, 205, 1],
        slategray: [112, 128, 144, 1],
        slategrey: [112, 128, 144, 1],
        snow: [255, 250, 250, 1],
        springgreen: [0, 255, 127, 1],
        steelblue: [70, 130, 180, 1],
        tan: [210, 180, 140, 1],
        teal: [0, 128, 128, 1],
        thistle: [216, 191, 216, 1],
        tomato: [255, 99, 71, 1],
        turquoise: [64, 224, 208, 1],
        violet: [238, 130, 238, 1],
        wheat: [245, 222, 179, 1],
        white: [255, 255, 255, 1],
        whitesmoke: [245, 245, 245, 1],
        yellow: [255, 255, 0, 1],
        yellowgreen: [154, 205, 50, 1]
    }, VM = new RM(20), GM = null, FM = ai, WM = ri, HM = (Object.freeze || Object)({
        parse: ti,
        lift: ni,
        toHex: oi,
        fastLerp: ai,
        fastMapToColor: FM,
        lerp: ri,
        mapToColor: WM,
        modifyHSL: si,
        modifyAlpha: li,
        stringify: ui
    }), ZM = Array.prototype.slice, UM = function (t, e, i, n) {
        this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || hi, this._setter = n || ci, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
    };
    UM.prototype = {
        when: function (t, e) {
            var i = this._tracks;
            for (var n in e) if (e.hasOwnProperty(n)) {
                if (!i[n]) {
                    i[n] = [];
                    var o = this._getter(this._target, n);
                    if (null == o) continue;
                    0 !== t && i[n].push({time: 0, value: xi(o)})
                }
                i[n].push({time: t, value: e[n]})
            }
            return this
        }, during: function (t) {
            return this._onframeList.push(t), this
        }, pause: function () {
            for (var t = 0; t < this._clipList.length; t++) this._clipList[t].pause();
            this._paused = !0
        }, resume: function () {
            for (var t = 0; t < this._clipList.length; t++) this._clipList[t].resume();
            this._paused = !1
        }, isPaused: function () {
            return !!this._paused
        }, _doneCallback: function () {
            this._tracks = {}, this._clipList.length = 0;
            for (var t = this._doneList, e = t.length, i = 0; e > i; i++) t[i].call(this)
        }, start: function (t, e) {
            var i, n = this, o = 0, a = function () {
                o--, o || n._doneCallback()
            };
            for (var r in this._tracks) if (this._tracks.hasOwnProperty(r)) {
                var s = bi(this, t, a, this._tracks[r], r, e);
                s && (this._clipList.push(s), o++, this.animation && this.animation.addClip(s), i = s)
            }
            if (i) {
                var l = i.onframe;
                i.onframe = function (t, e) {
                    l(t, e);
                    for (var i = 0; i < n._onframeList.length; i++) n._onframeList[i](t, e)
                }
            }
            return o || this._doneCallback(), this
        }, stop: function (t) {
            for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) {
                var o = e[n];
                t && o.onframe(this._target, 1), i && i.removeClip(o)
            }
            e.length = 0
        }, delay: function (t) {
            return this._delay = t, this
        }, done: function (t) {
            return t && this._doneList.push(t), this
        }, getClips: function () {
            return this._clipList
        }
    };
    var XM = 1;
    "undefined" != typeof window && (XM = Math.max(window.devicePixelRatio || 1, 1));
    var YM = 0, jM = XM, qM = function () {
    };
    1 === YM && (qM = console.error);
    var KM = qM, $M = function () {
        this.animators = []
    };
    $M.prototype = {
        constructor: $M, animate: function (t, e) {
            var i, n = !1, o = this, a = this.__zr;
            if (t) {
                var r = t.split("."), s = o;
                n = "shape" === r[0];
                for (var l = 0, h = r.length; h > l; l++) s && (s = s[r[l]]);
                s && (i = s)
            } else i = o;
            if (!i) return void KM('Property "' + t + '" is not existed in element ' + o.id);
            var c = o.animators, d = new UM(i, e);
            return d.during(function () {
                o.dirty(n)
            }).done(function () {
                c.splice(u(c, d), 1)
            }), c.push(d), a && a.animation.addAnimator(d), d
        }, stopAnimation: function (t) {
            for (var e = this.animators, i = e.length, n = 0; i > n; n++) e[n].stop(t);
            return e.length = 0, this
        }, animateTo: function (t, e, i, n, o, a) {
            Si(this, t, e, i, n, o, a)
        }, animateFrom: function (t, e, i, n, o, a) {
            Si(this, t, e, i, n, o, a, !0)
        }
    };
    var JM = function (t) {
        AM.call(this, t), hM.call(this, t), $M.call(this, t), this.id = t.id || GS()
    };
    JM.prototype = {
        type: "element", name: "", __zr: null, ignore: !1, clipPath: null, isGroup: !1, drift: function (t, e) {
            switch (this.draggable) {
                case"horizontal":
                    e = 0;
                    break;
                case"vertical":
                    t = 0
            }
            var i = this.transform;
            i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1)
        }, beforeUpdate: function () {
        }, afterUpdate: function () {
        }, update: function () {
            this.updateTransform()
        }, traverse: function () {
        }, attrKV: function (t, e) {
            if ("position" === t || "scale" === t || "origin" === t) {
                if (e) {
                    var i = this[t];
                    i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
                }
            } else this[t] = e
        }, hide: function () {
            this.ignore = !0, this.__zr && this.__zr.refresh()
        }, show: function () {
            this.ignore = !1, this.__zr && this.__zr.refresh()
        }, attr: function (t, e) {
            if ("string" == typeof t) this.attrKV(t, e); else if (S(t)) for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]);
            return this.dirty(!1), this
        }, setClipPath: function (t) {
            var e = this.__zr;
            e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1)
        }, removeClipPath: function () {
            var t = this.clipPath;
            t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1))
        }, addSelfToZr: function (t) {
            this.__zr = t;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.addAnimator(e[i]);
            this.clipPath && this.clipPath.addSelfToZr(t)
        }, removeSelfFromZr: function (t) {
            this.__zr = null;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.removeAnimator(e[i]);
            this.clipPath && this.clipPath.removeSelfFromZr(t)
        }
    }, c(JM, $M), c(JM, AM), c(JM, hM);
    var QM = ae, tI = Math.min, eI = Math.max;
    Ti.prototype = {
        constructor: Ti, union: function (t) {
            var e = tI(t.x, this.x), i = tI(t.y, this.y);
            this.width = eI(t.x + t.width, this.x + this.width) - e, this.height = eI(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i
        }, applyTransform: function () {
            var t = [], e = [], i = [], n = [];
            return function (o) {
                if (o) {
                    t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this.height, QM(t, t, o), QM(e, e, o), QM(i, i, o), QM(n, n, o), this.x = tI(t[0], e[0], i[0], n[0]), this.y = tI(t[1], e[1], i[1], n[1]);
                    var a = eI(t[0], e[0], i[0], n[0]), r = eI(t[1], e[1], i[1], n[1]);
                    this.width = a - this.x, this.height = r - this.y
                }
            }
        }(), calculateTransform: function (t) {
            var e = this, i = t.width / e.width, n = t.height / e.height, o = Oe();
            return ze(o, o, [-e.x, -e.y]), Ve(o, o, [i, n]), ze(o, o, [t.x, t.y]), o
        }, intersect: function (t) {
            if (!t) return !1;
            t instanceof Ti || (t = Ti.create(t));
            var e = this, i = e.x, n = e.x + e.width, o = e.y, a = e.y + e.height, r = t.x, s = t.x + t.width, l = t.y,
                u = t.y + t.height;
            return !(r > n || i > s || l > a || o > u)
        }, contain: function (t, e) {
            var i = this;
            return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height
        }, clone: function () {
            return new Ti(this.x, this.y, this.width, this.height)
        }, copy: function (t) {
            this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height
        }, plain: function () {
            return {x: this.x, y: this.y, width: this.width, height: this.height}
        }
    }, Ti.create = function (t) {
        return new Ti(t.x, t.y, t.width, t.height)
    };
    var iI = function (t) {
        t = t || {}, JM.call(this, t);
        for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
        this._children = [], this.__storage = null, this.__dirty = !0
    };
    iI.prototype = {
        constructor: iI, isGroup: !0, type: "group", silent: !1, children: function () {
            return this._children.slice()
        }, childAt: function (t) {
            return this._children[t]
        }, childOfName: function (t) {
            for (var e = this._children, i = 0; i < e.length; i++) if (e[i].name === t) return e[i]
        }, childCount: function () {
            return this._children.length
        }, add: function (t) {
            return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this
        }, addBefore: function (t, e) {
            if (t && t !== this && t.parent !== this && e && e.parent === this) {
                var i = this._children, n = i.indexOf(e);
                n >= 0 && (i.splice(n, 0, t), this._doAdd(t))
            }
            return this
        }, _doAdd: function (t) {
            t.parent && t.parent.remove(t), t.parent = this;
            var e = this.__storage, i = this.__zr;
            e && e !== t.__storage && (e.addToStorage(t), t instanceof iI && t.addChildrenToStorage(e)), i && i.refresh()
        }, remove: function (t) {
            var e = this.__zr, i = this.__storage, n = this._children, o = u(n, t);
            return 0 > o ? this : (n.splice(o, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof iI && t.delChildrenFromStorage(i)), e && e.refresh(), this)
        }, removeAll: function () {
            var t, e, i = this._children, n = this.__storage;
            for (e = 0; e < i.length; e++) t = i[e], n && (n.delFromStorage(t), t instanceof iI && t.delChildrenFromStorage(n)), t.parent = null;
            return i.length = 0, this
        }, eachChild: function (t, e) {
            for (var i = this._children, n = 0; n < i.length; n++) {
                var o = i[n];
                t.call(e, o, n)
            }
            return this
        }, traverse: function (t, e) {
            for (var i = 0; i < this._children.length; i++) {
                var n = this._children[i];
                t.call(e, n), "group" === n.type && n.traverse(t, e)
            }
            return this
        }, addChildrenToStorage: function (t) {
            for (var e = 0; e < this._children.length; e++) {
                var i = this._children[e];
                t.addToStorage(i), i instanceof iI && i.addChildrenToStorage(t)
            }
        }, delChildrenFromStorage: function (t) {
            for (var e = 0; e < this._children.length; e++) {
                var i = this._children[e];
                t.delFromStorage(i), i instanceof iI && i.delChildrenFromStorage(t)
            }
        }, dirty: function () {
            return this.__dirty = !0, this.__zr && this.__zr.refresh(), this
        }, getBoundingRect: function (t) {
            for (var e = null, i = new Ti(0, 0, 0, 0), n = t || this._children, o = [], a = 0; a < n.length; a++) {
                var r = n[a];
                if (!r.ignore && !r.invisible) {
                    var s = r.getBoundingRect(), l = r.getLocalTransform(o);
                    l ? (i.copy(s), i.applyTransform(l), e = e || i.clone(), e.union(i)) : (e = e || s.clone(), e.union(s))
                }
            }
            return e || i
        }
    }, h(iI, JM);
    var nI = 32, oI = 7, aI = function () {
        this._roots = [], this._displayList = [], this._displayListLen = 0
    };
    aI.prototype = {
        constructor: aI, traverse: function (t, e) {
            for (var i = 0; i < this._roots.length; i++) this._roots[i].traverse(t, e)
        }, getDisplayList: function (t, e) {
            return e = e || !1, t && this.updateDisplayList(e), this._displayList
        }, updateDisplayList: function (t) {
            this._displayListLen = 0;
            for (var e = this._roots, i = this._displayList, n = 0, o = e.length; o > n; n++) this._updateAndAddDisplayable(e[n], null, t);
            i.length = this._displayListLen, WS.canvasSupported && Ei(i, Ni)
        }, _updateAndAddDisplayable: function (t, e, i) {
            if (!t.ignore || i) {
                t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate();
                var n = t.clipPath;
                if (n) {
                    e = e ? e.slice() : [];
                    for (var o = n, a = t; o;) o.parent = a, o.updateTransform(), e.push(o), a = o, o = o.clipPath
                }
                if (t.isGroup) {
                    for (var r = t._children, s = 0; s < r.length; s++) {
                        var l = r[s];
                        t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i)
                    }
                    t.__dirty = !1
                } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
            }
        }, addRoot: function (t) {
            t.__storage !== this && (t instanceof iI && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t))
        }, delRoot: function (t) {
            if (null == t) {
                for (var e = 0; e < this._roots.length; e++) {
                    var i = this._roots[e];
                    i instanceof iI && i.delChildrenFromStorage(this)
                }
                return this._roots = [], this._displayList = [], void (this._displayListLen = 0)
            }
            if (t instanceof Array) for (var e = 0, n = t.length; n > e; e++) this.delRoot(t[e]); else {
                var o = u(this._roots, t);
                o >= 0 && (this.delFromStorage(t), this._roots.splice(o, 1), t instanceof iI && t.delChildrenFromStorage(this))
            }
        }, addToStorage: function (t) {
            return t && (t.__storage = this, t.dirty(!1)), this
        }, delFromStorage: function (t) {
            return t && (t.__storage = null), this
        }, dispose: function () {
            this._renderList = this._roots = null
        }, displayableSortFunc: Ni
    };
    var rI = {
            shadowBlur: 1,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            textShadowBlur: 1,
            textShadowOffsetX: 1,
            textShadowOffsetY: 1,
            textBoxShadowBlur: 1,
            textBoxShadowOffsetX: 1,
            textBoxShadowOffsetY: 1
        }, sI = function (t, e, i) {
            return rI.hasOwnProperty(e) ? i *= t.dpr : i
        }, lI = {NONE: 0, STYLE_BIND: 1, PLAIN_TEXT: 2}, uI = 9,
        hI = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]],
        cI = function (t) {
            this.extendFrom(t, !1)
        };
    cI.prototype = {
        constructor: cI,
        fill: "#000",
        stroke: null,
        opacity: 1,
        fillOpacity: null,
        strokeOpacity: null,
        lineDash: null,
        lineDashOffset: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        lineWidth: 1,
        strokeNoScale: !1,
        text: null,
        font: null,
        textFont: null,
        fontStyle: null,
        fontWeight: null,
        fontSize: null,
        fontFamily: null,
        textTag: null,
        textFill: "#000",
        textStroke: null,
        textWidth: null,
        textHeight: null,
        textStrokeWidth: 0,
        textLineHeight: null,
        textPosition: "inside",
        textRect: null,
        textOffset: null,
        textAlign: null,
        textVerticalAlign: null,
        textDistance: 5,
        textShadowColor: "transparent",
        textShadowBlur: 0,
        textShadowOffsetX: 0,
        textShadowOffsetY: 0,
        textBoxShadowColor: "transparent",
        textBoxShadowBlur: 0,
        textBoxShadowOffsetX: 0,
        textBoxShadowOffsetY: 0,
        transformText: !1,
        textRotation: 0,
        textOrigin: null,
        textBackgroundColor: null,
        textBorderColor: null,
        textBorderWidth: 0,
        textBorderRadius: 0,
        textPadding: null,
        rich: null,
        truncate: null,
        blend: null,
        bind: function (t, e, i) {
            var n = this, o = i && i.style, a = !o || t.__attrCachedBy !== lI.STYLE_BIND;
            t.__attrCachedBy = lI.STYLE_BIND;
            for (var r = 0; r < hI.length; r++) {
                var s = hI[r], l = s[0];
                (a || n[l] !== o[l]) && (t[l] = sI(t, l, n[l] || s[1]))
            }
            if ((a || n.fill !== o.fill) && (t.fillStyle = n.fill), (a || n.stroke !== o.stroke) && (t.strokeStyle = n.stroke), (a || n.opacity !== o.opacity) && (t.globalAlpha = null == n.opacity ? 1 : n.opacity), (a || n.blend !== o.blend) && (t.globalCompositeOperation = n.blend || "source-over"), this.hasStroke()) {
                var u = n.lineWidth;
                t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
            }
        },
        hasFill: function () {
            var t = this.fill;
            return null != t && "none" !== t
        },
        hasStroke: function () {
            var t = this.stroke;
            return null != t && "none" !== t && this.lineWidth > 0
        },
        extendFrom: function (t, e) {
            if (t) for (var i in t) !t.hasOwnProperty(i) || e !== !0 && (e === !1 ? this.hasOwnProperty(i) : null == t[i]) || (this[i] = t[i])
        },
        set: function (t, e) {
            "string" == typeof t ? this[t] = e : this.extendFrom(t, !0)
        },
        clone: function () {
            var t = new this.constructor;
            return t.extendFrom(this, !0), t
        },
        getGradient: function (t, e, i) {
            for (var n = "radial" === e.type ? zi : Ri, o = n(t, e, i), a = e.colorStops, r = 0; r < a.length; r++) o.addColorStop(a[r].offset, a[r].color);
            return o
        }
    };
    for (var dI = cI.prototype, fI = 0; fI < hI.length; fI++) {
        var pI = hI[fI];
        pI[0] in dI || (dI[pI[0]] = pI[1])
    }
    cI.getGradient = dI.getGradient;
    var gI = function (t, e) {
        this.image = t, this.repeat = e, this.type = "pattern"
    };
    gI.prototype.getCanvasPattern = function (t) {
        return t.createPattern(this.image, this.repeat || "repeat")
    };
    var mI = function (t, e, i) {
        var n;
        i = i || jM, "string" == typeof t ? n = Vi(t, e, i) : S(t) && (n = t, t = n.id), this.id = t, this.dom = n;
        var o = n.style;
        o && (n.onselectstart = Bi, o["-webkit-user-select"] = "none", o["user-select"] = "none", o["-webkit-touch-callout"] = "none", o["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", o.padding = 0, o.margin = 0, o["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = i
    };
    mI.prototype = {
        constructor: mI,
        __dirty: !0,
        __used: !1,
        __drawIndex: 0,
        __startIndex: 0,
        __endIndex: 0,
        incremental: !1,
        getElementCount: function () {
            return this.__endIndex - this.__startIndex
        },
        initContext: function () {
            this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr
        },
        createBackBuffer: function () {
            var t = this.dpr;
            this.domBack = Vi("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 !== t && this.ctxBack.scale(t, t)
        },
        resize: function (t, e) {
            var i = this.dpr, n = this.dom, o = n.style, a = this.domBack;
            o && (o.width = t + "px", o.height = e + "px"), n.width = t * i, n.height = e * i, a && (a.width = t * i, a.height = e * i, 1 !== i && this.ctxBack.scale(i, i))
        },
        clear: function (t, e) {
            var i = this.dom, n = this.ctx, o = i.width, a = i.height, e = e || this.clearColor,
                r = this.motionBlur && !t, s = this.lastFrameAlpha, l = this.dpr;
            if (r && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(i, 0, 0, o / l, a / l)), n.clearRect(0, 0, o, a), e && "transparent" !== e) {
                var u;
                e.colorStops ? (u = e.__canvasGradient || cI.getGradient(n, e, {
                    x: 0,
                    y: 0,
                    width: o,
                    height: a
                }), e.__canvasGradient = u) : e.image && (u = gI.prototype.getCanvasPattern.call(e, n)), n.save(), n.fillStyle = u || e, n.fillRect(0, 0, o, a), n.restore()
            }
            if (r) {
                var h = this.domBack;
                n.save(), n.globalAlpha = s, n.drawImage(h, 0, 0, o, a), n.restore()
            }
        }
    };
    var vI = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
            setTimeout(t, 16)
        }, yI = new RM(50), xI = {}, _I = 0, wI = 5e3, bI = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g, SI = "12px sans-serif",
        MI = {};
    MI.measureText = function (t, e) {
        var i = l();
        return i.font = e || SI, i.measureText(t)
    };
    var II = SI, TI = {left: 1, right: 1, center: 1}, AI = {top: 1, bottom: 1, middle: 1},
        DI = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]],
        CI = {}, LI = {}, kI = new Ti, PI = function () {
        };
    PI.prototype = {
        constructor: PI, drawRectText: function (t, e) {
            var i = this.style;
            e = i.textRect || e, this.__dirty && hn(i, !0);
            var n = i.text;
            if (null != n && (n += ""), An(n, i)) {
                t.save();
                var o = this.transform;
                i.transformText ? this.setTransform(t) : o && (kI.copy(e), kI.applyTransform(o), e = kI), dn(this, t, n, i, e, uI), t.restore()
            }
        }
    }, Dn.prototype = {
        constructor: Dn,
        type: "displayable",
        __dirty: !0,
        invisible: !1,
        z: 0,
        z2: 0,
        zlevel: 0,
        draggable: !1,
        dragging: !1,
        silent: !1,
        culling: !1,
        cursor: "pointer",
        rectHover: !1,
        progressive: !1,
        incremental: !1,
        globalScaleRatio: 1,
        beforeBrush: function () {
        },
        afterBrush: function () {
        },
        brush: function () {
        },
        getBoundingRect: function () {
        },
        contain: function (t, e) {
            return this.rectContain(t, e)
        },
        traverse: function (t, e) {
            t.call(e, this)
        },
        rectContain: function (t, e) {
            var i = this.transformCoordToLocal(t, e), n = this.getBoundingRect();
            return n.contain(i[0], i[1])
        },
        dirty: function () {
            this.__dirty = this.__dirtyText = !0, this._rect = null, this.__zr && this.__zr.refresh()
        },
        animateStyle: function (t) {
            return this.animate("style", t)
        },
        attrKV: function (t, e) {
            "style" !== t ? JM.prototype.attrKV.call(this, t, e) : this.style.set(e)
        },
        setStyle: function (t, e) {
            return this.style.set(t, e), this.dirty(!1), this
        },
        useStyle: function (t) {
            return this.style = new cI(t, this), this.dirty(!1), this
        },
        calculateTextPosition: null
    }, h(Dn, JM), c(Dn, PI), Cn.prototype = {
        constructor: Cn, type: "image", brush: function (t, e) {
            var i = this.style, n = i.image;
            i.bind(t, this, e);
            var o = this._image = Fi(n, this._image, this, this.onload);
            if (o && Hi(o)) {
                var a = i.x || 0, r = i.y || 0, s = i.width, l = i.height, u = o.width / o.height;
                if (null == s && null != l ? s = l * u : null == l && null != s ? l = s / u : null == s && null == l && (s = o.width, l = o.height), this.setTransform(t), i.sWidth && i.sHeight) {
                    var h = i.sx || 0, c = i.sy || 0;
                    t.drawImage(o, h, c, i.sWidth, i.sHeight, a, r, s, l)
                } else if (i.sx && i.sy) {
                    var h = i.sx, c = i.sy, d = s - h, f = l - c;
                    t.drawImage(o, h, c, d, f, a, r, s, l)
                } else t.drawImage(o, a, r, s, l);
                null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect()))
            }
        }, getBoundingRect: function () {
            var t = this.style;
            return this._rect || (this._rect = new Ti(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect
        }
    }, h(Cn, Dn);
    var OI = 1e5, EI = 314159, NI = .01, RI = .001, zI = new Ti(0, 0, 0, 0), BI = new Ti(0, 0, 0, 0),
        VI = function (t, e, i) {
            this.type = "canvas";
            var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
            this._opts = i = r({}, i || {}), this.dpr = i.devicePixelRatio || jM, this._singleCanvas = n, this.root = t;
            var o = t.style;
            o && (o["-webkit-tap-highlight-color"] = "transparent", o["-webkit-user-select"] = o["user-select"] = o["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e;
            var a = this._zlevelList = [], s = this._layers = {};
            if (this._layerConfig = {}, this._needsManuallyCompositing = !1, n) {
                var l = t.width, u = t.height;
                null != i.width && (l = i.width), null != i.height && (u = i.height), this.dpr = i.devicePixelRatio || 1, t.width = l * this.dpr, t.height = u * this.dpr, this._width = l, this._height = u;
                var h = new mI(t, this, this.dpr);
                h.__builtin__ = !0, h.initContext(), s[EI] = h, h.zlevel = EI, a.push(EI), this._domRoot = t
            } else {
                this._width = this._getSize(0), this._height = this._getSize(1);
                var c = this._domRoot = Nn(this._width, this._height);
                t.appendChild(c)
            }
            this._hoverlayer = null, this._hoverElements = []
        };
    VI.prototype = {
        constructor: VI, getType: function () {
            return "canvas"
        }, isSingleCanvas: function () {
            return this._singleCanvas
        }, getViewportRoot: function () {
            return this._domRoot
        }, getViewportRootOffset: function () {
            var t = this.getViewportRoot();
            return t ? {offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0} : void 0
        }, refresh: function (t) {
            var e = this.storage.getDisplayList(!0), i = this._zlevelList;
            this._redrawId = Math.random(), this._paintList(e, t, this._redrawId);
            for (var n = 0; n < i.length; n++) {
                var o = i[n], a = this._layers[o];
                if (!a.__builtin__ && a.refresh) {
                    var r = 0 === n ? this._backgroundColor : null;
                    a.refresh(r)
                }
            }
            return this.refreshHover(), this
        }, addHover: function (t, e) {
            if (!t.__hoverMir) {
                var i = new t.constructor({style: t.style, shape: t.shape, z: t.z, z2: t.z2, silent: t.silent});
                return i.__from = t, t.__hoverMir = i, e && i.setStyle(e), this._hoverElements.push(i), i
            }
        }, removeHover: function (t) {
            var e = t.__hoverMir, i = this._hoverElements, n = u(i, e);
            n >= 0 && i.splice(n, 1), t.__hoverMir = null
        }, clearHover: function () {
            for (var t = this._hoverElements, e = 0; e < t.length; e++) {
                var i = t[e].__from;
                i && (i.__hoverMir = null)
            }
            t.length = 0
        }, refreshHover: function () {
            var t = this._hoverElements, e = t.length, i = this._hoverlayer;
            if (i && i.clear(), e) {
                Ei(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(OI));
                var n = {};
                i.ctx.save();
                for (var o = 0; e > o;) {
                    var a = t[o], r = a.__from;
                    r && r.__zr ? (o++, r.invisible || (a.transform = r.transform, a.invTransform = r.invTransform, a.__clipPaths = r.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t.splice(o, 1), r.__hoverMir = null, e--)
                }
                i.ctx.restore()
            }
        }, getHoverLayer: function () {
            return this.getLayer(OI)
        }, _paintList: function (t, e, i) {
            if (this._redrawId === i) {
                e = e || !1, this._updateLayerStatus(t);
                var n = this._doPaintList(t, e);
                if (this._needsManuallyCompositing && this._compositeManually(), !n) {
                    var o = this;
                    vI(function () {
                        o._paintList(t, e, i)
                    })
                }
            }
        }, _compositeManually: function () {
            var t = this.getLayer(EI).ctx, e = this._domRoot.width, i = this._domRoot.height;
            t.clearRect(0, 0, e, i), this.eachBuiltinLayer(function (n) {
                n.virtual && t.drawImage(n.dom, 0, 0, e, i)
            })
        }, _doPaintList: function (t, e) {
            for (var i = [], n = 0; n < this._zlevelList.length; n++) {
                var o = this._zlevelList[n], a = this._layers[o];
                a.__builtin__ && a !== this._hoverlayer && (a.__dirty || e) && i.push(a)
            }
            for (var r = !0, s = 0; s < i.length; s++) {
                var a = i[s], l = a.ctx, u = {};
                l.save();
                var h = e ? a.__startIndex : a.__drawIndex, c = !e && a.incremental && Date.now, d = c && Date.now(),
                    p = a.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
                if (a.__startIndex === a.__endIndex) a.clear(!1, p); else if (h === a.__startIndex) {
                    var g = t[h];
                    g.incremental && g.notClear && !e || a.clear(!1, p)
                }
                -1 === h && (console.error("For some unknown reason. drawIndex is -1"), h = a.__startIndex);
                for (var m = h; m < a.__endIndex; m++) {
                    var v = t[m];
                    if (this._doPaintEl(v, a, e, u), v.__dirty = v.__dirtyText = !1, c) {
                        var y = Date.now() - d;
                        if (y > 15) break
                    }
                }
                a.__drawIndex = m, a.__drawIndex < a.__endIndex && (r = !1), u.prevElClipPaths && l.restore(), l.restore()
            }
            return WS.wxa && f(this._layers, function (t) {
                t && t.ctx && t.ctx.draw && t.ctx.draw()
            }), r
        }, _doPaintEl: function (t, e, i, n) {
            var o = e.ctx, a = t.transform;
            if (!(!e.__dirty && !i || t.invisible || 0 === t.style.opacity || a && !a[0] && !a[3] || t.culling && Pn(t, this._width, this._height))) {
                var r = t.__clipPaths, s = n.prevElClipPaths;
                (!s || On(r, s)) && (s && (o.restore(), n.prevElClipPaths = null, n.prevEl = null), r && (o.save(), En(r, o), n.prevElClipPaths = r)), t.beforeBrush && t.beforeBrush(o), t.brush(o, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(o)
            }
        }, getLayer: function (t, e) {
            this._singleCanvas && !this._needsManuallyCompositing && (t = EI);
            var i = this._layers[t];
            return i || (i = new mI("zr_" + t, this, this.dpr), i.zlevel = t, i.__builtin__ = !0, this._layerConfig[t] ? o(i, this._layerConfig[t], !0) : this._layerConfig[t - NI] && o(i, this._layerConfig[t - NI], !0), e && (i.virtual = e), this.insertLayer(t, i), i.initContext()), i
        }, insertLayer: function (t, e) {
            var i = this._layers, n = this._zlevelList, o = n.length, a = null, r = -1, s = this._domRoot;
            if (i[t]) return void KM("ZLevel " + t + " has been used already");
            if (!kn(e)) return void KM("Layer of zlevel " + t + " is not valid");
            if (o > 0 && t > n[0]) {
                for (r = 0; o - 1 > r && !(n[r] < t && n[r + 1] > t); r++) ;
                a = i[n[r]]
            }
            if (n.splice(r + 1, 0, t), i[t] = e, !e.virtual) if (a) {
                var l = a.dom;
                l.nextSibling ? s.insertBefore(e.dom, l.nextSibling) : s.appendChild(e.dom)
            } else s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom)
        }, eachLayer: function (t, e) {
            var i, n, o = this._zlevelList;
            for (n = 0; n < o.length; n++) i = o[n], t.call(e, this._layers[i], i)
        }, eachBuiltinLayer: function (t, e) {
            var i, n, o, a = this._zlevelList;
            for (o = 0; o < a.length; o++) n = a[o], i = this._layers[n], i.__builtin__ && t.call(e, i, n)
        }, eachOtherLayer: function (t, e) {
            var i, n, o, a = this._zlevelList;
            for (o = 0; o < a.length; o++) n = a[o], i = this._layers[n], i.__builtin__ || t.call(e, i, n)
        }, getLayers: function () {
            return this._layers
        }, _updateLayerStatus: function (t) {
            function e(t) {
                a && (a.__endIndex !== t && (a.__dirty = !0), a.__endIndex = t)
            }

            if (this.eachBuiltinLayer(function (t) {
                t.__dirty = t.__used = !1
            }), this._singleCanvas) for (var i = 1; i < t.length; i++) {
                var n = t[i];
                if (n.zlevel !== t[i - 1].zlevel || n.incremental) {
                    this._needsManuallyCompositing = !0;
                    break
                }
            }
            for (var o, a = null, r = 0, i = 0; i < t.length; i++) {
                var s, n = t[i], l = n.zlevel;
                o !== l && (o = l, r = 0), n.incremental ? (s = this.getLayer(l + RI, this._needsManuallyCompositing), s.incremental = !0, r = 1) : s = this.getLayer(l + (r > 0 ? NI : 0), this._needsManuallyCompositing), s.__builtin__ || KM("ZLevel " + l + " has been used by unkown layer " + s.id), s !== a && (s.__used = !0, s.__startIndex !== i && (s.__dirty = !0), s.__startIndex = i, s.__drawIndex = s.incremental ? -1 : i, e(i), a = s), n.__dirty && (s.__dirty = !0, s.incremental && s.__drawIndex < 0 && (s.__drawIndex = i))
            }
            e(i), this.eachBuiltinLayer(function (t) {
                !t.__used && t.getElementCount() > 0 && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex)
            })
        }, clear: function () {
            return this.eachBuiltinLayer(this._clearLayer), this
        }, _clearLayer: function (t) {
            t.clear()
        }, setBackgroundColor: function (t) {
            this._backgroundColor = t
        }, configLayer: function (t, e) {
            if (e) {
                var i = this._layerConfig;
                i[t] ? o(i[t], e, !0) : i[t] = e;
                for (var n = 0; n < this._zlevelList.length; n++) {
                    var a = this._zlevelList[n];
                    if (a === t || a === t + NI) {
                        var r = this._layers[a];
                        o(r, i[t], !0)
                    }
                }
            }
        }, delLayer: function (t) {
            var e = this._layers, i = this._zlevelList, n = e[t];
            n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(u(i, t), 1))
        }, resize: function (t, e) {
            if (this._domRoot.style) {
                var i = this._domRoot;
                i.style.display = "none";
                var n = this._opts;
                if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width !== t || e !== this._height) {
                    i.style.width = t + "px", i.style.height = e + "px";
                    for (var o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e);
                    f(this._progressiveLayers, function (i) {
                        i.resize(t, e)
                    }), this.refresh(!0)
                }
                this._width = t, this._height = e
            } else {
                if (null == t || null == e) return;
                this._width = t, this._height = e, this.getLayer(EI).resize(t, e)
            }
            return this
        }, clearLayer: function (t) {
            var e = this._layers[t];
            e && e.clear()
        }, dispose: function () {
            this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
        }, getRenderedCanvas: function (t) {
            if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[EI].dom;
            var e = new mI("image", this, t.pixelRatio || this.dpr);
            if (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), t.pixelRatio <= this.dpr) {
                this.refresh();
                var i = e.dom.width, n = e.dom.height, o = e.ctx;
                this.eachLayer(function (t) {
                    t.__builtin__ ? o.drawImage(t.dom, 0, 0, i, n) : t.renderToCanvas && (e.ctx.save(), t.renderToCanvas(e.ctx), e.ctx.restore())
                })
            } else for (var a = {}, r = this.storage.getDisplayList(!0), s = 0; s < r.length; s++) {
                var l = r[s];
                this._doPaintEl(l, e, !0, a)
            }
            return e.dom
        }, getWidth: function () {
            return this._width
        }, getHeight: function () {
            return this._height
        }, _getSize: function (t) {
            var e = this._opts, i = ["width", "height"][t], n = ["clientWidth", "clientHeight"][t],
                o = ["paddingLeft", "paddingTop"][t], a = ["paddingRight", "paddingBottom"][t];
            if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);
            var r = this.root, s = document.defaultView.getComputedStyle(r);
            return (r[n] || Ln(s[i]) || Ln(r.style[i])) - (Ln(s[o]) || 0) - (Ln(s[a]) || 0) | 0
        }, pathToImage: function (t, e) {
            e = e || this.dpr;
            var i = document.createElement("canvas"), n = i.getContext("2d"), o = t.getBoundingRect(), a = t.style,
                r = a.shadowBlur * e, s = a.shadowOffsetX * e, l = a.shadowOffsetY * e,
                u = a.hasStroke() ? a.lineWidth : 0, h = Math.max(u / 2, -s + r), c = Math.max(u / 2, s + r),
                d = Math.max(u / 2, -l + r), f = Math.max(u / 2, l + r), p = o.width + h + c, g = o.height + d + f;
            i.width = p * e, i.height = g * e, n.scale(e, e), n.clearRect(0, 0, p, g), n.dpr = e;
            var m = {position: t.position, rotation: t.rotation, scale: t.scale};
            t.position = [h - o.x, d - o.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(n);
            var v = Cn, y = new v({style: {x: 0, y: 0, image: i}});
            return null != m.position && (y.position = t.position = m.position), null != m.rotation && (y.rotation = t.rotation = m.rotation), null != m.scale && (y.scale = t.scale = m.scale), y
        }
    };
    var GI = function (t) {
        t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {
        }, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, hM.call(this)
    };
    GI.prototype = {
        constructor: GI, addClip: function (t) {
            this._clips.push(t)
        }, addAnimator: function (t) {
            t.animation = this;
            for (var e = t.getClips(), i = 0; i < e.length; i++) this.addClip(e[i])
        }, removeClip: function (t) {
            var e = u(this._clips, t);
            e >= 0 && this._clips.splice(e, 1)
        }, removeAnimator: function (t) {
            for (var e = t.getClips(), i = 0; i < e.length; i++) this.removeClip(e[i]);
            t.animation = null
        }, _update: function () {
            for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, o = [], a = [], r = 0; n > r; r++) {
                var s = i[r], l = s.step(t, e);
                l && (o.push(l), a.push(s))
            }
            for (var r = 0; n > r;) i[r]._needsRemove ? (i[r] = i[n - 1], i.pop(), n--) : r++;
            n = o.length;
            for (var r = 0; n > r; r++) a[r].fire(o[r]);
            this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update()
        }, _startLoop: function () {
            function t() {
                e._running && (vI(t), !e._paused && e._update())
            }

            var e = this;
            this._running = !0, vI(t)
        }, start: function () {
            this._time = (new Date).getTime(), this._pausedTime = 0, this._startLoop()
        }, stop: function () {
            this._running = !1
        }, pause: function () {
            this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0)
        }, resume: function () {
            this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1)
        }, clear: function () {
            this._clips = []
        }, isFinished: function () {
            return !this._clips.length
        }, animate: function (t, e) {
            e = e || {};
            var i = new UM(t, e.loop, e.getter, e.setter);
            return this.addAnimator(i), i
        }
    }, c(GI, hM);
    var FI = 300, WI = WS.domSupported, HI = function () {
        var t = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
            e = ["touchstart", "touchend", "touchmove"],
            i = {pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1}, n = p(t, function (t) {
                var e = t.replace("mouse", "pointer");
                return i.hasOwnProperty(e) ? e : t
            });
        return {mouse: t, touch: e, pointer: n}
    }(), ZI = {mouse: ["mousemove", "mouseup"], pointer: ["pointermove", "pointerup"]}, UI = Wn.prototype;
    UI.stopPropagation = UI.stopImmediatePropagation = UI.preventDefault = G;
    var XI = {
        mousedown: function (t) {
            t = be(this.dom, t), this._mayPointerCapture = [t.zrX, t.zrY], this.trigger("mousedown", t)
        }, mousemove: function (t) {
            t = be(this.dom, t);
            var e = this._mayPointerCapture;
            !e || t.zrX === e[0] && t.zrY === e[1] || Yn(this, !0), this.trigger("mousemove", t)
        }, mouseup: function (t) {
            t = be(this.dom, t), Yn(this, !1), this.trigger("mouseup", t)
        }, mouseout: function (t) {
            t = be(this.dom, t), this._pointerCapturing && (t.zrEventControl = "no_globalout");
            var e = t.toElement || t.relatedTarget;
            t.zrIsToLocalDOM = Fn(this, e), this.trigger("mouseout", t)
        }, touchstart: function (t) {
            t = be(this.dom, t), Vn(t), this._lastTouchMoment = new Date, this.handler.processGesture(t, "start"), XI.mousemove.call(this, t), XI.mousedown.call(this, t)
        }, touchmove: function (t) {
            t = be(this.dom, t), Vn(t), this.handler.processGesture(t, "change"), XI.mousemove.call(this, t)
        }, touchend: function (t) {
            t = be(this.dom, t), Vn(t), this.handler.processGesture(t, "end"), XI.mouseup.call(this, t), +new Date - this._lastTouchMoment < FI && XI.click.call(this, t)
        }, pointerdown: function (t) {
            XI.mousedown.call(this, t)
        }, pointermove: function (t) {
            zn(t) || XI.mousemove.call(this, t)
        }, pointerup: function (t) {
            XI.mouseup.call(this, t)
        }, pointerout: function (t) {
            zn(t) || XI.mouseout.call(this, t)
        }
    };
    f(["click", "mousewheel", "dblclick", "contextmenu"], function (t) {
        XI[t] = function (e) {
            e = be(this.dom, e), this.trigger(t, e)
        }
    });
    var YI = {
        pointermove: function (t) {
            zn(t) || YI.mousemove.call(this, t)
        }, pointerup: function (t) {
            YI.mouseup.call(this, t)
        }, mousemove: function (t) {
            this.trigger("mousemove", t)
        }, mouseup: function (t) {
            var e = this._pointerCapturing;
            Yn(this, !1), this.trigger("mouseup", t), e && (t.zrEventControl = "only_globalout", this.trigger("mouseout", t))
        }
    }, jI = qn.prototype;
    jI.dispose = function () {
        Xn(this._localHandlerScope), WI && Xn(this._globalHandlerScope)
    }, jI.setCursor = function (t) {
        this.dom.style && (this.dom.style.cursor = t || "default")
    }, c(qn, hM);
    var qI = !WS.canvasSupported, KI = {canvas: VI}, $I = {}, JI = "4.3.2", QI = function (t, e, i) {
        i = i || {}, this.dom = e, this.id = t;
        var n = this, o = new aI, a = i.renderer;
        if (qI) {
            if (!KI.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
            a = "vml"
        } else a && KI[a] || (a = "canvas");
        var r = new KI[a](e, o, i, t);
        this.storage = o, this.painter = r;
        var s = WS.node || WS.worker ? null : new qn(r.getViewportRoot(), r.root);
        this.handler = new bM(o, r, s, r.root), this.animation = new GI({stage: {update: y(this.flush, this)}}), this.animation.start(), this._needsRefresh;
        var l = o.delFromStorage, u = o.addToStorage;
        o.delFromStorage = function (t) {
            l.call(o, t), t && t.removeSelfFromZr(n)
        }, o.addToStorage = function (t) {
            u.call(o, t), t.addSelfToZr(n)
        }
    };
    QI.prototype = {
        constructor: QI, getId: function () {
            return this.id
        }, add: function (t) {
            this.storage.addRoot(t), this._needsRefresh = !0
        }, remove: function (t) {
            this.storage.delRoot(t), this._needsRefresh = !0
        }, configLayer: function (t, e) {
            this.painter.configLayer && this.painter.configLayer(t, e), this._needsRefresh = !0
        }, setBackgroundColor: function (t) {
            this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this._needsRefresh = !0
        }, refreshImmediately: function () {
            this._needsRefresh = this._needsRefreshHover = !1, this.painter.refresh(), this._needsRefresh = this._needsRefreshHover = !1
        }, refresh: function () {
            this._needsRefresh = !0
        }, flush: function () {
            var t;
            this._needsRefresh && (t = !0, this.refreshImmediately()), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately()), t && this.trigger("rendered")
        }, addHover: function (t, e) {
            if (this.painter.addHover) {
                var i = this.painter.addHover(t, e);
                return this.refreshHover(), i
            }
        }, removeHover: function (t) {
            this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover())
        }, clearHover: function () {
            this.painter.clearHover && (this.painter.clearHover(), this.refreshHover())
        }, refreshHover: function () {
            this._needsRefreshHover = !0
        }, refreshHoverImmediately: function () {
            this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover()
        }, resize: function (t) {
            t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize()
        }, clearAnimation: function () {
            this.animation.clear()
        }, getWidth: function () {
            return this.painter.getWidth()
        }, getHeight: function () {
            return this.painter.getHeight()
        }, pathToImage: function (t, e) {
            return this.painter.pathToImage(t, e)
        }, setCursorStyle: function (t) {
            this.handler.setCursorStyle(t)
        }, findHover: function (t, e) {
            return this.handler.findHover(t, e)
        }, on: function (t, e, i) {
            this.handler.on(t, e, i)
        }, off: function (t, e) {
            this.handler.off(t, e)
        }, trigger: function (t, e) {
            this.handler.trigger(t, e)
        }, clear: function () {
            this.storage.delRoot(), this.painter.clear()
        }, dispose: function () {
            this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, to(this.id)
        }
    };
    var tT = (Object.freeze || Object)({version: JI, init: Kn, dispose: $n, getInstance: Jn, registerPainter: Qn}),
        eT = f, iT = S, nT = _, oT = "series\x00",
        aT = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"],
        rT = 0, sT = ".", lT = "___EC__COMPONENT__CONTAINER___", uT = 0, hT = function (t) {
            for (var e = 0; e < t.length; e++) t[e][1] || (t[e][1] = t[e][0]);
            return function (e, i, n) {
                for (var o = {}, a = 0; a < t.length; a++) {
                    var r = t[a][1];
                    if (!(i && u(i, r) >= 0 || n && u(n, r) < 0)) {
                        var s = e.getShallow(r);
                        null != s && (o[t[a][0]] = s)
                    }
                }
                return o
            }
        },
        cT = hT([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]),
        dT = {
            getLineStyle: function (t) {
                var e = cT(this, t);
                return e.lineDash = this.getLineDash(e.lineWidth), e
            }, getLineDash: function (t) {
                null == t && (t = 1);
                var e = this.get("type"), i = Math.max(t, 2), n = 4 * t;
                return "solid" === e || null == e ? !1 : "dashed" === e ? [n, n] : [i, i]
            }
        },
        fT = hT([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]),
        pT = {
            getAreaStyle: function (t, e) {
                return fT(this, t, e)
            }
        }, gT = Math.pow, mT = Math.sqrt, vT = 1e-8, yT = 1e-4, xT = mT(3), _T = 1 / 3, wT = F(), bT = F(), ST = F(),
        MT = Math.min, IT = Math.max, TT = Math.sin, AT = Math.cos, DT = 2 * Math.PI, CT = F(), LT = F(), kT = F(),
        PT = [], OT = [], ET = {M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7}, NT = [], RT = [], zT = [], BT = [],
        VT = Math.min, GT = Math.max, FT = Math.cos, WT = Math.sin, HT = Math.sqrt, ZT = Math.abs,
        UT = "undefined" != typeof Float32Array, XT = function (t) {
            this._saveData = !t, this._saveData && (this.data = []), this._ctx = null
        };
    XT.prototype = {
        constructor: XT,
        _xi: 0,
        _yi: 0,
        _x0: 0,
        _y0: 0,
        _ux: 0,
        _uy: 0,
        _len: 0,
        _lineDash: null,
        _dashOffset: 0,
        _dashIdx: 0,
        _dashSum: 0,
        setScale: function (t, e, i) {
            i = i || 0, this._ux = ZT(i / jM / t) || 0, this._uy = ZT(i / jM / e) || 0
        },
        getContext: function () {
            return this._ctx
        },
        beginPath: function (t) {
            return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
        },
        moveTo: function (t, e) {
            return this.addData(ET.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
        },
        lineTo: function (t, e) {
            var i = ZT(t - this._xi) > this._ux || ZT(e - this._yi) > this._uy || this._len < 5;
            return this.addData(ET.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this
        },
        bezierCurveTo: function (t, e, i, n, o, a) {
            return this.addData(ET.C, t, e, i, n, o, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, o, a) : this._ctx.bezierCurveTo(t, e, i, n, o, a)), this._xi = o, this._yi = a, this
        },
        quadraticCurveTo: function (t, e, i, n) {
            return this.addData(ET.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
        },
        arc: function (t, e, i, n, o, a) {
            return this.addData(ET.A, t, e, i, i, n, o - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, o, a), this._xi = FT(o) * i + t, this._yi = WT(o) * i + e, this
        },
        arcTo: function (t, e, i, n, o) {
            return this._ctx && this._ctx.arcTo(t, e, i, n, o), this
        },
        rect: function (t, e, i, n) {
            return this._ctx && this._ctx.rect(t, e, i, n), this.addData(ET.R, t, e, i, n), this
        },
        closePath: function () {
            this.addData(ET.Z);
            var t = this._ctx, e = this._x0, i = this._y0;
            return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this
        },
        fill: function (t) {
            t && t.fill(), this.toStatic()
        },
        stroke: function (t) {
            t && t.stroke(), this.toStatic()
        },
        setLineDash: function (t) {
            if (t instanceof Array) {
                this._lineDash = t, this._dashIdx = 0;
                for (var e = 0, i = 0; i < t.length; i++) e += t[i];
                this._dashSum = e
            }
            return this
        },
        setLineDashOffset: function (t) {
            return this._dashOffset = t, this
        },
        len: function () {
            return this._len
        },
        setData: function (t) {
            var e = t.length;
            this.data && this.data.length === e || !UT || (this.data = new Float32Array(e));
            for (var i = 0; e > i; i++) this.data[i] = t[i];
            this._len = e
        },
        appendPath: function (t) {
            t instanceof Array || (t = [t]);
            for (var e = t.length, i = 0, n = this._len, o = 0; e > o; o++) i += t[o].len();
            UT && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
            for (var o = 0; e > o; o++) for (var a = t[o].data, r = 0; r < a.length; r++) this.data[n++] = a[r];
            this._len = n
        },
        addData: function (t) {
            if (this._saveData) {
                var e = this.data;
                this._len + arguments.length > e.length && (this._expandData(), e = this.data);
                for (var i = 0; i < arguments.length; i++) e[this._len++] = arguments[i];
                this._prevCmd = t
            }
        },
        _expandData: function () {
            if (!(this.data instanceof Array)) {
                for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
                this.data = t
            }
        },
        _needsDash: function () {
            return this._lineDash
        },
        _dashedLineTo: function (t, e) {
            var i, n, o = this._dashSum, a = this._dashOffset, r = this._lineDash, s = this._ctx, l = this._xi,
                u = this._yi, h = t - l, c = e - u, d = HT(h * h + c * c), f = l, p = u, g = r.length;
            for (h /= d, c /= d, 0 > a && (a = o + a), a %= o, f -= a * h, p -= a * c; h > 0 && t >= f || 0 > h && f >= t || 0 === h && (c > 0 && e >= p || 0 > c && p >= e);) n = this._dashIdx, i = r[n], f += h * i, p += c * i, this._dashIdx = (n + 1) % g, h > 0 && l > f || 0 > h && f > l || c > 0 && u > p || 0 > c && p > u || s[n % 2 ? "moveTo" : "lineTo"](h >= 0 ? VT(f, t) : GT(f, t), c >= 0 ? VT(p, e) : GT(p, e));
            h = f - t, c = p - e, this._dashOffset = -HT(h * h + c * c)
        },
        _dashedBezierTo: function (t, e, i, n, o, a) {
            var r, s, l, u, h, c = this._dashSum, d = this._dashOffset, f = this._lineDash, p = this._ctx, g = this._xi,
                m = this._yi, v = Do, y = 0, x = this._dashIdx, _ = f.length, w = 0;
            for (0 > d && (d = c + d), d %= c, r = 0; 1 > r; r += .1) s = v(g, t, i, o, r + .1) - v(g, t, i, o, r), l = v(m, e, n, a, r + .1) - v(m, e, n, a, r), y += HT(s * s + l * l);
            for (; _ > x && (w += f[x], !(w > d)); x++) ;
            for (r = (w - d) / y; 1 >= r;) u = v(g, t, i, o, r), h = v(m, e, n, a, r), x % 2 ? p.moveTo(u, h) : p.lineTo(u, h), r += f[x] / y, x = (x + 1) % _;
            x % 2 !== 0 && p.lineTo(o, a), s = o - u, l = a - h, this._dashOffset = -HT(s * s + l * l)
        },
        _dashedQuadraticTo: function (t, e, i, n) {
            var o = i, a = n;
            i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, o, a)
        },
        toStatic: function () {
            var t = this.data;
            t instanceof Array && (t.length = this._len, UT && (this.data = new Float32Array(t)))
        },
        getBoundingRect: function () {
            NT[0] = NT[1] = zT[0] = zT[1] = Number.MAX_VALUE, RT[0] = RT[1] = BT[0] = BT[1] = -Number.MAX_VALUE;
            for (var t = this.data, e = 0, i = 0, n = 0, o = 0, a = 0; a < t.length;) {
                var r = t[a++];
                switch (1 === a && (e = t[a], i = t[a + 1], n = e, o = i), r) {
                    case ET.M:
                        n = t[a++], o = t[a++], e = n, i = o, zT[0] = n, zT[1] = o, BT[0] = n, BT[1] = o;
                        break;
                    case ET.L:
                        Fo(e, i, t[a], t[a + 1], zT, BT), e = t[a++], i = t[a++];
                        break;
                    case ET.C:
                        Wo(e, i, t[a++], t[a++], t[a++], t[a++], t[a], t[a + 1], zT, BT), e = t[a++], i = t[a++];
                        break;
                    case ET.Q:
                        Ho(e, i, t[a++], t[a++], t[a], t[a + 1], zT, BT), e = t[a++], i = t[a++];
                        break;
                    case ET.A:
                        var s = t[a++], l = t[a++], u = t[a++], h = t[a++], c = t[a++], d = t[a++] + c;
                        a += 1;
                        var f = 1 - t[a++];
                        1 === a && (n = FT(c) * u + s, o = WT(c) * h + l), Zo(s, l, u, h, c, d, f, zT, BT), e = FT(d) * u + s, i = WT(d) * h + l;
                        break;
                    case ET.R:
                        n = e = t[a++], o = i = t[a++];
                        var p = t[a++], g = t[a++];
                        Fo(n, o, n + p, o + g, zT, BT);
                        break;
                    case ET.Z:
                        e = n, i = o
                }
                re(NT, NT, zT), se(RT, RT, BT)
            }
            return 0 === a && (NT[0] = NT[1] = RT[0] = RT[1] = 0), new Ti(NT[0], NT[1], RT[0] - NT[0], RT[1] - NT[1])
        },
        rebuildPath: function (t) {
            for (var e, i, n, o, a, r, s = this.data, l = this._ux, u = this._uy, h = this._len, c = 0; h > c;) {
                var d = s[c++];
                switch (1 === c && (n = s[c], o = s[c + 1], e = n, i = o), d) {
                    case ET.M:
                        e = n = s[c++], i = o = s[c++], t.moveTo(n, o);
                        break;
                    case ET.L:
                        a = s[c++], r = s[c++], (ZT(a - n) > l || ZT(r - o) > u || c === h - 1) && (t.lineTo(a, r), n = a, o = r);
                        break;
                    case ET.C:
                        t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], o = s[c - 1];
                        break;
                    case ET.Q:
                        t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], o = s[c - 1];
                        break;
                    case ET.A:
                        var f = s[c++], p = s[c++], g = s[c++], m = s[c++], v = s[c++], y = s[c++], x = s[c++],
                            _ = s[c++], w = g > m ? g : m, b = g > m ? 1 : g / m, S = g > m ? m / g : 1,
                            M = Math.abs(g - m) > .001, I = v + y;
                        M ? (t.translate(f, p), t.rotate(x), t.scale(b, S), t.arc(0, 0, w, v, I, 1 - _), t.scale(1 / b, 1 / S), t.rotate(-x), t.translate(-f, -p)) : t.arc(f, p, w, v, I, 1 - _), 1 === c && (e = FT(v) * g + f, i = WT(v) * m + p), n = FT(I) * g + f, o = WT(I) * m + p;
                        break;
                    case ET.R:
                        e = n = s[c], i = o = s[c + 1], t.rect(s[c++], s[c++], s[c++], s[c++]);
                        break;
                    case ET.Z:
                        t.closePath(), n = e, o = i
                }
            }
        }
    }, XT.CMD = ET;
    var YT = 2 * Math.PI, jT = 2 * Math.PI, qT = XT.CMD, KT = 2 * Math.PI, $T = 1e-4, JT = [-1, -1, -1], QT = [-1, -1],
        tA = gI.prototype.getCanvasPattern, eA = Math.abs, iA = new XT(!0);
    aa.prototype = {
        constructor: aa,
        type: "path",
        __dirtyPath: !0,
        strokeContainThreshold: 5,
        segmentIgnoreThreshold: 0,
        subPixelOptimize: !1,
        brush: function (t, e) {
            var i = this.style, n = this.path || iA, o = i.hasStroke(), a = i.hasFill(), r = i.fill, s = i.stroke,
                l = a && !!r.colorStops, u = o && !!s.colorStops, h = a && !!r.image, c = o && !!s.image;
            if (i.bind(t, this, e), this.setTransform(t), this.__dirty) {
                var d;
                l && (d = d || this.getBoundingRect(), this._fillGradient = i.getGradient(t, r, d)), u && (d = d || this.getBoundingRect(), this._strokeGradient = i.getGradient(t, s, d))
            }
            l ? t.fillStyle = this._fillGradient : h && (t.fillStyle = tA.call(r, t)), u ? t.strokeStyle = this._strokeGradient : c && (t.strokeStyle = tA.call(s, t));
            var f = i.lineDash, p = i.lineDashOffset, g = !!t.setLineDash, m = this.getGlobalScale();
            if (n.setScale(m[0], m[1], this.segmentIgnoreThreshold), this.__dirtyPath || f && !g && o ? (n.beginPath(t), f && !g && (n.setLineDash(f), n.setLineDashOffset(p)), this.buildPath(n, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), a) if (null != i.fillOpacity) {
                var v = t.globalAlpha;
                t.globalAlpha = i.fillOpacity * i.opacity, n.fill(t), t.globalAlpha = v
            } else n.fill(t);
            if (f && g && (t.setLineDash(f), t.lineDashOffset = p), o) if (null != i.strokeOpacity) {
                var v = t.globalAlpha;
                t.globalAlpha = i.strokeOpacity * i.opacity, n.stroke(t), t.globalAlpha = v
            } else n.stroke(t);
            f && g && t.setLineDash([]), null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect()))
        },
        buildPath: function () {
        },
        createPathProxy: function () {
            this.path = new XT
        },
        getBoundingRect: function () {
            var t = this._rect, e = this.style, i = !t;
            if (i) {
                var n = this.path;
                n || (n = this.path = new XT), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect()
            }
            if (this._rect = t, e.hasStroke()) {
                var o = this._rectWithStroke || (this._rectWithStroke = t.clone());
                if (this.__dirty || i) {
                    o.copy(t);
                    var a = e.lineWidth, r = e.strokeNoScale ? this.getLineScale() : 1;
                    e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), r > 1e-10 && (o.width += a / r, o.height += a / r, o.x -= a / r / 2, o.y -= a / r / 2)
                }
                return o
            }
            return t
        },
        contain: function (t, e) {
            var i = this.transformCoordToLocal(t, e), n = this.getBoundingRect(), o = this.style;
            if (t = i[0], e = i[1], n.contain(t, e)) {
                var a = this.path.data;
                if (o.hasStroke()) {
                    var r = o.lineWidth, s = o.strokeNoScale ? this.getLineScale() : 1;
                    if (s > 1e-10 && (o.hasFill() || (r = Math.max(r, this.strokeContainThreshold)), oa(a, r / s, t, e))) return !0
                }
                if (o.hasFill()) return na(a, t, e)
            }
            return !1
        },
        dirty: function (t) {
            null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = this.__dirtyText = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
        },
        animateShape: function (t) {
            return this.animate("shape", t)
        },
        attrKV: function (t, e) {
            "shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : Dn.prototype.attrKV.call(this, t, e)
        },
        setShape: function (t, e) {
            var i = this.shape;
            if (i) {
                if (S(t)) for (var n in t) t.hasOwnProperty(n) && (i[n] = t[n]); else i[t] = e;
                this.dirty(!0)
            }
            return this
        },
        getLineScale: function () {
            var t = this.transform;
            return t && eA(t[0] - 1) > 1e-10 && eA(t[3] - 1) > 1e-10 ? Math.sqrt(eA(t[0] * t[3] - t[2] * t[1])) : 1
        }
    }, aa.extend = function (t) {
        var e = function (e) {
            aa.call(this, e), t.style && this.style.extendFrom(t.style, !1);
            var i = t.shape;
            if (i) {
                this.shape = this.shape || {};
                var n = this.shape;
                for (var o in i) !n.hasOwnProperty(o) && i.hasOwnProperty(o) && (n[o] = i[o])
            }
            t.init && t.init.call(this, e)
        };
        h(e, aa);
        for (var i in t) "style" !== i && "shape" !== i && (e.prototype[i] = t[i]);
        return e
    }, h(aa, Dn);
    var nA = XT.CMD, oA = [[], [], []], aA = Math.sqrt, rA = Math.atan2, sA = function (t, e) {
        var i, n, o, a, r, s, l = t.data, u = nA.M, h = nA.C, c = nA.L, d = nA.R, f = nA.A, p = nA.Q;
        for (o = 0, a = 0; o < l.length;) {
            switch (i = l[o++], a = o, n = 0, i) {
                case u:
                    n = 1;
                    break;
                case c:
                    n = 1;
                    break;
                case h:
                    n = 3;
                    break;
                case p:
                    n = 2;
                    break;
                case f:
                    var g = e[4], m = e[5], v = aA(e[0] * e[0] + e[1] * e[1]), y = aA(e[2] * e[2] + e[3] * e[3]),
                        x = rA(-e[1] / y, e[0] / v);
                    l[o] *= v, l[o++] += g, l[o] *= y, l[o++] += m, l[o++] *= v, l[o++] *= y, l[o++] += x, l[o++] += x, o += 2, a = o;
                    break;
                case d:
                    s[0] = l[o++], s[1] = l[o++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1], s[0] += l[o++], s[1] += l[o++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1]
            }
            for (r = 0; n > r; r++) {
                var s = oA[r];
                s[0] = l[o++], s[1] = l[o++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1]
            }
        }
    }, lA = Math.sqrt, uA = Math.sin, hA = Math.cos, cA = Math.PI, dA = function (t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1])
    }, fA = function (t, e) {
        return (t[0] * e[0] + t[1] * e[1]) / (dA(t) * dA(e))
    }, pA = function (t, e) {
        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(fA(t, e))
    }, gA = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi, mA = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g, vA = function (t) {
        Dn.call(this, t)
    };
    vA.prototype = {
        constructor: vA, type: "text", brush: function (t, e) {
            var i = this.style;
            this.__dirty && hn(i, !0), i.fill = i.stroke = i.shadowBlur = i.shadowColor = i.shadowOffsetX = i.shadowOffsetY = null;
            var n = i.text;
            return null != n && (n += ""), An(n, i) ? (this.setTransform(t), dn(this, t, n, i, null, e), void this.restoreTransform(t)) : void (t.__attrCachedBy = lI.NONE)
        }, getBoundingRect: function () {
            var t = this.style;
            if (this.__dirty && hn(t, !0), !this._rect) {
                var e = t.text;
                null != e ? e += "" : e = "";
                var i = Xi(t.text + "", t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich);
                if (i.x += t.x || 0, i.y += t.y || 0, Sn(t.textStroke, t.textStrokeWidth)) {
                    var n = t.textStrokeWidth;
                    i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n
                }
                this._rect = i
            }
            return this._rect
        }
    }, h(vA, Dn);
    var yA = aa.extend({
            type: "circle", shape: {cx: 0, cy: 0, r: 0}, buildPath: function (t, e, i) {
                i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
            }
        }), xA = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]],
        _A = function (t) {
            return WS.browser.ie && WS.browser.version >= 11 ? function () {
                var e, i = this.__clipPaths, n = this.style;
                if (i) for (var o = 0; o < i.length; o++) {
                    var a = i[o], r = a && a.shape, s = a && a.type;
                    if (r && ("sector" === s && r.startAngle === r.endAngle || "rect" === s && (!r.width || !r.height))) {
                        for (var l = 0; l < xA.length; l++) xA[l][2] = n[xA[l][0]], n[xA[l][0]] = xA[l][1];
                        e = !0;
                        break
                    }
                }
                if (t.apply(this, arguments), e) for (var l = 0; l < xA.length; l++) n[xA[l][0]] = xA[l][2]
            } : t
        }, wA = aa.extend({
            type: "sector",
            shape: {cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
            brush: _A(aa.prototype.brush),
            buildPath: function (t, e) {
                var i = e.cx, n = e.cy, o = Math.max(e.r0 || 0, 0), a = Math.max(e.r, 0), r = e.startAngle, s = e.endAngle,
                    l = e.clockwise, u = Math.cos(r), h = Math.sin(r);
                t.moveTo(u * o + i, h * o + n), t.lineTo(u * a + i, h * a + n), t.arc(i, n, a, r, s, !l), t.lineTo(Math.cos(s) * o + i, Math.sin(s) * o + n), 0 !== o && t.arc(i, n, o, s, r, l), t.closePath()
            }
        }), bA = aa.extend({
            type: "ring", shape: {cx: 0, cy: 0, r: 0, r0: 0}, buildPath: function (t, e) {
                var i = e.cx, n = e.cy, o = 2 * Math.PI;
                t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, o, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, o, !0)
            }
        }), SA = function (t, e) {
            for (var i = t.length, n = [], o = 0, a = 1; i > a; a++) o += ee(t[a - 1], t[a]);
            var r = o / 2;
            r = i > r ? i : r;
            for (var a = 0; r > a; a++) {
                var s, l, u, h = a / (r - 1) * (e ? i : i - 1), c = Math.floor(h), d = h - c, f = t[c % i];
                e ? (s = t[(c - 1 + i) % i], l = t[(c + 1) % i], u = t[(c + 2) % i]) : (s = t[0 === c ? c : c - 1], l = t[c > i - 2 ? i - 1 : c + 1], u = t[c > i - 3 ? i - 1 : c + 2]);
                var p = d * d, g = d * p;
                n.push([da(s[0], f[0], l[0], u[0], d, p, g), da(s[1], f[1], l[1], u[1], d, p, g)])
            }
            return n
        }, MA = function (t, e, i, n) {
            var o, a, r, s, l = [], u = [], h = [], c = [];
            if (n) {
                r = [1 / 0, 1 / 0], s = [-1 / 0, -1 / 0];
                for (var d = 0, f = t.length; f > d; d++) re(r, r, t[d]), se(s, s, t[d]);
                re(r, r, n[0]), se(s, s, n[1])
            }
            for (var d = 0, f = t.length; f > d; d++) {
                var p = t[d];
                if (i) o = t[d ? d - 1 : f - 1], a = t[(d + 1) % f]; else {
                    if (0 === d || d === f - 1) {
                        l.push(H(t[d]));
                        continue
                    }
                    o = t[d - 1], a = t[d + 1]
                }
                Y(u, a, o), Q(u, u, e);
                var g = ee(p, o), m = ee(p, a), v = g + m;
                0 !== v && (g /= v, m /= v), Q(h, u, -g), Q(c, u, m);
                var y = U([], p, h), x = U([], p, c);
                n && (se(y, y, r), re(y, y, s), se(x, x, r), re(x, x, s)), l.push(y), l.push(x)
            }
            return i && l.push(l.shift()), l
        }, IA = aa.extend({
            type: "polygon",
            shape: {points: null, smooth: !1, smoothConstraint: null},
            buildPath: function (t, e) {
                fa(t, e, !0)
            }
        }), TA = aa.extend({
            type: "polyline",
            shape: {points: null, smooth: !1, smoothConstraint: null},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                fa(t, e, !1)
            }
        }), AA = Math.round, DA = {}, CA = aa.extend({
            type: "rect", shape: {r: 0, x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i, n, o, a;
                this.subPixelOptimize ? (ga(DA, e, this.style), i = DA.x, n = DA.y, o = DA.width, a = DA.height, DA.r = e.r, e = DA) : (i = e.x, n = e.y, o = e.width, a = e.height), e.r ? un(t, e) : t.rect(i, n, o, a), t.closePath()
            }
        }), LA = {}, kA = aa.extend({
            type: "line",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i, n, o, a;
                this.subPixelOptimize ? (pa(LA, e, this.style), i = LA.x1, n = LA.y1, o = LA.x2, a = LA.y2) : (i = e.x1, n = e.y1, o = e.x2, a = e.y2);
                var r = e.percent;
                0 !== r && (t.moveTo(i, n), 1 > r && (o = i * (1 - r) + o * r, a = n * (1 - r) + a * r), t.lineTo(o, a))
            },
            pointAt: function (t) {
                var e = this.shape;
                return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
            }
        }), PA = [], OA = aa.extend({
            type: "bezier-curve",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.x1, n = e.y1, o = e.x2, a = e.y2, r = e.cpx1, s = e.cpy1, l = e.cpx2, u = e.cpy2, h = e.percent;
                0 !== h && (t.moveTo(i, n), null == l || null == u ? (1 > h && (Bo(i, r, o, h, PA), r = PA[1], o = PA[2], Bo(n, s, a, h, PA), s = PA[1], a = PA[2]), t.quadraticCurveTo(r, s, o, a)) : (1 > h && (Po(i, r, l, o, h, PA), r = PA[1], l = PA[2], o = PA[3], Po(n, s, u, a, h, PA), s = PA[1], u = PA[2], a = PA[3]), t.bezierCurveTo(r, s, l, u, o, a)))
            },
            pointAt: function (t) {
                return va(this.shape, t, !1)
            },
            tangentAt: function (t) {
                var e = va(this.shape, t, !0);
                return te(e, e)
            }
        }), EA = aa.extend({
            type: "arc",
            shape: {cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.cx, n = e.cy, o = Math.max(e.r, 0), a = e.startAngle, r = e.endAngle, s = e.clockwise,
                    l = Math.cos(a), u = Math.sin(a);
                t.moveTo(l * o + i, u * o + n), t.arc(i, n, o, a, r, !s)
            }
        }), NA = aa.extend({
            type: "compound", shape: {paths: null}, _updatePathDirty: function () {
                for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++) t = t || e[i].__dirtyPath;
                this.__dirtyPath = t, this.__dirty = this.__dirty || t
            }, beforeBrush: function () {
                this._updatePathDirty();
                for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++) t[i].path || t[i].createPathProxy(), t[i].path.setScale(e[0], e[1], t[i].segmentIgnoreThreshold)
            }, buildPath: function (t, e) {
                for (var i = e.paths || [], n = 0; n < i.length; n++) i[n].buildPath(t, i[n].shape, !0)
            }, afterBrush: function () {
                for (var t = this.shape.paths || [], e = 0; e < t.length; e++) t[e].__dirtyPath = !1
            }, getBoundingRect: function () {
                return this._updatePathDirty(), aa.prototype.getBoundingRect.call(this)
            }
        }), RA = function (t) {
            this.colorStops = t || []
        };
    RA.prototype = {
        constructor: RA, addColorStop: function (t, e) {
            this.colorStops.push({offset: t, color: e})
        }
    };
    var zA = function (t, e, i, n, o, a) {
        this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, this.y2 = null == n ? 0 : n, this.type = "linear", this.global = a || !1, RA.call(this, o)
    };
    zA.prototype = {constructor: zA}, h(zA, RA);
    var BA = function (t, e, i, n, o) {
        this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, this.type = "radial", this.global = o || !1, RA.call(this, n)
    };
    BA.prototype = {constructor: BA}, h(BA, RA), ya.prototype.incremental = !0, ya.prototype.clearDisplaybles = function () {
        this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), this.notClear = !1
    }, ya.prototype.addDisplayable = function (t, e) {
        e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.dirty()
    }, ya.prototype.addDisplayables = function (t, e) {
        e = e || !1;
        for (var i = 0; i < t.length; i++) this.addDisplayable(t[i], e)
    }, ya.prototype.eachPendingDisplayable = function (t) {
        for (var e = this._cursor; e < this._displayables.length; e++) t && t(this._displayables[e]);
        for (var e = 0; e < this._temporaryDisplayables.length; e++) t && t(this._temporaryDisplayables[e])
    }, ya.prototype.update = function () {
        this.updateTransform();
        for (var t = this._cursor; t < this._displayables.length; t++) {
            var e = this._displayables[t];
            e.parent = this, e.update(), e.parent = null
        }
        for (var t = 0; t < this._temporaryDisplayables.length; t++) {
            var e = this._temporaryDisplayables[t];
            e.parent = this, e.update(), e.parent = null
        }
    }, ya.prototype.brush = function (t) {
        for (var e = this._cursor; e < this._displayables.length; e++) {
            var i = this._displayables[e];
            i.beforeBrush && i.beforeBrush(t), i.brush(t, e === this._cursor ? null : this._displayables[e - 1]), i.afterBrush && i.afterBrush(t)
        }
        this._cursor = e;
        for (var e = 0; e < this._temporaryDisplayables.length; e++) {
            var i = this._temporaryDisplayables[e];
            i.beforeBrush && i.beforeBrush(t), i.brush(t, 0 === e ? null : this._temporaryDisplayables[e - 1]), i.afterBrush && i.afterBrush(t)
        }
        this._temporaryDisplayables = [], this.notClear = !0
    };
    var VA = [];
    ya.prototype.getBoundingRect = function () {
        if (!this._rect) {
            for (var t = new Ti(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) {
                var i = this._displayables[e], n = i.getBoundingRect().clone();
                i.needLocalTransform() && n.applyTransform(i.getLocalTransform(VA)), t.union(n)
            }
            this._rect = t
        }
        return this._rect
    }, ya.prototype.contain = function (t, e) {
        var i = this.transformCoordToLocal(t, e), n = this.getBoundingRect();
        if (n.contain(i[0], i[1])) for (var o = 0; o < this._displayables.length; o++) {
            var a = this._displayables[o];
            if (a.contain(t, e)) return !0
        }
        return !1
    }, h(ya, Dn);
    var GA = Math.max, FA = Math.min, WA = {}, HA = 1,
        ZA = {color: "textFill", textBorderColor: "textStroke", textBorderWidth: "textStrokeWidth"}, UA = "emphasis",
        XA = "normal", YA = 1, jA = {}, qA = {}, KA = ca, $A = ma, JA = B(), QA = 0;
    wa("circle", yA), wa("sector", wA), wa("ring", bA), wa("polygon", IA), wa("polyline", TA), wa("rect", CA), wa("line", kA), wa("bezierCurve", OA), wa("arc", EA);
    var tD = (Object.freeze || Object)({
            Z2_EMPHASIS_LIFT: HA,
            CACHED_LABEL_STYLE_PROPERTIES: ZA,
            extendShape: xa,
            extendPath: _a,
            registerShape: wa,
            getShapeClass: ba,
            makePath: Sa,
            makeImage: Ma,
            mergePath: KA,
            resizePath: Ta,
            subPixelOptimizeLine: Aa,
            subPixelOptimizeRect: Da,
            subPixelOptimize: $A,
            setElementHoverStyle: Ra,
            setHoverStyle: Wa,
            setAsHighDownDispatcher: Ha,
            isHighDownDispatcher: Za,
            getHighlightDigit: Ua,
            setLabelStyle: Xa,
            modifyLabelStyle: Ya,
            setTextStyle: ja,
            setText: qa,
            getFont: ir,
            updateProps: or,
            initProps: ar,
            getTransform: rr,
            applyTransform: sr,
            transformDirection: lr,
            groupTransition: ur,
            clipPointsByRect: hr,
            clipRectByRect: cr,
            createIcon: dr,
            linePolygonIntersect: fr,
            lineLineIntersect: pr,
            Group: iI,
            Image: Cn,
            Text: vA,
            Circle: yA,
            Sector: wA,
            Ring: bA,
            Polygon: IA,
            Polyline: TA,
            Rect: CA,
            Line: kA,
            BezierCurve: OA,
            Arc: EA,
            IncrementalDisplayable: ya,
            CompoundPath: NA,
            LinearGradient: zA,
            RadialGradient: BA,
            BoundingRect: Ti
        }), eD = ["textStyle", "color"], iD = {
            getTextColor: function (t) {
                var e = this.ecModel;
                return this.getShallow("color") || (!t && e ? e.get(eD) : null)
            }, getFont: function () {
                return ir({
                    fontStyle: this.getShallow("fontStyle"),
                    fontWeight: this.getShallow("fontWeight"),
                    fontSize: this.getShallow("fontSize"),
                    fontFamily: this.getShallow("fontFamily")
                }, this.ecModel)
            }, getTextRect: function (t) {
                return Xi(t, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText"))
            }
        },
        nD = hT([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]),
        oD = {
            getItemStyle: function (t, e) {
                var i = nD(this, t, e), n = this.getBorderLineDash();
                return n && (i.lineDash = n), i
            }, getBorderLineDash: function () {
                var t = this.get("borderType");
                return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
            }
        }, aD = c, rD = co();
    vr.prototype = {
        constructor: vr, init: null, mergeOption: function (t) {
            o(this.option, t, !0)
        }, get: function (t, e) {
            return null == t ? this.option : yr(this.option, this.parsePath(t), !e && xr(this, t))
        }, getShallow: function (t, e) {
            var i = this.option, n = null == i ? i : i[t], o = !e && xr(this, t);
            return null == n && o && (n = o.getShallow(t)), n
        }, getModel: function (t, e) {
            var i, n = null == t ? this.option : yr(this.option, t = this.parsePath(t));
            return e = e || (i = xr(this, t)) && i.getModel(t), new vr(n, e, this.ecModel)
        }, isEmpty: function () {
            return null == this.option
        }, restoreData: function () {
        }, clone: function () {
            var t = this.constructor;
            return new t(n(this.option))
        }, setReadOnly: function () {
        }, parsePath: function (t) {
            return "string" == typeof t && (t = t.split(".")), t
        }, customizeGetParent: function (t) {
            rD(this).getParent = t
        }, isAnimationEnabled: function () {
            if (!WS.node) {
                if (null != this.option.animation) return !!this.option.animation;
                if (this.parentModel) return this.parentModel.isAnimationEnabled()
            }
        }
    }, wo(vr), bo(vr), aD(vr, dT), aD(vr, pT), aD(vr, iD), aD(vr, oD);
    var sD = 0, lD = 1e-4, uD = 9007199254740991,
        hD = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/,
        cD = (Object.freeze || Object)({
            linearMap: Mr,
            parsePercent: Ir,
            round: Tr,
            asc: Ar,
            getPrecision: Dr,
            getPrecisionSafe: Cr,
            getPixelPrecision: Lr,
            getPercentWithPrecision: kr,
            MAX_SAFE_INTEGER: uD,
            remRadian: Pr,
            isRadianAroundZero: Or,
            parseDate: Er,
            quantity: Nr,
            quantityExponent: Rr,
            nice: zr,
            quantile: Br,
            reformIntervals: Vr,
            isNumeric: Gr
        }), dD = P, fD = /([&<>"'])/g, pD = {"&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"},
        gD = ["a", "b", "c", "d", "e", "f", "g"], mD = function (t, e) {
            return "{" + t + (null == e ? "" : e) + "}"
        }, vD = Ji, yD = (Object.freeze || Object)({
            addCommas: Fr,
            toCamelCase: Wr,
            normalizeCssArray: dD,
            encodeHTML: Hr,
            formatTpl: Zr,
            formatTplSimple: Ur,
            getTooltipMarker: Xr,
            formatTime: jr,
            capitalFirst: qr,
            truncateText: vD,
            getTextBoundingRect: Kr,
            getTextRect: $r,
            windowOpen: Jr
        }), xD = f, _D = ["left", "right", "top", "bottom", "width", "height"],
        wD = [["width", "left", "right"], ["height", "top", "bottom"]], bD = Qr,
        SD = (x(Qr, "vertical"), x(Qr, "horizontal"), {
            getBoxLayoutParams: function () {
                return {
                    left: this.get("left"),
                    top: this.get("top"),
                    right: this.get("right"),
                    bottom: this.get("bottom"),
                    width: this.get("width"),
                    height: this.get("height")
                }
            }
        }), MD = co(), ID = vr.extend({
            type: "component",
            id: "",
            name: "",
            mainType: "",
            subType: "",
            componentIndex: 0,
            defaultOption: null,
            ecModel: null,
            dependentModels: [],
            uid: null,
            layoutMode: null,
            $constructor: function (t, e, i, n) {
                vr.call(this, t, e, i, n), this.uid = _r("ec_cpt_model")
            },
            init: function (t, e, i) {
                this.mergeDefaultAndTheme(t, i)
            },
            mergeDefaultAndTheme: function (t, e) {
                var i = this.layoutMode, n = i ? as(t) : {}, a = e.getTheme();
                o(t, a.get(this.mainType)), o(t, this.getDefaultOption()), i && os(t, n, i)
            },
            mergeOption: function (t) {
                o(this.option, t, !0);
                var e = this.layoutMode;
                e && os(this.option, t, e)
            },
            optionUpdated: function () {
            },
            getDefaultOption: function () {
                var t = MD(this);
                if (!t.defaultOption) {
                    for (var e = [], i = this.constructor; i;) {
                        var n = i.prototype.defaultOption;
                        n && e.push(n), i = i.superClass
                    }
                    for (var a = {}, r = e.length - 1; r >= 0; r--) a = o(a, e[r], !0);
                    t.defaultOption = a
                }
                return t.defaultOption
            },
            getReferringComponents: function (t) {
                return this.ecModel.queryComponents({
                    mainType: t,
                    index: this.get(t + "Index", !0),
                    id: this.get(t + "Id", !0)
                })
            }
        });
    Io(ID, {registerWhenExtend: !0}), wr(ID), br(ID, ss), c(ID, SD);
    var TD = "";
    "undefined" != typeof navigator && (TD = navigator.platform || "");
    var AD = {
            color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
            gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
            textStyle: {
                fontFamily: TD.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            },
            blendMode: null,
            animation: "auto",
            animationDuration: 1e3,
            animationDurationUpdate: 300,
            animationEasing: "exponentialOut",
            animationEasingUpdate: "cubicOut",
            animationThreshold: 2e3,
            progressiveThreshold: 3e3,
            progressive: 400,
            hoverLayerThreshold: 3e3,
            useUTC: !1
        }, DD = co(), CD = {
            clearColorPalette: function () {
                DD(this).colorIdx = 0, DD(this).colorNameMap = {}
            }, getColorFromPalette: function (t, e, i) {
                e = e || this;
                var n = DD(e), o = n.colorIdx || 0, a = n.colorNameMap = n.colorNameMap || {};
                if (a.hasOwnProperty(t)) return a[t];
                var r = eo(this.get("color", !0)), s = this.get("colorLayer", !0), l = null != i && s ? ls(s, i) : r;
                if (l = l || r, l && l.length) {
                    var u = l[o];
                    return t && (a[t] = u), n.colorIdx = (o + 1) % l.length, u
                }
            }
        }, LD = "original", kD = "arrayRows", PD = "objectRows", OD = "keyedColumns", ED = "unknown", ND = "typedArray",
        RD = "column", zD = "row";
    us.seriesDataToSource = function (t) {
        return new us({data: t, sourceFormat: I(t) ? ND : LD, fromDataset: !1})
    }, bo(us);
    var BD = {Must: 1, Might: 2, Not: 3}, VD = co(), GD = "\x00_ec_inner", FD = vr.extend({
        init: function (t, e, i, n) {
            i = i || {}, this.option = null, this._theme = new vr(i), this._optionManager = n
        }, setOption: function (t, e) {
            O(!(GD in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption(null)
        }, resetOption: function (t) {
            var e = !1, i = this._optionManager;
            if (!t || "recreate" === t) {
                var n = i.mountOption("recreate" === t);
                this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(n)) : Is.call(this, n), e = !0
            }
            if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) {
                var o = i.getTimelineOption(this);
                o && (this.mergeOption(o), e = !0)
            }
            if (!t || "recreate" === t || "media" === t) {
                var a = i.getMediaOption(this, this._api);
                a.length && f(a, function (t) {
                    this.mergeOption(t, e = !0)
                }, this)
            }
            return e
        }, mergeOption: function (t) {
            function e(e, n) {
                var o = eo(t[e]), s = ao(a.get(e), o);
                ro(s), f(s, function (t) {
                    var i = t.option;
                    S(i) && (t.keyInfo.mainType = e, t.keyInfo.subType = As(e, i, t.exist))
                });
                var l = Ts(a, n);
                i[e] = [], a.set(e, []), f(s, function (t, n) {
                    var o = t.exist, s = t.option;
                    if (O(S(s) || o, "Empty component definition"), s) {
                        var u = ID.getClass(e, t.keyInfo.subType, !0);
                        if (o && o.constructor === u) o.name = t.keyInfo.name, o.mergeOption(s, this), o.optionUpdated(s, !1); else {
                            var h = r({dependentModels: l, componentIndex: n}, t.keyInfo);
                            o = new u(s, this, this, h), r(o, h), o.init(s, this, this, h), o.optionUpdated(null, !0)
                        }
                    } else o.mergeOption({}, this), o.optionUpdated({}, !1);
                    a.get(e)[n] = o, i[e][n] = o.option
                }, this), "series" === e && Ds(this, a.get("series"))
            }

            var i = this.option, a = this._componentsMap, s = [];
            ds(this), f(t, function (t, e) {
                null != t && (ID.hasClass(e) ? e && s.push(e) : i[e] = null == i[e] ? n(t) : o(i[e], t, !0))
            }), ID.topologicalTravel(s, ID.getAllClassMainTypes(), e, this), this._seriesIndicesMap = B(this._seriesIndices = this._seriesIndices || [])
        }, getOption: function () {
            var t = n(this.option);
            return f(t, function (e, i) {
                if (ID.hasClass(i)) {
                    for (var e = eo(e), n = e.length - 1; n >= 0; n--) lo(e[n]) && e.splice(n, 1);
                    t[i] = e
                }
            }), delete t[GD], t
        }, getTheme: function () {
            return this._theme
        }, getComponent: function (t, e) {
            var i = this._componentsMap.get(t);
            return i ? i[e || 0] : void 0
        }, queryComponents: function (t) {
            var e = t.mainType;
            if (!e) return [];
            var i = t.index, n = t.id, o = t.name, a = this._componentsMap.get(e);
            if (!a || !a.length) return [];
            var r;
            if (null != i) _(i) || (i = [i]), r = m(p(i, function (t) {
                return a[t]
            }), function (t) {
                return !!t
            }); else if (null != n) {
                var s = _(n);
                r = m(a, function (t) {
                    return s && u(n, t.id) >= 0 || !s && t.id === n
                })
            } else if (null != o) {
                var l = _(o);
                r = m(a, function (t) {
                    return l && u(o, t.name) >= 0 || !l && t.name === o
                })
            } else r = a.slice();
            return Cs(r, t)
        }, findComponents: function (t) {
            function e(t) {
                var e = o + "Index", i = o + "Id", n = o + "Name";
                return !t || null == t[e] && null == t[i] && null == t[n] ? null : {
                    mainType: o,
                    index: t[e],
                    id: t[i],
                    name: t[n]
                }
            }

            function i(e) {
                return t.filter ? m(e, t.filter) : e
            }

            var n = t.query, o = t.mainType, a = e(n), r = a ? this.queryComponents(a) : this._componentsMap.get(o);
            return i(Cs(r, t))
        }, eachComponent: function (t, e, i) {
            var n = this._componentsMap;
            if ("function" == typeof t) i = e, e = t, n.each(function (t, n) {
                f(t, function (t, o) {
                    e.call(i, n, t, o)
                })
            }); else if (b(t)) f(n.get(t), e, i); else if (S(t)) {
                var o = this.findComponents(t);
                f(o, e, i)
            }
        }, getSeriesByName: function (t) {
            var e = this._componentsMap.get("series");
            return m(e, function (e) {
                return e.name === t
            })
        }, getSeriesByIndex: function (t) {
            return this._componentsMap.get("series")[t]
        }, getSeriesByType: function (t) {
            var e = this._componentsMap.get("series");
            return m(e, function (e) {
                return e.subType === t
            })
        }, getSeries: function () {
            return this._componentsMap.get("series").slice()
        }, getSeriesCount: function () {
            return this._componentsMap.get("series").length
        }, eachSeries: function (t, e) {
            Ls(this), f(this._seriesIndices, function (i) {
                var n = this._componentsMap.get("series")[i];
                t.call(e, n, i)
            }, this)
        }, eachRawSeries: function (t, e) {
            f(this._componentsMap.get("series"), t, e)
        }, eachSeriesByType: function (t, e, i) {
            Ls(this), f(this._seriesIndices, function (n) {
                var o = this._componentsMap.get("series")[n];
                o.subType === t && e.call(i, o, n)
            }, this)
        }, eachRawSeriesByType: function (t, e, i) {
            return f(this.getSeriesByType(t), e, i)
        }, isSeriesFiltered: function (t) {
            return Ls(this), null == this._seriesIndicesMap.get(t.componentIndex)
        }, getCurrentSeriesIndices: function () {
            return (this._seriesIndices || []).slice()
        }, filterSeries: function (t, e) {
            Ls(this);
            var i = m(this._componentsMap.get("series"), t, e);
            Ds(this, i)
        }, restoreData: function (t) {
            var e = this._componentsMap;
            Ds(this, e.get("series"));
            var i = [];
            e.each(function (t, e) {
                i.push(e)
            }), ID.topologicalTravel(i, ID.getAllClassMainTypes(), function (i) {
                f(e.get(i), function (e) {
                    ("series" !== i || !Ss(e, t)) && e.restoreData()
                })
            })
        }
    });
    c(FD, CD);
    var WD = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"],
        HD = {};
    Ps.prototype = {
        constructor: Ps, create: function (t, e) {
            var i = [];
            f(HD, function (n) {
                var o = n.create(t, e);
                i = i.concat(o || [])
            }), this._coordinateSystems = i
        }, update: function (t, e) {
            f(this._coordinateSystems, function (i) {
                i.update && i.update(t, e)
            })
        }, getCoordinateSystems: function () {
            return this._coordinateSystems.slice()
        }
    }, Ps.register = function (t, e) {
        HD[t] = e
    }, Ps.get = function (t) {
        return HD[t]
    };
    var ZD = f, UD = n, XD = p, YD = o, jD = /^(min|max)?(.+)$/;
    Os.prototype = {
        constructor: Os, setOption: function (t, e) {
            t && f(eo(t.series), function (t) {
                t && t.data && I(t.data) && N(t.data)
            }), t = UD(t);
            var i = this._optionBackup, n = Es.call(this, t, e, !i);
            this._newBaseOption = n.baseOption, i ? (Bs(i.baseOption, n.baseOption), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n
        }, mountOption: function (t) {
            var e = this._optionBackup;
            return this._timelineOptions = XD(e.timelineOptions, UD), this._mediaList = XD(e.mediaList, UD), this._mediaDefault = UD(e.mediaDefault), this._currentMediaIndices = [], UD(t ? e.baseOption : this._newBaseOption)
        }, getTimelineOption: function (t) {
            var e, i = this._timelineOptions;
            if (i.length) {
                var n = t.getComponent("timeline");
                n && (e = UD(i[n.getCurrentIndex()], !0))
            }
            return e
        }, getMediaOption: function () {
            var t = this._api.getWidth(), e = this._api.getHeight(), i = this._mediaList, n = this._mediaDefault,
                o = [], a = [];
            if (!i.length && !n) return a;
            for (var r = 0, s = i.length; s > r; r++) Ns(i[r].query, t, e) && o.push(r);
            return !o.length && n && (o = [-1]), o.length && !zs(o, this._currentMediaIndices) && (a = XD(o, function (t) {
                return UD(-1 === t ? n.option : i[t].option)
            })), this._currentMediaIndices = o, a
        }
    };
    var qD = f, KD = S, $D = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"],
        JD = function (t, e) {
            qD(Us(t.series), function (t) {
                KD(t) && Zs(t)
            });
            var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
            e && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), qD(i, function (e) {
                qD(Us(t[e]), function (t) {
                    t && (Ws(t, "axisLabel"), Ws(t.axisPointer, "label"))
                })
            }), qD(Us(t.parallel), function (t) {
                var e = t && t.parallelAxisDefault;
                Ws(e, "axisLabel"), Ws(e && e.axisPointer, "label")
            }), qD(Us(t.calendar), function (t) {
                Gs(t, "itemStyle"), Ws(t, "dayLabel"), Ws(t, "monthLabel"), Ws(t, "yearLabel")
            }), qD(Us(t.radar), function (t) {
                Ws(t, "name")
            }), qD(Us(t.geo), function (t) {
                KD(t) && (Hs(t), qD(Us(t.regions), function (t) {
                    Hs(t)
                }))
            }), qD(Us(t.timeline), function (t) {
                Hs(t), Gs(t, "label"), Gs(t, "itemStyle"), Gs(t, "controlStyle", !0);
                var e = t.data;
                _(e) && f(e, function (t) {
                    S(t) && (Gs(t, "label"), Gs(t, "itemStyle"))
                })
            }), qD(Us(t.toolbox), function (t) {
                Gs(t, "iconStyle"), qD(t.feature, function (t) {
                    Gs(t, "iconStyle")
                })
            }), Ws(Xs(t.axisPointer), "label"), Ws(Xs(t.tooltip).axisPointer, "label")
        }, QD = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]],
        tC = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
        eC = function (t, e) {
            JD(t, e), t.series = eo(t.series), f(t.series, function (t) {
                if (S(t)) {
                    var e = t.type;
                    if ("line" === e) null != t.clipOverflow && (t.clip = t.clipOverflow); else if ("pie" === e || "gauge" === e) null != t.clockWise && (t.clockwise = t.clockWise); else if ("gauge" === e) {
                        var i = Ys(t, "pointer.color");
                        null != i && js(t, "itemStyle.color", i)
                    }
                    qs(t)
                }
            }), t.dataRange && (t.visualMap = t.dataRange), f(tC, function (e) {
                var i = t[e];
                i && (_(i) || (i = [i]), f(i, function (t) {
                    qs(t)
                }))
            })
        }, iC = function (t) {
            var e = B();
            t.eachSeries(function (t) {
                var i = t.get("stack");
                if (i) {
                    var n = e.get(i) || e.set(i, []), o = t.getData(), a = {
                        stackResultDimension: o.getCalculationInfo("stackResultDimension"),
                        stackedOverDimension: o.getCalculationInfo("stackedOverDimension"),
                        stackedDimension: o.getCalculationInfo("stackedDimension"),
                        stackedByDimension: o.getCalculationInfo("stackedByDimension"),
                        isStackedByIndex: o.getCalculationInfo("isStackedByIndex"),
                        data: o,
                        seriesModel: t
                    };
                    if (!a.stackedDimension || !a.isStackedByIndex && !a.stackedByDimension) return;
                    n.length && o.setCalculationInfo("stackedOnSeries", n[n.length - 1].seriesModel), n.push(a)
                }
            }), e.each(Ks)
        }, nC = $s.prototype;
    nC.pure = !1, nC.persistent = !0, nC.getSource = function () {
        return this._source
    };
    var oC = {
        arrayRows_column: {
            pure: !0, count: function () {
                return Math.max(0, this._data.length - this._source.startIndex)
            }, getItem: function (t) {
                return this._data[t + this._source.startIndex]
            }, appendData: tl
        },
        arrayRows_row: {
            pure: !0, count: function () {
                var t = this._data[0];
                return t ? Math.max(0, t.length - this._source.startIndex) : 0
            }, getItem: function (t) {
                t += this._source.startIndex;
                for (var e = [], i = this._data, n = 0; n < i.length; n++) {
                    var o = i[n];
                    e.push(o ? o[t] : null)
                }
                return e
            }, appendData: function () {
                throw new Error('Do not support appendData when set seriesLayoutBy: "row".')
            }
        },
        objectRows: {pure: !0, count: Js, getItem: Qs, appendData: tl},
        keyedColumns: {
            pure: !0, count: function () {
                var t = this._source.dimensionsDefine[0].name, e = this._data[t];
                return e ? e.length : 0
            }, getItem: function (t) {
                for (var e = [], i = this._source.dimensionsDefine, n = 0; n < i.length; n++) {
                    var o = this._data[i[n].name];
                    e.push(o ? o[t] : null)
                }
                return e
            }, appendData: function (t) {
                var e = this._data;
                f(t, function (t, i) {
                    for (var n = e[i] || (e[i] = []), o = 0; o < (t || []).length; o++) n.push(t[o])
                })
            }
        },
        original: {count: Js, getItem: Qs, appendData: tl},
        typedArray: {
            persistent: !1, pure: !0, count: function () {
                return this._data ? this._data.length / this._dimSize : 0
            }, getItem: function (t, e) {
                t -= this._offset, e = e || [];
                for (var i = this._dimSize * t, n = 0; n < this._dimSize; n++) e[n] = this._data[i + n];
                return e
            }, appendData: function (t) {
                BS && O(I(t), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = t
            }, clean: function () {
                this._offset += this.count(), this._data = null
            }
        }
    }, aC = {
        arrayRows: el, objectRows: function (t, e, i, n) {
            return null != i ? t[n] : t
        }, keyedColumns: el, original: function (t, e, i) {
            var n = no(t);
            return null != i && n instanceof Array ? n[i] : n
        }, typedArray: el
    }, rC = {
        arrayRows: il, objectRows: function (t, e) {
            return nl(t[e], this._dimensionInfos[e])
        }, keyedColumns: il, original: function (t, e, i, n) {
            var o = t && (null == t.value ? t : t.value);
            return !this._rawData.pure && oo(t) && (this.hasItemOption = !0), nl(o instanceof Array ? o[n] : o, this._dimensionInfos[e])
        }, typedArray: function (t, e, i, n) {
            return t[n]
        }
    }, sC = /\{@(.+?)\}/g, lC = {
        getDataParams: function (t, e) {
            var i = this.getData(e), n = this.getRawValue(t, e), o = i.getRawIndex(t), a = i.getName(t),
                r = i.getRawDataItem(t), s = i.getItemVisual(t, "color"), l = i.getItemVisual(t, "borderColor"),
                u = this.ecModel.getComponent("tooltip"), h = u && u.get("renderMode"), c = vo(h), d = this.mainType,
                f = "series" === d, p = i.userOutput;
            return {
                componentType: d,
                componentSubType: this.subType,
                componentIndex: this.componentIndex,
                seriesType: f ? this.subType : null,
                seriesIndex: this.seriesIndex,
                seriesId: f ? this.id : null,
                seriesName: f ? this.name : null,
                name: a,
                dataIndex: o,
                data: r,
                dataType: e,
                value: n,
                color: s,
                borderColor: l,
                dimensionNames: p ? p.dimensionNames : null,
                encode: p ? p.encode : null,
                marker: Xr({color: s, renderMode: c}),
                $vars: ["seriesName", "name", "value"]
            }
        }, getFormattedLabel: function (t, e, i, n, o) {
            e = e || "normal";
            var a = this.getData(i), r = a.getItemModel(t), s = this.getDataParams(t, i);
            null != n && s.value instanceof Array && (s.value = s.value[n]);
            var l = r.get("normal" === e ? [o || "label", "formatter"] : [e, o || "label", "formatter"]);
            if ("function" == typeof l) return s.status = e, s.dimensionIndex = n, l(s);
            if ("string" == typeof l) {
                var u = Zr(l, s);
                return u.replace(sC, function (e, i) {
                    var n = i.length;
                    return "[" === i.charAt(0) && "]" === i.charAt(n - 1) && (i = +i.slice(1, n - 1)), ol(a, t, i)
                })
            }
        }, getRawValue: function (t, e) {
            return ol(this.getData(e), t)
        }, formatTooltip: function () {
        }
    }, uC = sl.prototype;
    uC.perform = function (t) {
        function e(t) {
            return !(t >= 1) && (t = 1), t
        }

        var i = this._upstream, n = t && t.skip;
        if (this._dirty && i) {
            var o = this.context;
            o.data = o.outputData = i.context.outputData
        }
        this.__pipeline && (this.__pipeline.currentTask = this);
        var a;
        this._plan && !n && (a = this._plan(this.context));
        var r = e(this._modBy), s = this._modDataCount || 0, l = e(t && t.modBy), u = t && t.modDataCount || 0;
        (r !== l || s !== u) && (a = "reset");
        var h;
        (this._dirty || "reset" === a) && (this._dirty = !1, h = ul(this, n)), this._modBy = l, this._modDataCount = u;
        var c = t && t.step;
        if (i ? (BS && O(null != i._outputDueEnd), this._dueEnd = i._outputDueEnd) : (BS && O(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
            var d = this._dueIndex, f = Math.min(null != c ? this._dueIndex + c : 1 / 0, this._dueEnd);
            if (!n && (h || f > d)) {
                var p = this._progress;
                if (_(p)) for (var g = 0; g < p.length; g++) ll(this, p[g], d, f, l, u);
                else ll(this, p, d, f, l, u)
            }
            this._dueIndex = f;
            var m = null != this._settedOutputEnd ? this._settedOutputEnd : f;
            BS && O(m >= this._outputDueEnd), this._outputDueEnd = m
        } else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd;
        return this.unfinished()
    };
    var hC = function () {
        function t() {
            return i > n ? n++ : null
        }

        function e() {
            var t = n % r * o + Math.ceil(n / r), e = n >= i ? null : a > t ? t : n;
            return n++, e
        }

        var i, n, o, a, r, s = {
            reset: function (l, u, h, c) {
                n = l, i = u, o = h, a = c, r = Math.ceil(a / o), s.next = o > 1 && a > 0 ? e : t
            }
        };
        return s
    }();
    uC.dirty = function () {
        this._dirty = !0, this._onDirty && this._onDirty(this.context)
    }, uC.unfinished = function () {
        return this._progress && this._dueIndex < this._dueEnd
    }, uC.pipe = function (t) {
        BS && O(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty())
    }, uC.dispose = function () {
        this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0)
    }, uC.getUpstream = function () {
        return this._upstream
    }, uC.getDownstream = function () {
        return this._downstream
    }, uC.setOutputEnd = function (t) {
        this._outputDueEnd = this._settedOutputEnd = t
    };
    var cC = co(), dC = ID.extend({
        type: "series.__base__",
        seriesIndex: 0,
        coordinateSystem: null,
        defaultOption: null,
        legendVisualProvider: null,
        visualColorAccessPath: "itemStyle.color",
        visualBorderColorAccessPath: "itemStyle.borderColor",
        layoutMode: null,
        init: function (t, e, i) {
            this.seriesIndex = this.componentIndex, this.dataTask = rl({
                count: dl,
                reset: fl
            }), this.dataTask.context = {model: this}, this.mergeDefaultAndTheme(t, i), fs(this);
            var n = this.getInitialData(t, i);
            gl(n, this), this.dataTask.context.data = n, BS && O(n, "getInitialData returned invalid data."), cC(this).dataBeforeProcessed = n, hl(this)
        },
        mergeDefaultAndTheme: function (t, e) {
            var i = this.layoutMode, n = i ? as(t) : {}, a = this.subType;
            ID.hasClass(a) && (a += "Series"), o(t, e.getTheme().get(this.subType)), o(t, this.getDefaultOption()), io(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && os(t, n, i)
        },
        mergeOption: function (t, e) {
            t = o(this.option, t, !0), this.fillDataTextStyle(t.data);
            var i = this.layoutMode;
            i && os(this.option, t, i), fs(this);
            var n = this.getInitialData(t, e);
            gl(n, this), this.dataTask.dirty(), this.dataTask.context.data = n, cC(this).dataBeforeProcessed = n, hl(this)
        },
        fillDataTextStyle: function (t) {
            if (t && !I(t)) for (var e = ["show"], i = 0; i < t.length; i++) t[i] && t[i].label && io(t[i], "label", e)
        },
        getInitialData: function () {
        },
        appendData: function (t) {
            var e = this.getRawData();
            e.appendData(t.data)
        },
        getData: function (t) {
            var e = vl(this);
            if (e) {
                var i = e.context.data;
                return null == t ? i : i.getLinkedData(t)
            }
            return cC(this).data
        },
        setData: function (t) {
            var e = vl(this);
            if (e) {
                var i = e.context;
                i.data !== t && e.modifyOutputEnd && e.setOutputEnd(t.count()), i.outputData = t, e !== this.dataTask && (i.data = t)
            }
            cC(this).data = t
        },
        getSource: function () {
            return cs(this)
        },
        getRawData: function () {
            return cC(this).dataBeforeProcessed
        },
        getBaseAxis: function () {
            var t = this.coordinateSystem;
            return t && t.getBaseAxis && t.getBaseAxis()
        },
        formatTooltip: function (t, e, i, n) {
            function o(i) {
                function o(t, i) {
                    var o = c.getDimensionInfo(i);
                    if (o && o.otherDims.tooltip !== !1) {
                        var d = o.type, f = "sub" + r.seriesIndex + "at" + h,
                            p = Xr({color: y, type: "subItem", renderMode: n, markerId: f}),
                            g = "string" == typeof p ? p : p.content,
                            m = (a ? g + Hr(o.displayName || "-") + ": " : "") + Hr("ordinal" === d ? t + "" : "time" === d ? e ? "" : jr("yyyy/MM/dd hh:mm:ss", t) : Fr(t));
                        m && s.push(m), l && (u[f] = y, ++h)
                    }
                }

                var a = g(i, function (t, e, i) {
                    var n = c.getDimensionInfo(i);
                    return t |= n && n.tooltip !== !1 && null != n.displayName
                }, 0), s = [];
                d.length ? f(d, function (e) {
                    o(ol(c, t, e), e)
                }) : f(i, o);
                var p = a ? l ? "\n" : "<br/>" : "", m = p + s.join(p || ", ");
                return {renderMode: n, content: m, style: u}
            }

            function a(t) {
                return {renderMode: n, content: Hr(Fr(t)), style: u}
            }

            var r = this;
            n = n || "html";
            var s = "html" === n ? "<br/>" : "\n", l = "richText" === n, u = {}, h = 0, c = this.getData(),
                d = c.mapDimension("defaultedTooltip", !0), p = d.length, m = this.getRawValue(t), v = _(m),
                y = c.getItemVisual(t, "color");
            S(y) && y.colorStops && (y = (y.colorStops[0] || {}).color), y = y || "transparent";
            var x = p > 1 || v && !p ? o(m) : a(p ? ol(c, t, d[0]) : v ? m[0] : m), w = x.content,
                b = r.seriesIndex + "at" + h, M = Xr({color: y, type: "item", renderMode: n, markerId: b});
            u[b] = y, ++h;
            var I = c.getName(t), T = this.name;
            so(this) || (T = ""), T = T ? Hr(T) + (e ? ": " : s) : "";
            var A = "string" == typeof M ? M : M.content, D = e ? A + T + w : T + A + (I ? Hr(I) + ": " + w : w);
            return {html: D, markers: u}
        },
        isAnimationEnabled: function () {
            if (WS.node) return !1;
            var t = this.getShallow("animation");
            return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t
        },
        restoreData: function () {
            this.dataTask.dirty()
        },
        getColorFromPalette: function (t, e, i) {
            var n = this.ecModel, o = CD.getColorFromPalette.call(this, t, e, i);
            return o || (o = n.getColorFromPalette(t, e, i)), o
        },
        coordDimToDataDim: function (t) {
            return this.getRawData().mapDimension(t, !0)
        },
        getProgressive: function () {
            return this.get("progressive")
        },
        getProgressiveThreshold: function () {
            return this.get("progressiveThreshold")
        },
        getAxisTooltipData: null,
        getTooltipPosition: null,
        pipeTask: null,
        preventIncremental: null,
        pipelineContext: null
    });
    c(dC, lC), c(dC, CD);
    var fC = function () {
        this.group = new iI, this.uid = _r("viewComponent")
    };
    fC.prototype = {
        constructor: fC, init: function () {
        }, render: function () {
        }, dispose: function () {
        }, filterForExposedEvent: null
    };
    var pC = fC.prototype;
    pC.updateView = pC.updateLayout = pC.updateVisual = function () {
    }, wo(fC), Io(fC, {registerWhenExtend: !0});
    var gC = function () {
        var t = co();
        return function (e) {
            var i = t(e), n = e.pipelineContext, o = i.large, a = i.progressiveRender, r = i.large = n && n.large,
                s = i.progressiveRender = n && n.progressiveRender;
            return !!(o ^ r || a ^ s) && "reset"
        }
    }, mC = co(), vC = gC();
    yl.prototype = {
        type: "chart", init: function () {
        }, render: function () {
        }, highlight: function (t, e, i, n) {
            _l(t.getData(), n, "emphasis")
        }, downplay: function (t, e, i, n) {
            _l(t.getData(), n, "normal")
        }, remove: function () {
            this.group.removeAll()
        }, dispose: function () {
        }, incrementalPrepareRender: null, incrementalRender: null, updateTransform: null, filterForExposedEvent: null
    };
    var yC = yl.prototype;
    yC.updateView = yC.updateLayout = yC.updateVisual = function (t, e, i, n) {
        this.render(t, e, i, n)
    }, wo(yl, ["dispose"]), Io(yl, {registerWhenExtend: !0}), yl.markUpdateMethod = function (t, e) {
        mC(t).updateMethod = e
    };
    var xC = {
        incrementalPrepareRender: {
            progress: function (t, e) {
                e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload)
            }
        }, render: {
            forceFirstProgress: !0, progress: function (t, e) {
                e.view.render(e.model, e.ecModel, e.api, e.payload)
            }
        }
    }, _C = "\x00__throttleOriginMethod", wC = "\x00__throttleRate", bC = "\x00__throttleType", SC = {
        createOnAllSeries: !0, performRawSeries: !0, reset: function (t, e) {
            var i = t.getData(), n = (t.visualColorAccessPath || "itemStyle.color").split("."), o = t.get(n),
                a = !w(o) || o instanceof RA ? null : o;
            (!o || a) && (o = t.getColorFromPalette(t.name, null, e.getSeriesCount())), i.setVisual("color", o);
            var r = (t.visualBorderColorAccessPath || "itemStyle.borderColor").split("."), s = t.get(r);
            if (i.setVisual("borderColor", s), !e.isSeriesFiltered(t)) {
                a && i.each(function (e) {
                    i.setItemVisual(e, "color", a(t.getDataParams(e)))
                });
                var l = function (t, e) {
                    var i = t.getItemModel(e), o = i.get(n, !0), a = i.get(r, !0);
                    null != o && t.setItemVisual(e, "color", o), null != a && t.setItemVisual(e, "borderColor", a)
                };
                return {dataEach: i.hasItemOption ? l : null}
            }
        }
    }, MC = {
        legend: {selector: {all: "全选", inverse: "反选"}},
        toolbox: {
            brush: {
                title: {
                    rect: "矩形选择",
                    polygon: "圈选",
                    lineX: "横向选择",
                    lineY: "纵向选择",
                    keep: "保持选择",
                    clear: "清除选择"
                }
            },
            dataView: {title: "数据视图", lang: ["数据视图", "关闭", "刷新"]},
            dataZoom: {title: {zoom: "区域缩放", back: "区域缩放还原"}},
            magicType: {title: {line: "切换为折线图", bar: "切换为柱状图", stack: "切换为堆叠", tiled: "切换为平铺"}},
            restore: {title: "还原"},
            saveAsImage: {title: "保存为图片", lang: ["右键另存为图片"]}
        },
        series: {
            typeNames: {
                pie: "饼图",
                bar: "柱状图",
                line: "折线图",
                scatter: "散点图",
                effectScatter: "涟漪散点图",
                radar: "雷达图",
                tree: "树图",
                treemap: "矩形树图",
                boxplot: "箱型图",
                candlestick: "K线图",
                k: "K线图",
                heatmap: "热力图",
                map: "地图",
                parallel: "平行坐标图",
                lines: "线图",
                graph: "关系图",
                sankey: "桑基图",
                funnel: "漏斗图",
                gauge: "仪表盘图",
                pictorialBar: "象形柱图",
                themeRiver: "主题河流图",
                sunburst: "旭日图"
            }
        },
        aria: {
            general: {withTitle: "这是一个关于“{title}”的图表。", withoutTitle: "这是一个图表，"},
            series: {
                single: {
                    prefix: "",
                    withName: "图表类型是{seriesType}，表示{seriesName}。",
                    withoutName: "图表类型是{seriesType}。"
                },
                multiple: {
                    prefix: "它由{seriesCount}个图表系列组成。",
                    withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
                    withoutName: "第{seriesId}个系列是一个{seriesType}，",
                    separator: {middle: "；", end: "。"}
                }
            },
            data: {
                allData: "其数据是——",
                partialData: "其中，前{displayCnt}项是——",
                withName: "{name}的数据是{value}",
                withoutName: "{value}",
                separator: {middle: "，", end: ""}
            }
        }
    }, IC = function (t, e) {
        function i(t, e) {
            if ("string" != typeof t) return t;
            var i = t;
            return f(e, function (t, e) {
                i = i.replace(new RegExp("\\{\\s*" + e + "\\s*\\}", "g"), t)
            }), i
        }

        function n(t) {
            var e = r.get(t);
            if (null == e) {
                for (var i = t.split("."), n = MC.aria, o = 0; o < i.length; ++o) n = n[i[o]];
                return n
            }
            return e
        }

        function o() {
            var t = e.getModel("title").option;
            return t && t.length && (t = t[0]), t && t.text
        }

        function a(t) {
            return MC.series.typeNames[t] || "自定义图"
        }

        var r = e.getModel("aria");
        if (r.get("show")) {
            if (r.get("description")) return void t.setAttribute("aria-label", r.get("description"));
            var s = 0;
            e.eachSeries(function () {
                ++s
            }, this);
            var l, u = r.get("data.maxCount") || 10, h = r.get("series.maxCount") || 10, c = Math.min(s, h);
            if (!(1 > s)) {
                var d = o();
                l = d ? i(n("general.withTitle"), {title: d}) : n("general.withoutTitle");
                var p = [], g = s > 1 ? "series.multiple.prefix" : "series.single.prefix";
                l += i(n(g), {seriesCount: s}), e.eachSeries(function (t, e) {
                    if (c > e) {
                        var o, r = t.get("name"), l = "series." + (s > 1 ? "multiple" : "single") + ".";
                        o = n(r ? l + "withName" : l + "withoutName"), o = i(o, {
                            seriesId: t.seriesIndex,
                            seriesName: t.get("name"),
                            seriesType: a(t.subType)
                        });
                        var h = t.getData();
                        window.data = h, o += h.count() > u ? i(n("data.partialData"), {displayCnt: u}) : n("data.allData");
                        for (var d = [], f = 0; f < h.count(); f++) if (u > f) {
                            var g = h.getName(f), m = ol(h, f);
                            d.push(i(n(g ? "data.withName" : "data.withoutName"), {name: g, value: m}))
                        }
                        o += d.join(n("data.separator.middle")) + n("data.separator.end"), p.push(o)
                    }
                }), l += p.join(n("series.multiple.separator.middle")) + n("series.multiple.separator.end"), t.setAttribute("aria-label", l)
            }
        }
    }, TC = Math.PI, AC = function (t, e) {
        e = e || {}, s(e, {
            text: "loading",
            textColor: "#000",
            fontSize: "12px",
            maskColor: "rgba(255, 255, 255, 0.8)",
            showSpinner: !0,
            color: "#c23531",
            spinnerRadius: 10,
            lineWidth: 5,
            zlevel: 0
        });
        var i = new iI, n = new CA({style: {fill: e.maskColor}, zlevel: e.zlevel, z: 1e4});
        i.add(n);
        var o = e.fontSize + " sans-serif", a = new CA({
            style: {
                fill: "none",
                text: e.text,
                font: o,
                textPosition: "right",
                textDistance: 10,
                textFill: e.textColor
            }, zlevel: e.zlevel, z: 10001
        });
        if (i.add(a), e.showSpinner) {
            var r = new EA({
                shape: {startAngle: -TC / 2, endAngle: -TC / 2 + .1, r: e.spinnerRadius},
                style: {stroke: e.color, lineCap: "round", lineWidth: e.lineWidth},
                zlevel: e.zlevel,
                z: 10001
            });
            r.animateShape(!0).when(1e3, {endAngle: 3 * TC / 2}).start("circularInOut"), r.animateShape(!0).when(1e3, {startAngle: 3 * TC / 2}).delay(300).start("circularInOut"), i.add(r)
        }
        return i.resize = function () {
            var i = Ui(e.text, o), s = e.showSpinner ? e.spinnerRadius : 0,
                l = (t.getWidth() - 2 * s - (e.showSpinner && i ? 10 : 0) - i) / 2 - (e.showSpinner ? 0 : i / 2),
                u = t.getHeight() / 2;
            e.showSpinner && r.setShape({cx: l, cy: u}), a.setShape({
                x: l - s,
                y: u - s,
                width: 2 * s,
                height: 2 * s
            }), n.setShape({x: 0, y: 0, width: t.getWidth(), height: t.getHeight()})
        }, i.resize(), i
    }, DC = Tl.prototype;
    DC.restoreData = function (t, e) {
        t.restoreData(e), this._stageTaskMap.each(function (t) {
            var e = t.overallTask;
            e && e.dirty()
        })
    }, DC.getPerformArgs = function (t, e) {
        if (t.__pipeline) {
            var i = this._pipelineMap.get(t.__pipeline.id), n = i.context,
                o = !e && i.progressiveEnabled && (!n || n.progressiveRender) && t.__idxInPipeline > i.blockIndex,
                a = o ? i.step : null, r = n && n.modDataCount, s = null != r ? Math.ceil(r / a) : null;
            return {step: a, modBy: s, modDataCount: r}
        }
    }, DC.getPipeline = function (t) {
        return this._pipelineMap.get(t)
    }, DC.updateStreamModes = function (t, e) {
        var i = this._pipelineMap.get(t.uid), n = t.getData(), o = n.count(),
            a = i.progressiveEnabled && e.incrementalPrepareRender && o >= i.threshold,
            r = t.get("large") && o >= t.get("largeThreshold"), s = "mod" === t.get("progressiveChunkMode") ? o : null;
        t.pipelineContext = i.context = {progressiveRender: a, modDataCount: s, large: r}
    }, DC.restorePipelines = function (t) {
        var e = this, i = e._pipelineMap = B();
        t.eachSeries(function (t) {
            var n = t.getProgressive(), o = t.uid;
            i.set(o, {
                id: o,
                head: null,
                tail: null,
                threshold: t.getProgressiveThreshold(),
                progressiveEnabled: n && !(t.preventIncremental && t.preventIncremental()),
                blockIndex: -1,
                step: Math.round(n || 700),
                count: 0
            }), Bl(e, t, t.dataTask)
        })
    }, DC.prepareStageTasks = function () {
        var t = this._stageTaskMap, e = this.ecInstance.getModel(), i = this.api;
        f(this._allHandlers, function (n) {
            var o = t.get(n.uid) || t.set(n.uid, []);
            n.reset && Dl(this, n, o, e, i), n.overallReset && Cl(this, n, o, e, i)
        }, this)
    }, DC.prepareView = function (t, e, i, n) {
        var o = t.renderTask, a = o.context;
        a.model = e, a.ecModel = i, a.api = n, o.__block = !t.incrementalPrepareRender, Bl(this, e, o)
    }, DC.performDataProcessorTasks = function (t, e) {
        Al(this, this._dataProcessorHandlers, t, e, {block: !0})
    }, DC.performVisualTasks = function (t, e, i) {
        Al(this, this._visualHandlers, t, e, i)
    }, DC.performSeriesTasks = function (t) {
        var e;
        t.eachSeries(function (t) {
            e |= t.dataTask.perform()
        }), this.unfinished |= e
    }, DC.plan = function () {
        this._pipelineMap.each(function (t) {
            var e = t.tail;
            do {
                if (e.__block) {
                    t.blockIndex = e.__idxInPipeline;
                    break
                }
                e = e.getUpstream()
            } while (e)
        })
    };
    var CC = DC.updatePayload = function (t, e) {
        "remain" !== e && (t.context.payload = e)
    }, LC = Rl(0);
    Tl.wrapStageHandler = function (t, e) {
        return w(t) && (t = {
            overallReset: t,
            seriesType: Vl(t)
        }), t.uid = _r("stageHandler"), e && (t.visualType = e), t
    };
    var kC, PC = {}, OC = {};
    Gl(PC, FD), Gl(OC, ks), PC.eachSeriesByType = PC.eachRawSeriesByType = function (t) {
        kC = t
    }, PC.eachComponent = function (t) {
        "series" === t.mainType && t.subType && (kC = t.subType)
    };
    var EC = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"],
        NC = {
            color: EC,
            colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], EC]
        }, RC = "#eee", zC = function () {
            return {
                axisLine: {lineStyle: {color: RC}},
                axisTick: {lineStyle: {color: RC}},
                axisLabel: {textStyle: {color: RC}},
                splitLine: {lineStyle: {type: "dashed", color: "#aaa"}},
                splitArea: {areaStyle: {color: RC}}
            }
        },
        BC = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"],
        VC = {
            color: BC,
            backgroundColor: "#333",
            tooltip: {axisPointer: {lineStyle: {color: RC}, crossStyle: {color: RC}, label: {color: "#000"}}},
            legend: {textStyle: {color: RC}},
            textStyle: {color: RC},
            title: {textStyle: {color: RC}},
            toolbox: {iconStyle: {normal: {borderColor: RC}}},
            dataZoom: {textStyle: {color: RC}},
            visualMap: {textStyle: {color: RC}},
            timeline: {
                lineStyle: {color: RC},
                itemStyle: {normal: {color: BC[1]}},
                label: {normal: {textStyle: {color: RC}}},
                controlStyle: {normal: {color: RC, borderColor: RC}}
            },
            timeAxis: zC(),
            logAxis: zC(),
            valueAxis: zC(),
            categoryAxis: zC(),
            line: {symbol: "circle"},
            graph: {color: BC},
            gauge: {title: {textStyle: {color: RC}}},
            candlestick: {
                itemStyle: {
                    normal: {
                        color: "#FD1050",
                        color0: "#0CF49B",
                        borderColor: "#FD1050",
                        borderColor0: "#0CF49B"
                    }
                }
            }
        };
    VC.categoryAxis.splitLine.show = !1, ID.extend({
        type: "dataset",
        defaultOption: {seriesLayoutBy: RD, sourceHeader: null, dimensions: null, source: null},
        optionUpdated: function () {
            hs(this)
        }
    }), fC.extend({type: "dataset"});
    var GC = aa.extend({
        type: "ellipse", shape: {cx: 0, cy: 0, rx: 0, ry: 0}, buildPath: function (t, e) {
            var i = .5522848, n = e.cx, o = e.cy, a = e.rx, r = e.ry, s = a * i, l = r * i;
            t.moveTo(n - a, o), t.bezierCurveTo(n - a, o - l, n - s, o - r, n, o - r), t.bezierCurveTo(n + s, o - r, n + a, o - l, n + a, o), t.bezierCurveTo(n + a, o + l, n + s, o + r, n, o + r), t.bezierCurveTo(n - s, o + r, n - a, o + l, n - a, o), t.closePath()
        }
    }), FC = /[\s,]+/;
    Wl.prototype.parse = function (t, e) {
        e = e || {};
        var i = Fl(t);
        if (!i) throw new Error("Illegal svg");
        var n = new iI;
        this._root = n;
        var o = i.getAttribute("viewBox") || "", a = parseFloat(i.getAttribute("width") || e.width),
            r = parseFloat(i.getAttribute("height") || e.height);
        isNaN(a) && (a = null), isNaN(r) && (r = null), Xl(i, n, null, !0);
        for (var s = i.firstChild; s;) this._parseNode(s, n), s = s.nextSibling;
        var l, u;
        if (o) {
            var h = E(o).split(FC);
            h.length >= 4 && (l = {
                x: parseFloat(h[0] || 0),
                y: parseFloat(h[1] || 0),
                width: parseFloat(h[2]),
                height: parseFloat(h[3])
            })
        }
        if (l && null != a && null != r && (u = Kl(l, a, r), !e.ignoreViewBox)) {
            var c = n;
            n = new iI, n.add(c), c.scale = u.scale.slice(), c.position = u.position.slice()
        }
        return e.ignoreRootClip || null == a || null == r || n.setClipPath(new CA({
            shape: {
                x: 0,
                y: 0,
                width: a,
                height: r
            }
        })), {root: n, width: a, height: r, viewBoxRect: l, viewBoxTransform: u}
    }, Wl.prototype._parseNode = function (t, e) {
        var i = t.nodeName.toLowerCase();
        "defs" === i ? this._isDefine = !0 : "text" === i && (this._isText = !0);
        var n;
        if (this._isDefine) {
            var o = HC[i];
            if (o) {
                var a = o.call(this, t), r = t.getAttribute("id");
                r && (this._defs[r] = a)
            }
        } else {
            var o = WC[i];
            o && (n = o.call(this, t, e), e.add(n))
        }
        for (var s = t.firstChild; s;) 1 === s.nodeType && this._parseNode(s, n), 3 === s.nodeType && this._isText && this._parseText(s, n), s = s.nextSibling;
        "defs" === i ? this._isDefine = !1 : "text" === i && (this._isText = !1)
    }, Wl.prototype._parseText = function (t, e) {
        if (1 === t.nodeType) {
            var i = t.getAttribute("dx") || 0, n = t.getAttribute("dy") || 0;
            this._textX += parseFloat(i), this._textY += parseFloat(n)
        }
        var o = new vA({
            style: {text: t.textContent, transformText: !0},
            position: [this._textX || 0, this._textY || 0]
        });
        Zl(e, o), Xl(t, o, this._defs);
        var a = o.style.fontSize;
        a && 9 > a && (o.style.fontSize = 9, o.scale = o.scale || [1, 1], o.scale[0] *= a / 9, o.scale[1] *= a / 9);
        var r = o.getBoundingRect();
        return this._textX += r.width, e.add(o), o
    };
    var WC = {
            g: function (t, e) {
                var i = new iI;
                return Zl(e, i), Xl(t, i, this._defs), i
            }, rect: function (t, e) {
                var i = new CA;
                return Zl(e, i), Xl(t, i, this._defs), i.setShape({
                    x: parseFloat(t.getAttribute("x") || 0),
                    y: parseFloat(t.getAttribute("y") || 0),
                    width: parseFloat(t.getAttribute("width") || 0),
                    height: parseFloat(t.getAttribute("height") || 0)
                }), i
            }, circle: function (t, e) {
                var i = new yA;
                return Zl(e, i), Xl(t, i, this._defs), i.setShape({
                    cx: parseFloat(t.getAttribute("cx") || 0),
                    cy: parseFloat(t.getAttribute("cy") || 0),
                    r: parseFloat(t.getAttribute("r") || 0)
                }), i
            }, line: function (t, e) {
                var i = new kA;
                return Zl(e, i), Xl(t, i, this._defs), i.setShape({
                    x1: parseFloat(t.getAttribute("x1") || 0),
                    y1: parseFloat(t.getAttribute("y1") || 0),
                    x2: parseFloat(t.getAttribute("x2") || 0),
                    y2: parseFloat(t.getAttribute("y2") || 0)
                }), i
            }, ellipse: function (t, e) {
                var i = new GC;
                return Zl(e, i), Xl(t, i, this._defs), i.setShape({
                    cx: parseFloat(t.getAttribute("cx") || 0),
                    cy: parseFloat(t.getAttribute("cy") || 0),
                    rx: parseFloat(t.getAttribute("rx") || 0),
                    ry: parseFloat(t.getAttribute("ry") || 0)
                }), i
            }, polygon: function (t, e) {
                var i = t.getAttribute("points");
                i && (i = Ul(i));
                var n = new IA({shape: {points: i || []}});
                return Zl(e, n), Xl(t, n, this._defs), n
            }, polyline: function (t, e) {
                var i = new aa;
                Zl(e, i), Xl(t, i, this._defs);
                var n = t.getAttribute("points");
                n && (n = Ul(n));
                var o = new TA({shape: {points: n || []}});
                return o
            }, image: function (t, e) {
                var i = new Cn;
                return Zl(e, i), Xl(t, i, this._defs), i.setStyle({
                    image: t.getAttribute("xlink:href"),
                    x: t.getAttribute("x"),
                    y: t.getAttribute("y"),
                    width: t.getAttribute("width"),
                    height: t.getAttribute("height")
                }), i
            }, text: function (t, e) {
                var i = t.getAttribute("x") || 0, n = t.getAttribute("y") || 0, o = t.getAttribute("dx") || 0,
                    a = t.getAttribute("dy") || 0;
                this._textX = parseFloat(i) + parseFloat(o), this._textY = parseFloat(n) + parseFloat(a);
                var r = new iI;
                return Zl(e, r), Xl(t, r, this._defs), r
            }, tspan: function (t, e) {
                var i = t.getAttribute("x"), n = t.getAttribute("y");
                null != i && (this._textX = parseFloat(i)), null != n && (this._textY = parseFloat(n));
                var o = t.getAttribute("dx") || 0, a = t.getAttribute("dy") || 0, r = new iI;
                return Zl(e, r), Xl(t, r, this._defs), this._textX += o, this._textY += a, r
            }, path: function (t, e) {
                var i = t.getAttribute("d") || "", n = ua(i);
                return Zl(e, n), Xl(t, n, this._defs), n
            }
        }, HC = {
            lineargradient: function (t) {
                var e = parseInt(t.getAttribute("x1") || 0, 10), i = parseInt(t.getAttribute("y1") || 0, 10),
                    n = parseInt(t.getAttribute("x2") || 10, 10), o = parseInt(t.getAttribute("y2") || 0, 10),
                    a = new zA(e, i, n, o);
                return Hl(t, a), a
            }, radialgradient: function () {
            }
        }, ZC = {
            fill: "fill",
            stroke: "stroke",
            "stroke-width": "lineWidth",
            opacity: "opacity",
            "fill-opacity": "fillOpacity",
            "stroke-opacity": "strokeOpacity",
            "stroke-dasharray": "lineDash",
            "stroke-dashoffset": "lineDashOffset",
            "stroke-linecap": "lineCap",
            "stroke-linejoin": "lineJoin",
            "stroke-miterlimit": "miterLimit",
            "font-family": "fontFamily",
            "font-size": "fontSize",
            "font-style": "fontStyle",
            "font-weight": "fontWeight",
            "text-align": "textAlign",
            "alignment-baseline": "textBaseline"
        }, UC = /url\(\s*#(.*?)\)/, XC = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g,
        YC = /([^\s:;]+)\s*:\s*([^:;]+)/g, jC = B(), qC = {
            registerMap: function (t, e, i) {
                var n;
                return _(e) ? n = e : e.svg ? n = [{
                    type: "svg",
                    source: e.svg,
                    specialAreas: e.specialAreas
                }] : (e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), n = [{
                    type: "geoJSON",
                    source: e,
                    specialAreas: i
                }]), f(n, function (t) {
                    var e = t.type;
                    "geoJson" === e && (e = t.type = "geoJSON");
                    var i = KC[e];
                    BS && O(i, "Illegal map type: " + e), i(t)
                }), jC.set(t, n)
            }, retrieveMap: function (t) {
                return jC.get(t)
            }
        }, KC = {
            geoJSON: function (t) {
                var e = t.source;
                t.geoJSON = b(e) ? "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")() : e
            }, svg: function (t) {
                t.svgXML = Fl(t.source)
            }
        }, $C = O, JC = f, QC = w, tL = S, eL = ID.parseClassType, iL = "4.9.0", nL = {zrender: "4.3.2"}, oL = 1, aL = 1e3,
        rL = 800, sL = 900, lL = 5e3, uL = 1e3, hL = 1100, cL = 2e3, dL = 3e3, fL = 3500, pL = 4e3, gL = 5e3, mL = {
            PROCESSOR: {FILTER: aL, SERIES_FILTER: rL, STATISTIC: lL},
            VISUAL: {
                LAYOUT: uL,
                PROGRESSIVE_LAYOUT: hL,
                GLOBAL: cL,
                CHART: dL,
                POST_CHART_LAYOUT: fL,
                COMPONENT: pL,
                BRUSH: gL
            }
        }, vL = "__flagInMainProcess", yL = "__optionUpdated", xL = /^[a-zA-Z0-9_]+$/;
    Ql.prototype.on = Jl("on", !0), Ql.prototype.off = Jl("off", !0), Ql.prototype.one = Jl("one", !0), c(Ql, hM);
    var _L = tu.prototype;
    _L._onframe = function () {
        if (!this._disposed) {
            var t = this._scheduler;
            if (this[yL]) {
                var e = this[yL].silent;
                this[vL] = !0, iu(this), wL.update.call(this), this[vL] = !1, this[yL] = !1, ru.call(this, e), su.call(this, e)
            } else if (t.unfinished) {
                var i = oL, n = this._model, o = this._api;
                t.unfinished = !1;
                do {
                    var a = +new Date;
                    t.performSeriesTasks(n), t.performDataProcessorTasks(n), ou(this, n), t.performVisualTasks(n), fu(this, this._model, o, "remain"), i -= +new Date - a
                } while (i > 0 && t.unfinished);
                t.unfinished || this._zr.flush()
            }
        }
    }, _L.getDom = function () {
        return this._dom
    }, _L.getZr = function () {
        return this._zr
    }, _L.setOption = function (t, e, i) {
        if (BS && $C(!this[vL], "`setOption` should not be called during main process."), this._disposed) return void gu(this.id);
        var n;
        if (tL(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[vL] = !0, !this._model || e) {
            var o = new Os(this._api), a = this._theme, r = this._model = new FD;
            r.scheduler = this._scheduler, r.init(null, null, a, o)
        }
        this._model.setOption(t, TL), i ? (this[yL] = {silent: n}, this[vL] = !1) : (iu(this), wL.update.call(this), this._zr.flush(), this[yL] = !1, this[vL] = !1, ru.call(this, n), su.call(this, n))
    }, _L.setTheme = function () {
        console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
    }, _L.getModel = function () {
        return this._model
    }, _L.getOption = function () {
        return this._model && this._model.getOption()
    }, _L.getWidth = function () {
        return this._zr.getWidth()
    }, _L.getHeight = function () {
        return this._zr.getHeight()
    }, _L.getDevicePixelRatio = function () {
        return this._zr.painter.dpr || window.devicePixelRatio || 1
    }, _L.getRenderedCanvas = function (t) {
        if (WS.canvasSupported) {
            t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
            var e = this._zr;
            return e.painter.getRenderedCanvas(t)
        }
    }, _L.getSvgDataURL = function () {
        if (WS.svgSupported) {
            var t = this._zr, e = t.storage.getDisplayList();
            return f(e, function (t) {
                t.stopAnimation(!0)
            }), t.painter.toDataURL()
        }
    }, _L.getDataURL = function (t) {
        if (this._disposed) return void gu(this.id);
        t = t || {};
        var e = t.excludeComponents, i = this._model, n = [], o = this;
        JC(e, function (t) {
            i.eachComponent({mainType: t}, function (t) {
                var e = o._componentsMap[t.__viewId];
                e.group.ignore || (n.push(e), e.group.ignore = !0)
            })
        });
        var a = "svg" === this._zr.painter.getType() ? this.getSvgDataURL() : this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
        return JC(n, function (t) {
            t.group.ignore = !1
        }), a
    }, _L.getConnectedDataURL = function (t) {
        if (this._disposed) return void gu(this.id);
        if (WS.canvasSupported) {
            var e = "svg" === t.type, i = this.group, o = Math.min, a = Math.max, r = 1 / 0;
            if (PL[i]) {
                var s = r, l = r, u = -r, h = -r, c = [], d = t && t.pixelRatio || 1;
                f(kL, function (r) {
                    if (r.group === i) {
                        var d = e ? r.getZr().painter.getSvgDom().innerHTML : r.getRenderedCanvas(n(t)),
                            f = r.getDom().getBoundingClientRect();
                        s = o(f.left, s), l = o(f.top, l), u = a(f.right, u), h = a(f.bottom, h), c.push({
                            dom: d,
                            left: f.left,
                            top: f.top
                        })
                    }
                }), s *= d, l *= d, u *= d, h *= d;
                var p = u - s, g = h - l, m = QS(), v = Kn(m, {renderer: e ? "svg" : "canvas"});
                if (v.resize({width: p, height: g}), e) {
                    var y = "";
                    return JC(c, function (t) {
                        var e = t.left - s, i = t.top - l;
                        y += '<g transform="translate(' + e + "," + i + ')">' + t.dom + "</g>"
                    }), v.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && v.painter.setBackgroundColor(t.connectedBackgroundColor), v.refreshImmediately(), v.painter.toDataURL()
                }
                return t.connectedBackgroundColor && v.add(new CA({
                    shape: {x: 0, y: 0, width: p, height: g},
                    style: {fill: t.connectedBackgroundColor}
                })), JC(c, function (t) {
                    var e = new Cn({style: {x: t.left * d - s, y: t.top * d - l, image: t.dom}});
                    v.add(e)
                }), v.refreshImmediately(), m.toDataURL("image/" + (t && t.type || "png"))
            }
            return this.getDataURL(t)
        }
    }, _L.convertToPixel = x(eu, "convertToPixel"), _L.convertFromPixel = x(eu, "convertFromPixel"), _L.containPixel = function (t, e) {
        if (this._disposed) return void gu(this.id);
        var i, n = this._model;
        return t = fo(n, t), f(t, function (t, n) {
            n.indexOf("Models") >= 0 && f(t, function (t) {
                var o = t.coordinateSystem;
                if (o && o.containPoint) i |= !!o.containPoint(e); else if ("seriesModels" === n) {
                    var a = this._chartsMap[t.__viewId];
                    a && a.containPoint ? i |= a.containPoint(e, t) : BS && console.warn(n + ": " + (a ? "The found component do not support containPoint." : "No view mapping to the found component."))
                } else BS && console.warn(n + ": containPoint is not supported")
            }, this)
        }, this), !!i
    }, _L.getVisual = function (t, e) {
        var i = this._model;
        t = fo(i, t, {defaultMainType: "series"});
        var n = t.seriesModel;
        BS && (n || console.warn("There is no specified seires model"));
        var o = n.getData(),
            a = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? o.indexOfRawIndex(t.dataIndex) : null;
        return null != a ? o.getItemVisual(a, e) : o.getVisual(e)
    }, _L.getViewOfComponentModel = function (t) {
        return this._componentsMap[t.__viewId]
    }, _L.getViewOfSeriesModel = function (t) {
        return this._chartsMap[t.__viewId]
    };
    var wL = {
        prepareAndUpdate: function (t) {
            iu(this), wL.update.call(this, t)
        }, update: function (t) {
            var e = this._model, i = this._api, n = this._zr, o = this._coordSysMgr, a = this._scheduler;
            if (e) {
                a.restoreData(e, t), a.performSeriesTasks(e), o.create(e, i), a.performDataProcessorTasks(e, t), ou(this, e), o.update(e, i), hu(e), a.performVisualTasks(e, t), cu(this, e, i, t);
                var r = e.get("backgroundColor") || "transparent";
                if (WS.canvasSupported) n.setBackgroundColor(r); else {
                    var s = ti(r);
                    r = ui(s, "rgb"), 0 === s[3] && (r = "transparent")
                }
                pu(e, i)
            }
        }, updateTransform: function (t) {
            var e = this._model, i = this, n = this._api;
            if (e) {
                var o = [];
                e.eachComponent(function (a, r) {
                    var s = i.getViewOfComponentModel(r);
                    if (s && s.__alive) if (s.updateTransform) {
                        var l = s.updateTransform(r, e, n, t);
                        l && l.update && o.push(s)
                    } else o.push(s)
                });
                var a = B();
                e.eachSeries(function (o) {
                    var r = i._chartsMap[o.__viewId];
                    if (r.updateTransform) {
                        var s = r.updateTransform(o, e, n, t);
                        s && s.update && a.set(o.uid, 1)
                    } else a.set(o.uid, 1)
                }), hu(e), this._scheduler.performVisualTasks(e, t, {
                    setDirty: !0,
                    dirtyMap: a
                }), fu(i, e, n, t, a), pu(e, this._api)
            }
        }, updateView: function (t) {
            var e = this._model;
            e && (yl.markUpdateMethod(t, "updateView"), hu(e), this._scheduler.performVisualTasks(e, t, {setDirty: !0}), cu(this, this._model, this._api, t), pu(e, this._api))
        }, updateVisual: function (t) {
            wL.update.call(this, t)
        }, updateLayout: function (t) {
            wL.update.call(this, t)
        }
    };
    _L.resize = function (t) {
        if (BS && $C(!this[vL], "`resize` should not be called during main process."), this._disposed) return void gu(this.id);
        this._zr.resize(t);
        var e = this._model;
        if (this._loadingFX && this._loadingFX.resize(), e) {
            var i = e.resetOption("media"), n = t && t.silent;
            this[vL] = !0, i && iu(this), wL.update.call(this), this[vL] = !1, ru.call(this, n), su.call(this, n)
        }
    }, _L.showLoading = function (t, e) {
        if (this._disposed) return void gu(this.id);
        if (tL(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), !LL[t]) return void (BS && console.warn("Loading effects " + t + " not exists."));
        var i = LL[t](this._api, e), n = this._zr;
        this._loadingFX = i, n.add(i)
    }, _L.hideLoading = function () {
        return this._disposed ? void gu(this.id) : (this._loadingFX && this._zr.remove(this._loadingFX), void (this._loadingFX = null))
    }, _L.makeActionFromEvent = function (t) {
        var e = r({}, t);
        return e.type = ML[t.type], e
    }, _L.dispatchAction = function (t, e) {
        if (this._disposed) return void gu(this.id);
        if (tL(e) || (e = {silent: !!e}), SL[t.type] && this._model) {
            if (this[vL]) return void this._pendingActions.push(t);
            au.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : e.flush !== !1 && WS.browser.weChat && this._throttledZrFlush(), ru.call(this, e.silent), su.call(this, e.silent)
        }
    }, _L.appendData = function (t) {
        if (this._disposed) return void gu(this.id);
        var e = t.seriesIndex, i = this.getModel(), n = i.getSeriesByIndex(e);
        BS && $C(t.data && n), n.appendData(t), this._scheduler.unfinished = !0
    }, _L.on = Jl("on", !1), _L.off = Jl("off", !1), _L.one = Jl("one", !1);
    var bL = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
    _L._initEvents = function () {
        JC(bL, function (t) {
            var e = function (e) {
                var i, n = this.getModel(), o = e.target, a = "globalout" === t;
                if (a) i = {}; else if (o && null != o.dataIndex) {
                    var s = o.dataModel || n.getSeriesByIndex(o.seriesIndex);
                    i = s && s.getDataParams(o.dataIndex, o.dataType, o) || {}
                } else o && o.eventData && (i = r({}, o.eventData));
                if (i) {
                    var l = i.componentType, u = i.componentIndex;
                    ("markLine" === l || "markPoint" === l || "markArea" === l) && (l = "series", u = i.seriesIndex);
                    var h = l && null != u && n.getComponent(l, u),
                        c = h && this["series" === h.mainType ? "_chartsMap" : "_componentsMap"][h.__viewId];
                    BS && (a || h && c || console.warn("model or view can not be found by params")), i.event = e, i.type = t, this._ecEventProcessor.eventInfo = {
                        targetEl: o,
                        packedEvent: i,
                        model: h,
                        view: c
                    }, this.trigger(t, i)
                }
            };
            e.zrEventfulCallAtLast = !0, this._zr.on(t, e, this)
        }, this), JC(ML, function (t, e) {
            this._messageCenter.on(e, function (t) {
                this.trigger(e, t)
            }, this)
        }, this)
    }, _L.isDisposed = function () {
        return this._disposed
    }, _L.clear = function () {
        return this._disposed ? void gu(this.id) : void this.setOption({series: []}, !0)
    }, _L.dispose = function () {
        if (this._disposed) return void gu(this.id);
        this._disposed = !0, go(this.getDom(), NL, "");
        var t = this._api, e = this._model;
        JC(this._componentsViews, function (i) {
            i.dispose(e, t)
        }), JC(this._chartsViews, function (i) {
            i.dispose(e, t)
        }), this._zr.dispose(), delete kL[this.id]
    }, c(tu, hM), _u.prototype = {
        constructor: _u, normalizeQuery: function (t) {
            var e = {}, i = {}, n = {};
            if (b(t)) {
                var o = eL(t);
                e.mainType = o.main || null, e.subType = o.sub || null
            } else {
                var a = ["Index", "Name", "Id"], r = {name: 1, dataIndex: 1, dataType: 1};
                f(t, function (t, o) {
                    for (var s = !1, l = 0; l < a.length; l++) {
                        var u = a[l], h = o.lastIndexOf(u);
                        if (h > 0 && h === o.length - u.length) {
                            var c = o.slice(0, h);
                            "data" !== c && (e.mainType = c, e[u.toLowerCase()] = t, s = !0)
                        }
                    }
                    r.hasOwnProperty(o) && (i[o] = t, s = !0), s || (n[o] = t)
                })
            }
            return {cptQuery: e, dataQuery: i, otherQuery: n}
        }, filter: function (t, e) {
            function i(t, e, i, n) {
                return null == t[i] || e[n || i] === t[i]
            }

            var n = this.eventInfo;
            if (!n) return !0;
            var o = n.targetEl, a = n.packedEvent, r = n.model, s = n.view;
            if (!r || !s) return !0;
            var l = e.cptQuery, u = e.dataQuery;
            return i(l, r, "mainType") && i(l, r, "subType") && i(l, r, "index", "componentIndex") && i(l, r, "name") && i(l, r, "id") && i(u, a, "name") && i(u, a, "dataIndex") && i(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, o, a))
        }, afterTrigger: function () {
            this.eventInfo = null
        }
    };
    var SL = {}, ML = {}, IL = [], TL = [], AL = [], DL = [], CL = {}, LL = {}, kL = {}, PL = {}, OL = new Date - 0,
        EL = new Date - 0, NL = "_echarts_instance_", RL = Mu;
    Ru(cL, SC), Cu(eC), Lu(sL, iC), Bu("default", AC), Pu({
        type: "highlight",
        event: "highlight",
        update: "highlight"
    }, G), Pu({type: "downplay", event: "downplay", update: "downplay"}, G), Du("light", NC), Du("dark", VC);
    var zL = {};
    Yu.prototype = {
        constructor: Yu, add: function (t) {
            return this._add = t, this
        }, update: function (t) {
            return this._update = t, this
        }, remove: function (t) {
            return this._remove = t, this
        }, execute: function () {
            var t, e = this._old, i = this._new, n = {}, o = {}, a = [], r = [];
            for (ju(e, n, a, "_oldKeyGetter", this), ju(i, o, r, "_newKeyGetter", this), t = 0; t < e.length; t++) {
                var s = a[t], l = o[s];
                if (null != l) {
                    var u = l.length;
                    u ? (1 === u && (o[s] = null), l = l.shift()) : o[s] = null, this._update && this._update(l, t)
                } else this._remove && this._remove(t)
            }
            for (var t = 0; t < r.length; t++) {
                var s = r[t];
                if (o.hasOwnProperty(s)) {
                    var l = o[s];
                    if (null == l) continue;
                    if (l.length) for (var h = 0, u = l.length; u > h; h++) this._add && this._add(l[h]); else this._add && this._add(l)
                }
            }
        }
    };
    var BL = B(["tooltip", "label", "itemName", "itemId", "seriesName"]), VL = S, GL = "undefined", FL = -1,
        WL = "e\x00\x00", HL = {
            "float": typeof Float64Array === GL ? Array : Float64Array,
            "int": typeof Int32Array === GL ? Array : Int32Array,
            ordinal: Array,
            number: Array,
            time: Array
        }, ZL = typeof Uint32Array === GL ? Array : Uint32Array, UL = typeof Int32Array === GL ? Array : Int32Array,
        XL = typeof Uint16Array === GL ? Array : Uint16Array,
        YL = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"],
        jL = ["_extent", "_approximateExtent", "_rawExtent"], qL = function (t, e) {
            t = t || ["x", "y"];
            for (var i = {}, n = [], o = {}, a = 0; a < t.length; a++) {
                var r = t[a];
                b(r) ? r = new Qu({name: r}) : r instanceof Qu || (r = new Qu(r));
                var s = r.name;
                r.type = r.type || "float", r.coordDim || (r.coordDim = s, r.coordDimIndex = 0), r.otherDims = r.otherDims || {}, n.push(s), i[s] = r, r.index = a, r.createInvertedIndices && (o[s] = [])
            }
            this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], this._graphicEls = [], this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, this._rawExtent = {}, this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = qu(this), this._invertedIndicesMap = o, this._calculationInfo = {}, this.userOutput = this._dimensionsSummary.userOutput
        }, KL = qL.prototype;
    KL.type = "list", KL.hasItemOption = !0, KL.getDimension = function (t) {
        return ("number" == typeof t || !isNaN(t) && !this._dimensionInfos.hasOwnProperty(t)) && (t = this.dimensions[t]), t
    }, KL.getDimensionInfo = function (t) {
        return this._dimensionInfos[this.getDimension(t)]
    }, KL.getDimensionsOnCoord = function () {
        return this._dimensionsSummary.dataDimsOnCoord.slice()
    }, KL.mapDimension = function (t, e) {
        var i = this._dimensionsSummary;
        if (null == e) return i.encodeFirstDimNotExtra[t];
        var n = i.encode[t];
        return e === !0 ? (n || []).slice() : n && n[e]
    }, KL.initData = function (t, e, i) {
        var n = us.isInstance(t) || d(t);
        if (n && (t = new $s(t, this.dimensions.length)), BS && !n && ("function" != typeof t.getItem || "function" != typeof t.count)) throw new Error("Inavlid data provider.");
        this._rawData = t, this._storage = {}, this._indices = null, this._nameList = e || [], this._idList = [], this._nameRepeatCount = {}, i || (this.hasItemOption = !1), this.defaultDimValueGetter = rC[this._rawData.getSource().sourceFormat], this._dimValueGetter = i = i || this.defaultDimValueGetter, this._dimValueGetterArrayRows = rC.arrayRows, this._rawExtent = {}, this._initDataFromProvider(0, t.count()), t.pure && (this.hasItemOption = !1)
    }, KL.getProvider = function () {
        return this._rawData
    }, KL.appendData = function (t) {
        BS && O(!this._indices, "appendData can only be called on raw data.");
        var e = this._rawData, i = this.count();
        e.appendData(t);
        var n = e.count();
        e.persistent || (n += i), this._initDataFromProvider(i, n)
    }, KL.appendValues = function (t, e) {
        for (var i = this._chunkSize, n = this._storage, o = this.dimensions, a = o.length, r = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e ? e.length : 0), u = this._chunkCount, h = 0; a > h; h++) {
            var c = o[h];
            r[c] || (r[c] = fh()), n[c] || (n[c] = []), nh(n, this._dimensionInfos[c], i, u, l), this._chunkCount = n[c].length
        }
        for (var d = new Array(a), f = s; l > f; f++) {
            for (var p = f - s, g = Math.floor(f / i), m = f % i, v = 0; a > v; v++) {
                var c = o[v], y = this._dimValueGetterArrayRows(t[p] || d, c, p, v);
                n[c][g][m] = y;
                var x = r[c];
                y < x[0] && (x[0] = y), y > x[1] && (x[1] = y)
            }
            e && (this._nameList[f] = e[p])
        }
        this._rawCount = this._count = l, this._extent = {}, oh(this)
    }, KL._initDataFromProvider = function (t, e) {
        if (!(t >= e)) {
            for (var i, n = this._chunkSize, o = this._rawData, a = this._storage, r = this.dimensions, s = r.length, l = this._dimensionInfos, u = this._nameList, h = this._idList, c = this._rawExtent, d = this._nameRepeatCount = {}, f = this._chunkCount, p = 0; s > p; p++) {
                var g = r[p];
                c[g] || (c[g] = fh());
                var m = l[g];
                0 === m.otherDims.itemName && (i = this._nameDimIdx = p), 0 === m.otherDims.itemId && (this._idDimIdx = p), a[g] || (a[g] = []), nh(a, m, n, f, e), this._chunkCount = a[g].length
            }
            for (var v = new Array(s), y = t; e > y; y++) {
                v = o.getItem(y, v);
                for (var x = Math.floor(y / n), _ = y % n, w = 0; s > w; w++) {
                    var g = r[w], b = a[g][x], S = this._dimValueGetter(v, g, y, w);
                    b[_] = S;
                    var M = c[g];
                    S < M[0] && (M[0] = S), S > M[1] && (M[1] = S)
                }
                if (!o.pure) {
                    var I = u[y];
                    if (v && null == I) if (null != v.name) u[y] = I = v.name; else if (null != i) {
                        var T = r[i], A = a[T][x];
                        if (A) {
                            I = A[_];
                            var D = l[T].ordinalMeta;
                            D && D.categories.length && (I = D.categories[I])
                        }
                    }
                    var C = null == v ? null : v.id;
                    null == C && null != I && (d[I] = d[I] || 0, C = I, d[I] > 0 && (C += "__ec__" + d[I]), d[I]++), null != C && (h[y] = C)
                }
            }
            !o.persistent && o.clean && o.clean(), this._rawCount = this._count = e, this._extent = {}, oh(this)
        }
    }, KL.count = function () {
        return this._count
    }, KL.getIndices = function () {
        var t, e = this._indices;
        if (e) {
            var i = e.constructor, n = this._count;
            if (i === Array) {
                t = new i(n);
                for (var o = 0; n > o; o++) t[o] = e[o]
            } else t = new i(e.buffer, 0, n)
        } else for (var i = th(this), t = new i(this.count()), o = 0; o < t.length; o++) t[o] = o;
        return t
    }, KL.get = function (t, e) {
        if (!(e >= 0 && e < this._count)) return 0 / 0;
        var i = this._storage;
        if (!i[t]) return 0 / 0;
        e = this.getRawIndex(e);
        var n = Math.floor(e / this._chunkSize), o = e % this._chunkSize, a = i[t][n], r = a[o];
        return r
    }, KL.getByRawIndex = function (t, e) {
        if (!(e >= 0 && e < this._rawCount)) return 0 / 0;
        var i = this._storage[t];
        if (!i) return 0 / 0;
        var n = Math.floor(e / this._chunkSize), o = e % this._chunkSize, a = i[n];
        return a[o]
    }, KL._getFast = function (t, e) {
        var i = Math.floor(e / this._chunkSize), n = e % this._chunkSize, o = this._storage[t][i];
        return o[n]
    }, KL.getValues = function (t, e) {
        var i = [];
        _(t) || (e = t, t = this.dimensions);
        for (var n = 0, o = t.length; o > n; n++) i.push(this.get(t[n], e));
        return i
    }, KL.hasValue = function (t) {
        for (var e = this._dimensionsSummary.dataDimsOnCoord, i = 0, n = e.length; n > i; i++) if (isNaN(this.get(e[i], t))) return !1;
        return !0
    }, KL.getDataExtent = function (t) {
        t = this.getDimension(t);
        var e = this._storage[t], i = fh();
        if (!e) return i;
        var n, o = this.count(), a = !this._indices;
        if (a) return this._rawExtent[t].slice();
        if (n = this._extent[t]) return n.slice();
        n = i;
        for (var r = n[0], s = n[1], l = 0; o > l; l++) {
            var u = this._getFast(t, this.getRawIndex(l));
            r > u && (r = u), u > s && (s = u)
        }
        return n = [r, s], this._extent[t] = n, n
    }, KL.getApproximateExtent = function (t) {
        return t = this.getDimension(t), this._approximateExtent[t] || this.getDataExtent(t)
    }, KL.setApproximateExtent = function (t, e) {
        e = this.getDimension(e), this._approximateExtent[e] = t.slice()
    }, KL.getCalculationInfo = function (t) {
        return this._calculationInfo[t]
    }, KL.setCalculationInfo = function (t, e) {
        VL(t) ? r(this._calculationInfo, t) : this._calculationInfo[t] = e
    }, KL.getSum = function (t) {
        var e = this._storage[t], i = 0;
        if (e) for (var n = 0, o = this.count(); o > n; n++) {
            var a = this.get(t, n);
            isNaN(a) || (i += a)
        }
        return i
    }, KL.getMedian = function (t) {
        var e = [];
        this.each(t, function (t) {
            isNaN(t) || e.push(t)
        });
        var i = [].concat(e).sort(function (t, e) {
            return t - e
        }), n = this.count();
        return 0 === n ? 0 : n % 2 === 1 ? i[(n - 1) / 2] : (i[n / 2] + i[n / 2 - 1]) / 2
    }, KL.rawIndexOf = function (t, e) {
        var i = t && this._invertedIndicesMap[t];
        if (BS && !i) throw new Error("Do not supported yet");
        var n = i[e];
        return null == n || isNaN(n) ? FL : n
    }, KL.indexOfName = function (t) {
        for (var e = 0, i = this.count(); i > e; e++) if (this.getName(e) === t) return e;
        return -1
    }, KL.indexOfRawIndex = function (t) {
        if (t >= this._rawCount || 0 > t) return -1;
        if (!this._indices) return t;
        var e = this._indices, i = e[t];
        if (null != i && i < this._count && i === t) return t;
        for (var n = 0, o = this._count - 1; o >= n;) {
            var a = (n + o) / 2 | 0;
            if (e[a] < t) n = a + 1; else {
                if (!(e[a] > t)) return a;
                o = a - 1
            }
        }
        return -1
    }, KL.indicesOfNearest = function (t, e, i) {
        var n = this._storage, o = n[t], a = [];
        if (!o) return a;
        null == i && (i = 1 / 0);
        for (var r = 1 / 0, s = -1, l = 0, u = 0, h = this.count(); h > u; u++) {
            var c = e - this.get(t, u), d = Math.abs(c);
            i >= d && ((r > d || d === r && c >= 0 && 0 > s) && (r = d, s = c, l = 0), c === s && (a[l++] = u))
        }
        return a.length = l, a
    }, KL.getRawIndex = rh, KL.getRawDataItem = function (t) {
        if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(t));
        for (var e = [], i = 0; i < this.dimensions.length; i++) {
            var n = this.dimensions[i];
            e.push(this.get(n, t))
        }
        return e
    }, KL.getName = function (t) {
        var e = this.getRawIndex(t);
        return this._nameList[e] || ah(this, this._nameDimIdx, e) || ""
    }, KL.getId = function (t) {
        return lh(this, this.getRawIndex(t))
    }, KL.each = function (t, e, i, n) {
        if (this._count) {
            "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = p(uh(t), this.getDimension, this), BS && hh(this, t);
            for (var o = t.length, a = 0; a < this.count(); a++) switch (o) {
                case 0:
                    e.call(i, a);
                    break;
                case 1:
                    e.call(i, this.get(t[0], a), a);
                    break;
                case 2:
                    e.call(i, this.get(t[0], a), this.get(t[1], a), a);
                    break;
                default:
                    for (var r = 0, s = []; o > r; r++) s[r] = this.get(t[r], a);
                    s[r] = a, e.apply(i, s)
            }
        }
    }, KL.filterSelf = function (t, e, i, n) {
        if (this._count) {
            "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = p(uh(t), this.getDimension, this), BS && hh(this, t);
            for (var o = this.count(), a = th(this), r = new a(o), s = [], l = t.length, u = 0, h = t[0], c = 0; o > c; c++) {
                var d, f = this.getRawIndex(c);
                if (0 === l) d = e.call(i, c); else if (1 === l) {
                    var g = this._getFast(h, f);
                    d = e.call(i, g, c)
                } else {
                    for (var m = 0; l > m; m++) s[m] = this._getFast(h, f);
                    s[m] = c, d = e.apply(i, s)
                }
                d && (r[u++] = f)
            }
            return o > u && (this._indices = r), this._count = u, this._extent = {}, this.getRawIndex = this._indices ? sh : rh, this
        }
    }, KL.selectRange = function (t) {
        if (this._count) {
            var e = [];
            for (var i in t) t.hasOwnProperty(i) && e.push(i);
            BS && hh(this, e);
            var n = e.length;
            if (n) {
                var o = this.count(), a = th(this), r = new a(o), s = 0, l = e[0], u = t[l][0], h = t[l][1], c = !1;
                if (!this._indices) {
                    var d = 0;
                    if (1 === n) {
                        for (var f = this._storage[e[0]], p = 0; p < this._chunkCount; p++) for (var g = f[p], m = Math.min(this._count - p * this._chunkSize, this._chunkSize), v = 0; m > v; v++) {
                            var y = g[v];
                            (y >= u && h >= y || isNaN(y)) && (r[s++] = d), d++
                        }
                        c = !0
                    } else if (2 === n) {
                        for (var f = this._storage[l], x = this._storage[e[1]], _ = t[e[1]][0], w = t[e[1]][1], p = 0; p < this._chunkCount; p++) for (var g = f[p], b = x[p], m = Math.min(this._count - p * this._chunkSize, this._chunkSize), v = 0; m > v; v++) {
                            var y = g[v], S = b[v];
                            (y >= u && h >= y || isNaN(y)) && (S >= _ && w >= S || isNaN(S)) && (r[s++] = d), d++
                        }
                        c = !0
                    }
                }
                if (!c) if (1 === n) for (var v = 0; o > v; v++) {
                    var M = this.getRawIndex(v), y = this._getFast(l, M);
                    (y >= u && h >= y || isNaN(y)) && (r[s++] = M)
                } else for (var v = 0; o > v; v++) {
                    for (var I = !0, M = this.getRawIndex(v), p = 0; n > p; p++) {
                        var T = e[p], y = this._getFast(i, M);
                        (y < t[T][0] || y > t[T][1]) && (I = !1)
                    }
                    I && (r[s++] = this.getRawIndex(v))
                }
                return o > s && (this._indices = r), this._count = s, this._extent = {}, this.getRawIndex = this._indices ? sh : rh, this
            }
        }
    }, KL.mapArray = function (t, e, i, n) {
        "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this;
        var o = [];
        return this.each(t, function () {
            o.push(e && e.apply(this, arguments))
        }, i), o
    }, KL.map = function (t, e, i, n) {
        i = i || n || this, t = p(uh(t), this.getDimension, this), BS && hh(this, t);
        var o = ch(this, t);
        o._indices = this._indices, o.getRawIndex = o._indices ? sh : rh;
        for (var a = o._storage, r = [], s = this._chunkSize, l = t.length, u = this.count(), h = [], c = o._rawExtent, d = 0; u > d; d++) {
            for (var f = 0; l > f; f++) h[f] = this.get(t[f], d);
            h[l] = d;
            var g = e && e.apply(i, h);
            if (null != g) {
                "object" != typeof g && (r[0] = g, g = r);
                for (var m = this.getRawIndex(d), v = Math.floor(m / s), y = m % s, x = 0; x < g.length; x++) {
                    var _ = t[x], w = g[x], b = c[_], S = a[_];
                    S && (S[v][y] = w), w < b[0] && (b[0] = w), w > b[1] && (b[1] = w)
                }
            }
        }
        return o
    }, KL.downSample = function (t, e, i, n) {
        for (var o = ch(this, [t]), a = o._storage, r = [], s = Math.floor(1 / e), l = a[t], u = this.count(), h = this._chunkSize, c = o._rawExtent[t], d = new (th(this))(u), f = 0, p = 0; u > p; p += s) {
            s > u - p && (s = u - p, r.length = s);
            for (var g = 0; s > g; g++) {
                var m = this.getRawIndex(p + g), v = Math.floor(m / h), y = m % h;
                r[g] = l[v][y]
            }
            var x = i(r), _ = this.getRawIndex(Math.min(p + n(r, x) || 0, u - 1)), w = Math.floor(_ / h), b = _ % h;
            l[w][b] = x, x < c[0] && (c[0] = x), x > c[1] && (c[1] = x), d[f++] = _
        }
        return o._count = f, o._indices = d, o.getRawIndex = sh, o
    }, KL.getItemModel = function (t) {
        var e = this.hostModel;
        return new vr(this.getRawDataItem(t), e, e && e.ecModel)
    }, KL.diff = function (t) {
        var e = this;
        return new Yu(t ? t.getIndices() : [], this.getIndices(), function (e) {
            return lh(t, e)
        }, function (t) {
            return lh(e, t)
        })
    }, KL.getVisual = function (t) {
        var e = this._visual;
        return e && e[t]
    }, KL.setVisual = function (t, e) {
        if (VL(t)) for (var i in t) t.hasOwnProperty(i) && this.setVisual(i, t[i]); else this._visual = this._visual || {}, this._visual[t] = e
    }, KL.setLayout = function (t, e) {
        if (VL(t)) for (var i in t) t.hasOwnProperty(i) && this.setLayout(i, t[i]); else this._layout[t] = e
    }, KL.getLayout = function (t) {
        return this._layout[t]
    }, KL.getItemLayout = function (t) {
        return this._itemLayouts[t]
    }, KL.setItemLayout = function (t, e, i) {
        this._itemLayouts[t] = i ? r(this._itemLayouts[t] || {}, e) : e
    }, KL.clearItemLayouts = function () {
        this._itemLayouts.length = 0
    }, KL.getItemVisual = function (t, e, i) {
        var n = this._itemVisuals[t], o = n && n[e];
        return null != o || i ? o : this.getVisual(e)
    }, KL.setItemVisual = function (t, e, i) {
        var n = this._itemVisuals[t] || {}, o = this.hasItemVisual;
        if (this._itemVisuals[t] = n, VL(e)) for (var a in e) e.hasOwnProperty(a) && (n[a] = e[a], o[a] = !0); else n[e] = i, o[e] = !0
    }, KL.clearAllVisual = function () {
        this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {}
    };
    var $L = function (t) {
        t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType
    };
    KL.setItemGraphicEl = function (t, e) {
        var i = this.hostModel;
        e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, "group" === e.type && e.traverse($L, e)), this._graphicEls[t] = e
    }, KL.getItemGraphicEl = function (t) {
        return this._graphicEls[t]
    }, KL.eachItemGraphicEl = function (t, e) {
        f(this._graphicEls, function (i, n) {
            i && t && t.call(e, i, n)
        })
    }, KL.cloneShallow = function (t) {
        if (!t) {
            var e = p(this.dimensions, this.getDimensionInfo, this);
            t = new qL(e, this.hostModel)
        }
        if (t._storage = this._storage, ih(t, this), this._indices) {
            var i = this._indices.constructor;
            t._indices = new i(this._indices)
        } else t._indices = null;
        return t.getRawIndex = t._indices ? sh : rh, t
    }, KL.wrapMethod = function (t, e) {
        var i = this[t];
        "function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
            var t = i.apply(this, arguments);
            return e.apply(this, [t].concat(k(arguments)))
        })
    }, KL.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], KL.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    var JL = function (t, e) {
        return e = e || {}, ph(e.coordDimensions || [], t, {
            dimsDef: e.dimensionsDefine || t.dimensionsDefine,
            encodeDef: e.encodeDefine || t.encodeDefine,
            dimCount: e.dimensionsCount,
            encodeDefaulter: e.encodeDefaulter,
            generateCoord: e.generateCoord,
            generateCoordCount: e.generateCoordCount
        })
    }, QL = {
        cartesian2d: function (t, e, i, n) {
            var o = t.getReferringComponents("xAxis")[0], a = t.getReferringComponents("yAxis")[0];
            if (BS) {
                if (!o) throw new Error('xAxis "' + D(t.get("xAxisIndex"), t.get("xAxisId"), 0) + '" not found');
                if (!a) throw new Error('yAxis "' + D(t.get("xAxisIndex"), t.get("yAxisId"), 0) + '" not found')
            }
            e.coordSysDims = ["x", "y"], i.set("x", o), i.set("y", a), xh(o) && (n.set("x", o), e.firstCategoryDimIndex = 0), xh(a) && (n.set("y", a), null == e.firstCategoryDimIndex & (e.firstCategoryDimIndex = 1))
        }, singleAxis: function (t, e, i, n) {
            var o = t.getReferringComponents("singleAxis")[0];
            if (BS && !o) throw new Error("singleAxis should be specified.");
            e.coordSysDims = ["single"], i.set("single", o), xh(o) && (n.set("single", o), e.firstCategoryDimIndex = 0)
        }, polar: function (t, e, i, n) {
            var o = t.getReferringComponents("polar")[0], a = o.findAxisModel("radiusAxis"),
                r = o.findAxisModel("angleAxis");
            if (BS) {
                if (!r) throw new Error("angleAxis option not found");
                if (!a) throw new Error("radiusAxis option not found")
            }
            e.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", r), xh(a) && (n.set("radius", a), e.firstCategoryDimIndex = 0), xh(r) && (n.set("angle", r), null == e.firstCategoryDimIndex && (e.firstCategoryDimIndex = 1))
        }, geo: function (t, e) {
            e.coordSysDims = ["lng", "lat"]
        }, parallel: function (t, e, i, n) {
            var o = t.ecModel, a = o.getComponent("parallel", t.get("parallelIndex")),
                r = e.coordSysDims = a.dimensions.slice();
            f(a.parallelAxisIndex, function (t, a) {
                var s = o.getComponent("parallelAxis", t), l = r[a];
                i.set(l, s), xh(s) && null == e.firstCategoryDimIndex && (n.set(l, s), e.firstCategoryDimIndex = a)
            })
        }
    };
    Th.prototype.parse = function (t) {
        return t
    }, Th.prototype.getSetting = function (t) {
        return this._setting[t]
    }, Th.prototype.contain = function (t) {
        var e = this._extent;
        return t >= e[0] && t <= e[1]
    }, Th.prototype.normalize = function (t) {
        var e = this._extent;
        return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
    }, Th.prototype.scale = function (t) {
        var e = this._extent;
        return t * (e[1] - e[0]) + e[0]
    }, Th.prototype.unionExtent = function (t) {
        var e = this._extent;
        t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
    }, Th.prototype.unionExtentFromData = function (t, e) {
        this.unionExtent(t.getApproximateExtent(e))
    }, Th.prototype.getExtent = function () {
        return this._extent.slice()
    }, Th.prototype.setExtent = function (t, e) {
        var i = this._extent;
        isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
    }, Th.prototype.isBlank = function () {
        return this._isBlank
    }, Th.prototype.setBlank = function (t) {
        this._isBlank = t
    }, Th.prototype.getLabel = null, wo(Th), Io(Th, {registerWhenExtend: !0}), Ah.createByAxisModel = function (t) {
        var e = t.option, i = e.data, n = i && p(i, Ch);
        return new Ah({categories: n, needCollect: !n, deduplication: e.dedplication !== !1})
    };
    var tk = Ah.prototype;
    tk.getOrdinal = function (t) {
        return Dh(this).get(t)
    }, tk.parseAndCollect = function (t) {
        var e, i = this._needCollect;
        if ("string" != typeof t && !i) return t;
        if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e;
        var n = Dh(this);
        return e = n.get(t), null == e && (i ? (e = this.categories.length, this.categories[e] = t, n.set(t, e)) : e = 0 / 0), e
    };
    var ek = Th.prototype, ik = Th.extend({
        type: "ordinal", init: function (t, e) {
            (!t || _(t)) && (t = new Ah({categories: t})), this._ordinalMeta = t, this._extent = e || [0, t.categories.length - 1]
        }, parse: function (t) {
            return "string" == typeof t ? this._ordinalMeta.getOrdinal(t) : Math.round(t)
        }, contain: function (t) {
            return t = this.parse(t), ek.contain.call(this, t) && null != this._ordinalMeta.categories[t]
        }, normalize: function (t) {
            return ek.normalize.call(this, this.parse(t))
        }, scale: function (t) {
            return Math.round(ek.scale.call(this, t))
        }, getTicks: function () {
            for (var t = [], e = this._extent, i = e[0]; i <= e[1];) t.push(i), i++;
            return t
        }, getLabel: function (t) {
            return this.isBlank() ? void 0 : this._ordinalMeta.categories[t]
        }, count: function () {
            return this._extent[1] - this._extent[0] + 1
        }, unionExtentFromData: function (t, e) {
            this.unionExtent(t.getApproximateExtent(e))
        }, getOrdinalMeta: function () {
            return this._ordinalMeta
        }, niceTicks: G, niceExtent: G
    });
    ik.create = function () {
        return new ik
    };
    var nk = Tr, ok = Tr, ak = Th.extend({
        type: "interval", _interval: 0, _intervalPrecision: 2, setExtent: function (t, e) {
            var i = this._extent;
            isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
        }, unionExtent: function (t) {
            var e = this._extent;
            t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), ak.prototype.setExtent.call(this, e[0], e[1])
        }, getInterval: function () {
            return this._interval
        }, setInterval: function (t) {
            this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = kh(t)
        }, getTicks: function (t) {
            var e = this._interval, i = this._extent, n = this._niceExtent, o = this._intervalPrecision, a = [];
            if (!e) return a;
            var r = 1e4;
            i[0] < n[0] && a.push(t ? ok(n[0] - e, o) : i[0]);
            for (var s = n[0]; s <= n[1] && (a.push(s), s = ok(s + e, o), s !== a[a.length - 1]);) if (a.length > r) return [];
            var l = a.length ? a[a.length - 1] : n[1];
            return i[1] > l && a.push(t ? ok(l + e, o) : i[1]), a
        }, getMinorTicks: function (t) {
            for (var e = this.getTicks(!0), i = [], n = this.getExtent(), o = 1; o < e.length; o++) {
                for (var a = e[o], r = e[o - 1], s = 0, l = [], u = a - r, h = u / t; t - 1 > s;) {
                    var c = Tr(r + (s + 1) * h);
                    c > n[0] && c < n[1] && l.push(c), s++
                }
                i.push(l)
            }
            return i
        }, getLabel: function (t, e) {
            if (null == t) return "";
            var i = e && e.precision;
            return null == i ? i = Cr(t) || 0 : "auto" === i && (i = this._intervalPrecision), t = ok(t, i, !0), Fr(t)
        }, niceTicks: function (t, e, i) {
            t = t || 5;
            var n = this._extent, o = n[1] - n[0];
            if (isFinite(o)) {
                0 > o && (o = -o, n.reverse());
                var a = Lh(n, t, e, i);
                this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent
            }
        }, niceExtent: function (t) {
            var e = this._extent;
            if (e[0] === e[1]) if (0 !== e[0]) {
                var i = e[0];
                t.fixMax ? e[0] -= i / 2 : (e[1] += i / 2, e[0] -= i / 2)
            } else e[1] = 1;
            var n = e[1] - e[0];
            isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
            var o = this._interval;
            t.fixMin || (e[0] = ok(Math.floor(e[0] / o) * o)), t.fixMax || (e[1] = ok(Math.ceil(e[1] / o) * o))
        }
    });
    ak.create = function () {
        return new ak
    };
    var rk = "__ec_stack_", sk = .5, lk = "undefined" != typeof Float32Array ? Float32Array : Array, uk = {
            seriesType: "bar", plan: gC(), reset: function (t) {
                function e(t, e) {
                    for (var i, d = t.count, f = new lk(2 * d), p = new lk(2 * d), g = new lk(d), m = [], v = [], y = 0, x = 0; null != (i = t.next());) v[h] = e.get(s, i), v[1 - h] = e.get(l, i), m = n.dataToPoint(v, null, m), p[y] = u ? o.x + o.width : m[0], f[y++] = m[0], p[y] = u ? m[1] : o.y + o.height, f[y++] = m[1], g[x++] = i;
                    e.setLayout({
                        largePoints: f,
                        largeDataIndices: g,
                        largeBackgroundPoints: p,
                        barWidth: c,
                        valueAxisStart: Uh(a, r, !1),
                        backgroundStart: u ? o.x : o.y,
                        valueAxisHorizontal: u
                    })
                }

                if (Hh(t) && Zh(t)) {
                    var i = t.getData(), n = t.coordinateSystem, o = n.grid.getRect(), a = n.getBaseAxis(),
                        r = n.getOtherAxis(a), s = i.mapDimension(r.dim), l = i.mapDimension(a.dim), u = r.isHorizontal(),
                        h = u ? 0 : 1, c = Fh(Vh([t]), a, t).width;
                    return c > sk || (c = sk), {progress: e}
                }
            }
        }, hk = ak.prototype, ck = Math.ceil, dk = Math.floor, fk = 1e3, pk = 60 * fk, gk = 60 * pk, mk = 24 * gk,
        vk = function (t, e, i, n) {
            for (; n > i;) {
                var o = i + n >>> 1;
                t[o][1] < e ? i = o + 1 : n = o
            }
            return i
        }, yk = ak.extend({
            type: "time", getLabel: function (t) {
                var e = this._stepLvl, i = new Date(t);
                return jr(e[0], i, this.getSetting("useUTC"))
            }, niceExtent: function (t) {
                var e = this._extent;
                if (e[0] === e[1] && (e[0] -= mk, e[1] += mk), e[1] === -1 / 0 && 1 / 0 === e[0]) {
                    var i = new Date;
                    e[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - mk
                }
                this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
                var n = this._interval;
                t.fixMin || (e[0] = Tr(dk(e[0] / n) * n)), t.fixMax || (e[1] = Tr(ck(e[1] / n) * n))
            }, niceTicks: function (t, e, i) {
                t = t || 10;
                var n = this._extent, o = n[1] - n[0], a = o / t;
                null != e && e > a && (a = e), null != i && a > i && (a = i);
                var r = xk.length, s = vk(xk, a, 0, r), l = xk[Math.min(s, r - 1)], u = l[1];
                if ("year" === l[0]) {
                    var h = o / u, c = zr(h / t, !0);
                    u *= c
                }
                var d = this.getSetting("useUTC") ? 0 : 60 * new Date(+n[0] || +n[1]).getTimezoneOffset() * 1e3,
                    f = [Math.round(ck((n[0] - d) / u) * u + d), Math.round(dk((n[1] - d) / u) * u + d)];
                Oh(f, n), this._stepLvl = l, this._interval = u, this._niceExtent = f
            }, parse: function (t) {
                return +Er(t)
            }
        });
    f(["contain", "normalize"], function (t) {
        yk.prototype[t] = function (e) {
            return hk[t].call(this, this.parse(e))
        }
    });
    var xk = [["hh:mm:ss", fk], ["hh:mm:ss", 5 * fk], ["hh:mm:ss", 10 * fk], ["hh:mm:ss", 15 * fk], ["hh:mm:ss", 30 * fk], ["hh:mm\nMM-dd", pk], ["hh:mm\nMM-dd", 5 * pk], ["hh:mm\nMM-dd", 10 * pk], ["hh:mm\nMM-dd", 15 * pk], ["hh:mm\nMM-dd", 30 * pk], ["hh:mm\nMM-dd", gk], ["hh:mm\nMM-dd", 2 * gk], ["hh:mm\nMM-dd", 6 * gk], ["hh:mm\nMM-dd", 12 * gk], ["MM-dd\nyyyy", mk], ["MM-dd\nyyyy", 2 * mk], ["MM-dd\nyyyy", 3 * mk], ["MM-dd\nyyyy", 4 * mk], ["MM-dd\nyyyy", 5 * mk], ["MM-dd\nyyyy", 6 * mk], ["week", 7 * mk], ["MM-dd\nyyyy", 10 * mk], ["week", 14 * mk], ["week", 21 * mk], ["month", 31 * mk], ["week", 42 * mk], ["month", 62 * mk], ["week", 70 * mk], ["quarter", 95 * mk], ["month", 31 * mk * 4], ["month", 31 * mk * 5], ["half-year", 380 * mk / 2], ["month", 31 * mk * 8], ["month", 31 * mk * 10], ["year", 380 * mk]];
    yk.create = function (t) {
        return new yk({useUTC: t.ecModel.get("useUTC")})
    };
    var _k = Th.prototype, wk = ak.prototype, bk = Cr, Sk = Tr, Mk = Math.floor, Ik = Math.ceil, Tk = Math.pow,
        Ak = Math.log, Dk = Th.extend({
            type: "log", base: 10, $constructor: function () {
                Th.apply(this, arguments), this._originalScale = new ak
            }, getTicks: function (t) {
                var e = this._originalScale, i = this._extent, n = e.getExtent();
                return p(wk.getTicks.call(this, t), function (t) {
                    var o = Tr(Tk(this.base, t));
                    return o = t === i[0] && e.__fixMin ? Xh(o, n[0]) : o, o = t === i[1] && e.__fixMax ? Xh(o, n[1]) : o
                }, this)
            }, getMinorTicks: wk.getMinorTicks, getLabel: wk.getLabel, scale: function (t) {
                return t = _k.scale.call(this, t), Tk(this.base, t)
            }, setExtent: function (t, e) {
                var i = this.base;
                t = Ak(t) / Ak(i), e = Ak(e) / Ak(i), wk.setExtent.call(this, t, e)
            }, getExtent: function () {
                var t = this.base, e = _k.getExtent.call(this);
                e[0] = Tk(t, e[0]), e[1] = Tk(t, e[1]);
                var i = this._originalScale, n = i.getExtent();
                return i.__fixMin && (e[0] = Xh(e[0], n[0])), i.__fixMax && (e[1] = Xh(e[1], n[1])), e
            }, unionExtent: function (t) {
                this._originalScale.unionExtent(t);
                var e = this.base;
                t[0] = Ak(t[0]) / Ak(e), t[1] = Ak(t[1]) / Ak(e), _k.unionExtent.call(this, t)
            }, unionExtentFromData: function (t, e) {
                this.unionExtent(t.getApproximateExtent(e))
            }, niceTicks: function (t) {
                t = t || 10;
                var e = this._extent, i = e[1] - e[0];
                if (!(1 / 0 === i || 0 >= i)) {
                    var n = Nr(i), o = t / i * n;
                    for (.5 >= o && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && Math.abs(n) > 0;) n *= 10;
                    var a = [Tr(Ik(e[0] / n) * n), Tr(Mk(e[1] / n) * n)];
                    this._interval = n, this._niceExtent = a
                }
            }, niceExtent: function (t) {
                wk.niceExtent.call(this, t);
                var e = this._originalScale;
                e.__fixMin = t.fixMin, e.__fixMax = t.fixMax
            }
        });
    f(["contain", "normalize"], function (t) {
        Dk.prototype[t] = function (e) {
            return e = Ak(e) / Ak(this.base), _k[t].call(this, e)
        }
    }), Dk.create = function () {
        return new Dk
    };
    var Ck = {
            getMin: function (t) {
                var e = this.option, i = t || null == e.rangeStart ? e.min : e.rangeStart;
                return this.axis && null != i && "dataMin" !== i && "function" != typeof i && !A(i) && (i = this.axis.scale.parse(i)), i
            }, getMax: function (t) {
                var e = this.option, i = t || null == e.rangeEnd ? e.max : e.rangeEnd;
                return this.axis && null != i && "dataMax" !== i && "function" != typeof i && !A(i) && (i = this.axis.scale.parse(i)), i
            }, getNeedCrossZero: function () {
                var t = this.option;
                return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
            }, getCoordSysModel: G, setRange: function (t, e) {
                this.option.rangeStart = t, this.option.rangeEnd = e
            }, resetRange: function () {
                this.option.rangeStart = this.option.rangeEnd = null
            }
        }, Lk = xa({
            type: "triangle", shape: {cx: 0, cy: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i = e.cx, n = e.cy, o = e.width / 2, a = e.height / 2;
                t.moveTo(i, n - a), t.lineTo(i + o, n + a), t.lineTo(i - o, n + a), t.closePath()
            }
        }), kk = xa({
            type: "diamond", shape: {cx: 0, cy: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i = e.cx, n = e.cy, o = e.width / 2, a = e.height / 2;
                t.moveTo(i, n - a), t.lineTo(i + o, n), t.lineTo(i, n + a), t.lineTo(i - o, n), t.closePath()
            }
        }), Pk = xa({
            type: "pin", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i = e.x, n = e.y, o = e.width / 5 * 3, a = Math.max(o, e.height), r = o / 2, s = r * r / (a - r),
                    l = n - a + r + s, u = Math.asin(s / r), h = Math.cos(u) * r, c = Math.sin(u), d = Math.cos(u),
                    f = .6 * r, p = .7 * r;
                t.moveTo(i - h, l + s), t.arc(i, l, r, Math.PI - u, 2 * Math.PI + u), t.bezierCurveTo(i + h - c * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - h + c * f, l + s + d * f, i - h, l + s), t.closePath()
            }
        }), Ok = xa({
            type: "arrow", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i = e.height, n = e.width, o = e.x, a = e.y, r = n / 3 * 2;
                t.moveTo(o, a), t.lineTo(o + r, a + i), t.lineTo(o, a + i / 4 * 3), t.lineTo(o - r, a + i), t.lineTo(o, a), t.closePath()
            }
        }), Ek = {line: kA, rect: CA, roundRect: CA, square: CA, circle: yA, diamond: kk, pin: Pk, arrow: Ok, triangle: Lk},
        Nk = {
            line: function (t, e, i, n, o) {
                o.x1 = t, o.y1 = e + n / 2, o.x2 = t + i, o.y2 = e + n / 2
            }, rect: function (t, e, i, n, o) {
                o.x = t, o.y = e, o.width = i, o.height = n
            }, roundRect: function (t, e, i, n, o) {
                o.x = t, o.y = e, o.width = i, o.height = n, o.r = Math.min(i, n) / 4
            }, square: function (t, e, i, n, o) {
                var a = Math.min(i, n);
                o.x = t, o.y = e, o.width = a, o.height = a
            }, circle: function (t, e, i, n, o) {
                o.cx = t + i / 2, o.cy = e + n / 2, o.r = Math.min(i, n) / 2
            }, diamond: function (t, e, i, n, o) {
                o.cx = t + i / 2, o.cy = e + n / 2, o.width = i, o.height = n
            }, pin: function (t, e, i, n, o) {
                o.x = t + i / 2, o.y = e + n / 2, o.width = i, o.height = n
            }, arrow: function (t, e, i, n, o) {
                o.x = t + i / 2, o.y = e + n / 2, o.width = i, o.height = n
            }, triangle: function (t, e, i, n, o) {
                o.cx = t + i / 2, o.cy = e + n / 2, o.width = i, o.height = n
            }
        }, Rk = {};
    f(Ek, function (t, e) {
        Rk[e] = new t
    });
    var zk = xa({
        type: "symbol",
        shape: {symbolType: "", x: 0, y: 0, width: 0, height: 0},
        calculateTextPosition: function (t, e, i) {
            var n = $i(t, e, i), o = this.shape;
            return o && "pin" === o.symbolType && "inside" === e.textPosition && (n.y = i.y + .4 * i.height), n
        },
        buildPath: function (t, e, i) {
            var n = e.symbolType;
            if ("none" !== n) {
                var o = Rk[n];
                o || (n = "rect", o = Rk[n]), Nk[n](e.x, e.y, e.width, e.height, o.shape), o.buildPath(t, o.shape, i)
            }
        }
    }), Bk = {isDimensionStacked: wh, enableDataStack: _h, getStackedDimension: bh}, Vk = (Object.freeze || Object)({
        createList: rc,
        getLayoutRect: es,
        dataStack: Bk,
        createScale: sc,
        mixinAxisModelCommonMethods: lc,
        completeDimensions: ph,
        createDimensions: JL,
        createSymbol: ac
    }), Gk = 1e-8;
    cc.prototype = {
        constructor: cc, properties: null, getBoundingRect: function () {
            var t = this._rect;
            if (t) return t;
            for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], o = [], a = [], r = this.geometries, s = 0; s < r.length; s++) if ("polygon" === r[s].type) {
                var l = r[s].exterior;
                Go(l, o, a), re(i, i, o), se(n, n, a)
            }
            return 0 === s && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new Ti(i[0], i[1], n[0] - i[0], n[1] - i[1])
        }, contain: function (t) {
            var e = this.getBoundingRect(), i = this.geometries;
            if (!e.contain(t[0], t[1])) return !1;
            t:for (var n = 0, o = i.length; o > n; n++) if ("polygon" === i[n].type) {
                var a = i[n].exterior, r = i[n].interiors;
                if (hc(a, t[0], t[1])) {
                    for (var s = 0; s < (r ? r.length : 0); s++) if (hc(r[s])) continue t;
                    return !0
                }
            }
            return !1
        }, transformTo: function (t, e, i, n) {
            var o = this.getBoundingRect(), a = o.width / o.height;
            i ? n || (n = i / a) : i = a * n;
            for (var r = new Ti(t, e, i, n), s = o.calculateTransform(r), l = this.geometries, u = 0; u < l.length; u++) if ("polygon" === l[u].type) {
                for (var h = l[u].exterior, c = l[u].interiors, d = 0; d < h.length; d++) ae(h[d], h[d], s);
                for (var f = 0; f < (c ? c.length : 0); f++) for (var d = 0; d < c[f].length; d++) ae(c[f][d], c[f][d], s)
            }
            o = this._rect, o.copy(r), this.center = [o.x + o.width / 2, o.y + o.height / 2]
        }, cloneShallow: function (t) {
            null == t && (t = this.name);
            var e = new cc(t, this.geometries, this.center);
            return e._rect = this._rect, e.transformTo = null, e
        }
    };
    var Fk = function (t, e) {
        return dc(t), p(m(t.features, function (t) {
            return t.geometry && t.properties && t.geometry.coordinates.length > 0
        }), function (t) {
            var i = t.properties, n = t.geometry, o = n.coordinates, a = [];
            "Polygon" === n.type && a.push({
                type: "polygon",
                exterior: o[0],
                interiors: o.slice(1)
            }), "MultiPolygon" === n.type && f(o, function (t) {
                t[0] && a.push({type: "polygon", exterior: t[0], interiors: t.slice(1)})
            });
            var r = new cc(i[e || "name"], a, i.cp);
            return r.properties = i, r
        })
    }, Wk = co(), Hk = [0, 1], Zk = function (t, e, i) {
        this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1
    };
    Zk.prototype = {
        constructor: Zk, contain: function (t) {
            var e = this._extent, i = Math.min(e[0], e[1]), n = Math.max(e[0], e[1]);
            return t >= i && n >= t
        }, containData: function (t) {
            return this.scale.contain(t)
        }, getExtent: function () {
            return this._extent.slice()
        }, getPixelPrecision: function (t) {
            return Lr(t || this.scale.getExtent(), this._extent)
        }, setExtent: function (t, e) {
            var i = this._extent;
            i[0] = t, i[1] = e
        }, dataToCoord: function (t, e) {
            var i = this._extent, n = this.scale;
            return t = n.normalize(t), this.onBand && "ordinal" === n.type && (i = i.slice(), Dc(i, n.count())), Mr(t, Hk, i, e)
        }, coordToData: function (t, e) {
            var i = this._extent, n = this.scale;
            this.onBand && "ordinal" === n.type && (i = i.slice(), Dc(i, n.count()));
            var o = Mr(t, i, Hk, e);
            return this.scale.scale(o)
        }, pointToData: function () {
        }, getTicksCoords: function (t) {
            t = t || {};
            var e = t.tickModel || this.getTickModel(), i = gc(this, e), n = i.ticks, o = p(n, function (t) {
                return {coord: this.dataToCoord(t), tickValue: t}
            }, this), a = e.get("alignWithLabel");
            return Cc(this, o, a, t.clamp), o
        }, getMinorTicksCoords: function () {
            if ("ordinal" === this.scale.type) return [];
            var t = this.model.getModel("minorTick"), e = t.get("splitNumber");
            e > 0 && 100 > e || (e = 5);
            var i = this.scale.getMinorTicks(e), n = p(i, function (t) {
                return p(t, function (t) {
                    return {coord: this.dataToCoord(t), tickValue: t}
                }, this)
            }, this);
            return n
        }, getViewLabels: function () {
            return pc(this).labels
        }, getLabelModel: function () {
            return this.model.getModel("axisLabel")
        }, getTickModel: function () {
            return this.model.getModel("axisTick")
        }, getBandWidth: function () {
            var t = this._extent, e = this.scale.getExtent(), i = e[1] - e[0] + (this.onBand ? 1 : 0);
            0 === i && (i = 1);
            var n = Math.abs(t[1] - t[0]);
            return Math.abs(n) / i
        }, isHorizontal: null, getRotate: null, calculateCategoryInterval: function () {
            return Mc(this)
        }
    };
    var Uk = Fk, Xk = {};
    f(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function (t) {
        Xk[t] = iM[t]
    });
    var Yk = {};
    f(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "registerShape", "getShapeClass", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function (t) {
        Yk[t] = tD[t]
    });
    var jk = function (t) {
        this._axes = {}, this._dimList = [], this.name = t || ""
    };
    jk.prototype = {
        constructor: jk, type: "cartesian", getAxis: function (t) {
            return this._axes[t]
        }, getAxes: function () {
            return p(this._dimList, Lc, this)
        }, getAxesByScale: function (t) {
            return t = t.toLowerCase(), m(this.getAxes(), function (e) {
                return e.scale.type === t
            })
        }, addAxis: function (t) {
            var e = t.dim;
            this._axes[e] = t, this._dimList.push(e)
        }, dataToCoord: function (t) {
            return this._dataCoordConvert(t, "dataToCoord")
        }, coordToData: function (t) {
            return this._dataCoordConvert(t, "coordToData")
        }, _dataCoordConvert: function (t, e) {
            for (var i = this._dimList, n = t instanceof Array ? [] : {}, o = 0; o < i.length; o++) {
                var a = i[o], r = this._axes[a];
                n[a] = r[e](t[a])
            }
            return n
        }
    }, kc.prototype = {
        constructor: kc, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function () {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
        }, containPoint: function (t) {
            var e = this.getAxis("x"), i = this.getAxis("y");
            return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]))
        }, containData: function (t) {
            return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
        }, dataToPoint: function (t, e, i) {
            var n = this.getAxis("x"), o = this.getAxis("y");
            return i = i || [], i[0] = n.toGlobalCoord(n.dataToCoord(t[0])), i[1] = o.toGlobalCoord(o.dataToCoord(t[1])), i
        }, clampData: function (t, e) {
            var i = this.getAxis("x").scale, n = this.getAxis("y").scale, o = i.getExtent(), a = n.getExtent(),
                r = i.parse(t[0]), s = n.parse(t[1]);
            return e = e || [], e[0] = Math.min(Math.max(Math.min(o[0], o[1]), r), Math.max(o[0], o[1])), e[1] = Math.min(Math.max(Math.min(a[0], a[1]), s), Math.max(a[0], a[1])), e
        }, pointToData: function (t, e) {
            var i = this.getAxis("x"), n = this.getAxis("y");
            return e = e || [], e[0] = i.coordToData(i.toLocalCoord(t[0])), e[1] = n.coordToData(n.toLocalCoord(t[1])), e
        }, getOtherAxis: function (t) {
            return this.getAxis("x" === t.dim ? "y" : "x")
        }, getArea: function () {
            var t = this.getAxis("x").getGlobalExtent(), e = this.getAxis("y").getGlobalExtent(),
                i = Math.min(t[0], t[1]), n = Math.min(e[0], e[1]), o = Math.max(t[0], t[1]) - i,
                a = Math.max(e[0], e[1]) - n, r = new Ti(i, n, o, a);
            return r
        }
    }, h(kc, jk);
    var qk = function (t, e, i, n, o) {
        Zk.call(this, t, e, i), this.type = n || "value", this.position = o || "bottom"
    };
    qk.prototype = {
        constructor: qk, index: 0, getAxesOnZeroOf: null, model: null, isHorizontal: function () {
            var t = this.position;
            return "top" === t || "bottom" === t
        }, getGlobalExtent: function (t) {
            var e = this.getExtent();
            return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e
        }, getOtherAxis: function () {
            this.grid.getOtherAxis()
        }, pointToData: function (t, e) {
            return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e)
        }, toLocalCoord: null, toGlobalCoord: null
    }, h(qk, Zk);
    var Kk = {
        show: !0,
        zlevel: 0,
        z: 0,
        inverse: !1,
        name: "",
        nameLocation: "end",
        nameRotate: null,
        nameTruncate: {maxWidth: null, ellipsis: "...", placeholder: "."},
        nameTextStyle: {},
        nameGap: 15,
        silent: !1,
        triggerEvent: !1,
        tooltip: {show: !1},
        axisPointer: {},
        axisLine: {
            show: !0,
            onZero: !0,
            onZeroAxisIndex: null,
            lineStyle: {color: "#333", width: 1, type: "solid"},
            symbol: ["none", "none"],
            symbolSize: [10, 15]
        },
        axisTick: {show: !0, inside: !1, length: 5, lineStyle: {width: 1}},
        axisLabel: {show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12},
        splitLine: {show: !0, lineStyle: {color: ["#ccc"], width: 1, type: "solid"}},
        splitArea: {show: !1, areaStyle: {color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]}}
    }, $k = {};
    $k.categoryAxis = o({
        boundaryGap: !0,
        deduplication: null,
        splitLine: {show: !1},
        axisTick: {alignWithLabel: !1, interval: "auto"},
        axisLabel: {interval: "auto"}
    }, Kk), $k.valueAxis = o({
        boundaryGap: [0, 0],
        splitNumber: 5,
        minorTick: {show: !1, splitNumber: 5, length: 3, lineStyle: {}},
        minorSplitLine: {show: !1, lineStyle: {color: "#eee", width: 1}}
    }, Kk), $k.timeAxis = s({scale: !0, min: "dataMin", max: "dataMax"}, $k.valueAxis), $k.logAxis = s({
        scale: !0,
        logBase: 10
    }, $k.valueAxis);
    var Jk = ["value", "category", "time", "log"], Qk = function (t, e, i, n) {
        f(Jk, function (r) {
            e.extend({
                type: t + "Axis." + r, mergeDefaultAndTheme: function (e, n) {
                    var a = this.layoutMode, s = a ? as(e) : {}, l = n.getTheme();
                    o(e, l.get(r + "Axis")), o(e, this.getDefaultOption()), e.type = i(t, e), a && os(e, s, a)
                }, optionUpdated: function () {
                    var t = this.option;
                    "category" === t.type && (this.__ordinalMeta = Ah.createByAxisModel(this))
                }, getCategories: function (t) {
                    var e = this.option;
                    return "category" === e.type ? t ? e.data : this.__ordinalMeta.categories : void 0
                }, getOrdinalMeta: function () {
                    return this.__ordinalMeta
                }, defaultOption: a([{}, $k[r + "Axis"], n], !0)
            })
        }), ID.registerSubTypeDefaulter(t + "Axis", x(i, t))
    }, tP = ID.extend({
        type: "cartesian2dAxis", axis: null, init: function () {
            tP.superApply(this, "init", arguments), this.resetRange()
        }, mergeOption: function () {
            tP.superApply(this, "mergeOption", arguments), this.resetRange()
        }, restoreData: function () {
            tP.superApply(this, "restoreData", arguments), this.resetRange()
        }, getCoordSysModel: function () {
            return this.ecModel.queryComponents({
                mainType: "grid",
                index: this.option.gridIndex,
                id: this.option.gridId
            })[0]
        }
    });
    o(tP.prototype, Ck);
    var eP = {offset: 0};
    Qk("x", tP, Pc, eP), Qk("y", tP, Pc, eP), ID.extend({
        type: "grid",
        dependencies: ["xAxis", "yAxis"],
        layoutMode: "box",
        coordinateSystem: null,
        defaultOption: {
            show: !1,
            zlevel: 0,
            z: 0,
            left: "10%",
            top: 60,
            right: "10%",
            bottom: 60,
            containLabel: !1,
            backgroundColor: "rgba(0,0,0,0)",
            borderWidth: 1,
            borderColor: "#ccc"
        }
    });
    var iP = Ec.prototype;
    iP.type = "grid", iP.axisPointerEnabled = !0, iP.getRect = function () {
        return this._rect
    }, iP.update = function (t, e) {
        var i = this._axesMap;
        this._updateScale(t, this.model), f(i.x, function (t) {
            qh(t.scale, t.model)
        }), f(i.y, function (t) {
            qh(t.scale, t.model)
        });
        var n = {};
        f(i.x, function (t) {
            Nc(i, "y", t, n)
        }), f(i.y, function (t) {
            Nc(i, "x", t, n)
        }), this.resize(this.model, e)
    }, iP.resize = function (t, e, i) {
        function n() {
            f(a, function (t) {
                var e = t.isHorizontal(), i = e ? [0, o.width] : [0, o.height], n = t.inverse ? 1 : 0;
                t.setExtent(i[n], i[1 - n]), zc(t, e ? o.x : o.y)
            })
        }

        var o = es(t.getBoxLayoutParams(), {width: e.getWidth(), height: e.getHeight()});
        this._rect = o;
        var a = this._axesList;
        n(), !i && t.get("containLabel") && (f(a, function (t) {
            if (!t.model.get("axisLabel.inside")) {
                var e = tc(t);
                if (e) {
                    var i = t.isHorizontal() ? "height" : "width", n = t.model.get("axisLabel.margin");
                    o[i] -= e[i] + n, "top" === t.position ? o.y += e.height + n : "left" === t.position && (o.x += e.width + n)
                }
            }
        }), n())
    }, iP.getAxis = function (t, e) {
        var i = this._axesMap[t];
        if (null != i) {
            if (null == e) for (var n in i) if (i.hasOwnProperty(n)) return i[n];
            return i[e]
        }
    }, iP.getAxes = function () {
        return this._axesList.slice()
    }, iP.getCartesian = function (t, e) {
        if (null != t && null != e) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i]
        }
        S(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
        for (var n = 0, o = this._coordsList; n < o.length; n++) if (o[n].getAxis("x").index === t || o[n].getAxis("y").index === e) return o[n]
    }, iP.getCartesians = function () {
        return this._coordsList.slice()
    }, iP.convertToPixel = function (t, e, i) {
        var n = this._findConvertTarget(t, e);
        return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null
    }, iP.convertFromPixel = function (t, e, i) {
        var n = this._findConvertTarget(t, e);
        return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null
    }, iP._findConvertTarget = function (t, e) {
        var i, n, o = e.seriesModel, a = e.xAxisModel || o && o.getReferringComponents("xAxis")[0],
            r = e.yAxisModel || o && o.getReferringComponents("yAxis")[0], s = e.gridModel, l = this._coordsList;
        if (o) i = o.coordinateSystem, u(l, i) < 0 && (i = null); else if (a && r) i = this.getCartesian(a.componentIndex, r.componentIndex); else if (a) n = this.getAxis("x", a.componentIndex); else if (r) n = this.getAxis("y", r.componentIndex); else if (s) {
            var h = s.coordinateSystem;
            h === this && (i = this._coordsList[0])
        }
        return {cartesian: i, axis: n}
    }, iP.containPoint = function (t) {
        var e = this._coordsList[0];
        return e ? e.containPoint(t) : void 0
    }, iP._initCartesian = function (t, e) {
        function i(i) {
            return function (r, s) {
                if (Oc(r, t, e)) {
                    var l = r.get("position");
                    "x" === i ? "top" !== l && "bottom" !== l && (l = n.bottom ? "top" : "bottom") : "left" !== l && "right" !== l && (l = n.left ? "right" : "left"), n[l] = !0;
                    var u = new qk(i, Kh(r), [0, 0], r.get("type"), l), h = "category" === u.type;
                    u.onBand = h && r.get("boundaryGap"), u.inverse = r.get("inverse"), r.axis = u, u.model = r, u.grid = this, u.index = s, this._axesList.push(u), o[i][s] = u, a[i]++
                }
            }
        }

        var n = {left: !1, right: !1, top: !1, bottom: !1}, o = {x: {}, y: {}}, a = {x: 0, y: 0};
        return e.eachComponent("xAxis", i("x"), this), e.eachComponent("yAxis", i("y"), this), a.x && a.y ? (this._axesMap = o, void f(o.x, function (e, i) {
            f(o.y, function (n, o) {
                var a = "x" + i + "y" + o, r = new kc(a);
                r.grid = this, r.model = t, this._coordsMap[a] = r, this._coordsList.push(r), r.addAxis(e), r.addAxis(n)
            }, this)
        }, this)) : (this._axesMap = {}, void (this._axesList = []))
    }, iP._updateScale = function (t, e) {
        function i(t, e) {
            f(t.mapDimension(e.dim, !0), function (i) {
                e.scale.unionExtentFromData(t, bh(t, i))
            })
        }

        f(this._axesList, function (t) {
            t.scale.setExtent(1 / 0, -1 / 0)
        }), t.eachSeries(function (n) {
            if (Vc(n)) {
                var o = Bc(n, t), a = o[0], r = o[1];
                if (!Oc(a, e, t) || !Oc(r, e, t)) return;
                var s = this.getCartesian(a.componentIndex, r.componentIndex), l = n.getData(), u = s.getAxis("x"),
                    h = s.getAxis("y");
                "list" === l.type && (i(l, u, n), i(l, h, n))
            }
        }, this)
    }, iP.getTooltipAxes = function (t) {
        var e = [], i = [];
        return f(this.getCartesians(), function (n) {
            var o = null != t && "auto" !== t ? n.getAxis(t) : n.getBaseAxis(), a = n.getOtherAxis(o);
            u(e, o) < 0 && e.push(o), u(i, a) < 0 && i.push(a)
        }), {baseAxes: e, otherAxes: i}
    };
    var nP = ["xAxis", "yAxis"];
    Ec.create = function (t, e) {
        var i = [];
        return t.eachComponent("grid", function (n, o) {
            var a = new Ec(n, t, e);
            a.name = "grid_" + o, a.resize(n, e, !0), n.coordinateSystem = a, i.push(a)
        }), t.eachSeries(function (e) {
            if (Vc(e)) {
                var i = Bc(e, t), n = i[0], o = i[1], a = n.getCoordSysModel();
                if (BS) {
                    if (!a) throw new Error('Grid "' + D(n.get("gridIndex"), n.get("gridId"), 0) + '" not found');
                    if (n.getCoordSysModel() !== o.getCoordSysModel()) throw new Error("xAxis and yAxis must use the same grid")
                }
                var r = a.coordinateSystem;
                e.coordinateSystem = r.getCartesian(n.componentIndex, o.componentIndex)
            }
        }), i
    }, Ec.dimensions = Ec.prototype.dimensions = kc.prototype.dimensions, Ps.register("cartesian2d", Ec);
    var oP = dC.extend({
        type: "series.__base_bar__",
        getInitialData: function () {
            return Sh(this.getSource(), this, {useEncodeDefaulter: !0})
        },
        getMarkerPosition: function (t) {
            var e = this.coordinateSystem;
            if (e) {
                var i = e.dataToPoint(e.clampData(t)), n = this.getData(), o = n.getLayout("offset"),
                    a = n.getLayout("size"), r = e.getBaseAxis().isHorizontal() ? 0 : 1;
                return i[r] += o + a / 2, i
            }
            return [0 / 0, 0 / 0]
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            barMinHeight: 0,
            barMinAngle: 0,
            large: !1,
            largeThreshold: 400,
            progressive: 3e3,
            progressiveChunkMode: "mod",
            itemStyle: {},
            emphasis: {}
        }
    });
    oP.extend({
        type: "series.bar",
        dependencies: ["grid", "polar"],
        brushSelector: "rect",
        getProgressive: function () {
            return this.get("large") ? this.get("progressive") : !1
        },
        getProgressiveThreshold: function () {
            var t = this.get("progressiveThreshold"), e = this.get("largeThreshold");
            return e > t && (t = e), t
        },
        defaultOption: {
            clip: !0,
            roundCap: !1,
            showBackground: !1,
            backgroundStyle: {
                color: "rgba(180, 180, 180, 0.2)",
                borderColor: null,
                borderWidth: 0,
                borderType: "solid",
                borderRadius: 0,
                shadowBlur: 0,
                shadowColor: null,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                opacity: 1
            }
        }
    });
    var aP = hT([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]),
        rP = {
            getBarItemStyle: function (t) {
                var e = aP(this, t);
                if (this.getBorderLineDash) {
                    var i = this.getBorderLineDash();
                    i && (e.lineDash = i)
                }
                return e
            }
        }, sP = xa({
            type: "sausage",
            shape: {cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
            buildPath: function (t, e) {
                var i = e.cx, n = e.cy, o = Math.max(e.r0 || 0, 0), a = Math.max(e.r, 0), r = .5 * (a - o), s = o + r,
                    l = e.startAngle, u = e.endAngle, h = e.clockwise, c = Math.cos(l), d = Math.sin(l), f = Math.cos(u),
                    p = Math.sin(u), g = h ? u - l < 2 * Math.PI : l - u < 2 * Math.PI;
                g && (t.moveTo(c * o + i, d * o + n), t.arc(c * s + i, d * s + n, r, -Math.PI + l, l, !h)), t.arc(i, n, a, l, u, !h), t.moveTo(f * a + i, p * a + n), t.arc(f * s + i, p * s + n, r, u - 2 * Math.PI, u - Math.PI, !h), 0 !== o && (t.arc(i, n, o, u, l, h), t.moveTo(c * o + i, p * o + n)), t.closePath()
            }
        }), lP = ["itemStyle", "barBorderWidth"], uP = [0, 0];
    r(vr.prototype, rP), Wu({
        type: "bar", render: function (t, e, i) {
            this._updateDrawMode(t);
            var n = t.get("coordinateSystem");
            return "cartesian2d" === n || "polar" === n ? this._isLargeDraw ? this._renderLarge(t, e, i) : this._renderNormal(t, e, i) : BS && console.warn("Only cartesian2d and polar supported for bar."), this.group
        }, incrementalPrepareRender: function (t) {
            this._clear(), this._updateDrawMode(t)
        }, incrementalRender: function (t, e) {
            this._incrementalRenderLarge(t, e)
        }, _updateDrawMode: function (t) {
            var e = t.pipelineContext.large;
            (null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear())
        }, _renderNormal: function (t) {
            var e, i = this.group, n = t.getData(), o = this._data, a = t.coordinateSystem, r = a.getBaseAxis();
            "cartesian2d" === a.type ? e = r.isHorizontal() : "polar" === a.type && (e = "angle" === r.dim);
            var s = t.isAnimationEnabled() ? t : null, l = t.get("clip", !0), u = Xc(a, n);
            i.removeClipPath();
            var h = t.get("roundCap", !0), c = t.get("showBackground", !0), d = t.getModel("backgroundStyle"),
                f = d.get("barBorderRadius") || 0, p = [], g = this._backgroundEls || [], m = function (t) {
                    var i = pP[a.type](n, t), o = nd(a, e, i);
                    return o.useStyle(d.getBarItemStyle()), "cartesian2d" === a.type && o.setShape("r", f), p[t] = o, o
                };
            n.diff(o).add(function (o) {
                var r = n.getItemModel(o), d = pP[a.type](n, o, r);
                if (c && m(o), n.hasValue(o)) {
                    if (l) {
                        var f = dP[a.type](u, d);
                        if (f) return void i.remove(p)
                    }
                    var p = fP[a.type](o, d, e, s, !1, h);
                    n.setItemGraphicEl(o, p), i.add(p), Kc(p, n, o, r, d, t, e, "polar" === a.type)
                }
            }).update(function (r, v) {
                var y = n.getItemModel(r), x = pP[a.type](n, r, y);
                if (c) {
                    var _;
                    0 === g.length ? _ = m(v) : (_ = g[v], _.useStyle(d.getBarItemStyle()), "cartesian2d" === a.type && _.setShape("r", f), p[r] = _);
                    var w = pP[a.type](n, r), b = id(e, w, a);
                    or(_, {shape: b}, s, r)
                }
                var S = o.getItemGraphicEl(v);
                if (!n.hasValue(r)) return void i.remove(S);
                if (l) {
                    var M = dP[a.type](u, x);
                    if (M) return void i.remove(S)
                }
                S ? or(S, {shape: x}, s, r) : S = fP[a.type](r, x, e, s, !0, h), n.setItemGraphicEl(r, S), i.add(S), Kc(S, n, r, y, x, t, e, "polar" === a.type)
            }).remove(function (t) {
                var e = o.getItemGraphicEl(t);
                "cartesian2d" === a.type ? e && Yc(t, s, e) : e && jc(t, s, e)
            }).execute();
            var v = this._backgroundGroup || (this._backgroundGroup = new iI);
            v.removeAll();
            for (var y = 0; y < p.length; ++y) v.add(p[y]);
            i.add(v), this._backgroundEls = p, this._data = n
        }, _renderLarge: function (t) {
            this._clear(), Jc(t, this.group);
            var e = t.get("clip", !0) ? Uc(t.coordinateSystem, !1, t) : null;
            e ? this.group.setClipPath(e) : this.group.removeClipPath()
        }, _incrementalRenderLarge: function (t, e) {
            this._removeBackground(), Jc(e, this.group, !0)
        }, dispose: G, remove: function (t) {
            this._clear(t)
        }, _clear: function (t) {
            var e = this.group, i = this._data;
            t && t.get("animation") && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function (e) {
                "sector" === e.type ? jc(e.dataIndex, t, e) : Yc(e.dataIndex, t, e)
            })) : e.removeAll(), this._data = null
        }, _removeBackground: function () {
            this.group.remove(this._backgroundGroup), this._backgroundGroup = null
        }
    });
    var hP = Math.max, cP = Math.min, dP = {
        cartesian2d: function (t, e) {
            var i = e.width < 0 ? -1 : 1, n = e.height < 0 ? -1 : 1;
            0 > i && (e.x += e.width, e.width = -e.width), 0 > n && (e.y += e.height, e.height = -e.height);
            var o = hP(e.x, t.x), a = cP(e.x + e.width, t.x + t.width), r = hP(e.y, t.y),
                s = cP(e.y + e.height, t.y + t.height);
            e.x = o, e.y = r, e.width = a - o, e.height = s - r;
            var l = e.width < 0 || e.height < 0;
            return 0 > i && (e.x += e.width, e.width = -e.width), 0 > n && (e.y += e.height, e.height = -e.height), l
        }, polar: function (t, e) {
            var i = e.r0 <= e.r ? 1 : -1;
            if (0 > i) {
                var n = e.r;
                e.r = e.r0, e.r0 = n
            }
            var n = cP(e.r, t.r), o = hP(e.r0, t.r0);
            e.r = n, e.r0 = o;
            var a = 0 > n - o;
            if (0 > i) {
                var n = e.r;
                e.r = e.r0, e.r0 = n
            }
            return a
        }
    }, fP = {
        cartesian2d: function (t, e, i, n, o) {
            var a = new CA({shape: r({}, e), z2: 1});
            if (a.name = "item", n) {
                var s = a.shape, l = i ? "height" : "width", u = {};
                s[l] = 0, u[l] = e[l], tD[o ? "updateProps" : "initProps"](a, {shape: u}, n, t)
            }
            return a
        }, polar: function (t, e, i, n, o, a) {
            var r = e.startAngle < e.endAngle, l = !i && a ? sP : wA, u = new l({shape: s({clockwise: r}, e), z2: 1});
            if (u.name = "item", n) {
                var h = u.shape, c = i ? "r" : "endAngle", d = {};
                h[c] = i ? 0 : e.startAngle, d[c] = e[c], tD[o ? "updateProps" : "initProps"](u, {shape: d}, n, t)
            }
            return u
        }
    }, pP = {
        cartesian2d: function (t, e, i) {
            var n = t.getItemLayout(e), o = i ? $c(i, n) : 0, a = n.width > 0 ? 1 : -1, r = n.height > 0 ? 1 : -1;
            return {x: n.x + a * o / 2, y: n.y + r * o / 2, width: n.width - a * o, height: n.height - r * o}
        }, polar: function (t, e) {
            var i = t.getItemLayout(e);
            return {cx: i.cx, cy: i.cy, r0: i.r0, r: i.r, startAngle: i.startAngle, endAngle: i.endAngle}
        }
    }, gP = aa.extend({
        type: "largeBar", shape: {points: []}, buildPath: function (t, e) {
            for (var i = e.points, n = this.__startPoint, o = this.__baseDimIdx, a = 0; a < i.length; a += 2) n[o] = i[a + o], t.moveTo(n[0], n[1]), t.lineTo(i[a], i[a + 1])
        }
    }), mP = Sl(function (t) {
        var e = this, i = Qc(e, t.offsetX, t.offsetY);
        e.dataIndex = i >= 0 ? i : null
    }, 30, !1), vP = Math.PI, yP = function (t, e) {
        this.opt = e, this.axisModel = t, s(e, {
            labelOffset: 0,
            nameDirection: 1,
            tickDirection: 1,
            labelDirection: 1,
            silent: !0
        }), this.group = new iI;
        var i = new iI({position: e.position.slice(), rotation: e.rotation});
        i.updateTransform(), this._transform = i.transform, this._dumbGroup = i
    };
    yP.prototype = {
        constructor: yP, hasBuilder: function (t) {
            return !!xP[t]
        }, add: function (t) {
            xP[t].call(this)
        }, getGroup: function () {
            return this.group
        }
    };
    var xP = {
        axisLine: function () {
            var t = this.opt, e = this.axisModel;
            if (e.get("axisLine.show")) {
                var i = this.axisModel.axis.getExtent(), n = this._transform, o = [i[0], 0], a = [i[1], 0];
                n && (ae(o, o, n), ae(a, a, n));
                var s = r({lineCap: "round"}, e.getModel("axisLine.lineStyle").getLineStyle());
                this.group.add(new kA({
                    anid: "line",
                    subPixelOptimize: !0,
                    shape: {x1: o[0], y1: o[1], x2: a[0], y2: a[1]},
                    style: s,
                    strokeContainThreshold: t.strokeContainThreshold || 5,
                    silent: !0,
                    z2: 1
                }));
                var l = e.get("axisLine.symbol"), u = e.get("axisLine.symbolSize"),
                    h = e.get("axisLine.symbolOffset") || 0;
                if ("number" == typeof h && (h = [h, h]), null != l) {
                    "string" == typeof l && (l = [l, l]), ("string" == typeof u || "number" == typeof u) && (u = [u, u]);
                    var c = u[0], d = u[1];
                    f([{rotate: t.rotation + Math.PI / 2, offset: h[0], r: 0}, {
                        rotate: t.rotation - Math.PI / 2,
                        offset: h[1],
                        r: Math.sqrt((o[0] - a[0]) * (o[0] - a[0]) + (o[1] - a[1]) * (o[1] - a[1]))
                    }], function (e, i) {
                        if ("none" !== l[i] && null != l[i]) {
                            var n = ac(l[i], -c / 2, -d / 2, c, d, s.stroke, !0), a = e.r + e.offset,
                                r = [o[0] + a * Math.cos(t.rotation), o[1] - a * Math.sin(t.rotation)];
                            n.attr({rotation: e.rotate, position: r, silent: !0, z2: 11}), this.group.add(n)
                        }
                    }, this)
                }
            }
        }, axisTickLabel: function () {
            var t = this.axisModel, e = this.opt, i = hd(this, t, e), n = dd(this, t, e);
            ad(t, n, i), cd(this, t, e)
        }, axisName: function () {
            var t = this.opt, e = this.axisModel, i = D(t.axisName, e.get("name"));
            if (i) {
                var n, o = e.get("nameLocation"), a = t.nameDirection, s = e.getModel("nameTextStyle"),
                    l = e.get("nameGap") || 0, u = this.axisModel.axis.getExtent(), h = u[0] > u[1] ? -1 : 1,
                    c = ["start" === o ? u[0] - h * l : "end" === o ? u[1] + h * l : (u[0] + u[1]) / 2, ld(o) ? t.labelOffset + a * l : 0],
                    d = e.get("nameRotate");
                null != d && (d = d * vP / 180);
                var f;
                ld(o) ? n = wP(t.rotation, null != d ? d : t.rotation, a) : (n = od(t, o, d || 0, u), f = t.axisNameAvailableWidth, null != f && (f = Math.abs(f / Math.sin(n.rotation)), !isFinite(f) && (f = null)));
                var p = s.getFont(), g = e.get("nameTruncate", !0) || {}, m = g.ellipsis,
                    v = D(t.nameTruncateMaxWidth, g.maxWidth, f),
                    y = null != m && null != v ? vD(i, v, p, m, {minChar: 2, placeholder: g.placeholder}) : i,
                    x = e.get("tooltip", !0), _ = e.mainType, w = {componentType: _, name: i, $vars: ["name"]};
                w[_ + "Index"] = e.componentIndex;
                var b = new vA({
                    anid: "name",
                    __fullText: i,
                    __truncatedText: y,
                    position: c,
                    rotation: n.rotation,
                    silent: bP(e),
                    z2: 1,
                    tooltip: x && x.show ? r({
                        content: i, formatter: function () {
                            return i
                        }, formatterParams: w
                    }, x) : null
                });
                ja(b.style, s, {
                    text: y,
                    textFont: p,
                    textFill: s.getTextColor() || e.get("axisLine.lineStyle.color"),
                    textAlign: s.get("align") || n.textAlign,
                    textVerticalAlign: s.get("verticalAlign") || n.textVerticalAlign
                }), e.get("triggerEvent") && (b.eventData = _P(e), b.eventData.targetType = "axisName", b.eventData.name = i), this._dumbGroup.add(b), b.updateTransform(), this.group.add(b), b.decomposeTransform()
            }
        }
    }, _P = yP.makeAxisEventDataBase = function (t) {
        var e = {componentType: t.mainType, componentIndex: t.componentIndex};
        return e[t.mainType + "Index"] = t.componentIndex, e
    }, wP = yP.innerTextLayout = function (t, e, i) {
        var n, o, a = Pr(e - t);
        return Or(a) ? (o = i > 0 ? "top" : "bottom", n = "center") : Or(a - vP) ? (o = i > 0 ? "bottom" : "top", n = "center") : (o = "middle", n = a > 0 && vP > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
            rotation: a,
            textAlign: n,
            textVerticalAlign: o
        }
    }, bP = yP.isLabelSilent = function (t) {
        var e = t.get("tooltip");
        return t.get("silent") || !(t.get("triggerEvent") || e && e.show)
    }, SP = f, MP = x, IP = Gu({
        type: "axis", _axisPointer: null, axisPointerClass: null, render: function (t, e, i, n) {
            this.axisPointerClass && xd(t), IP.superApply(this, "render", arguments), Md(this, t, e, i, n, !0)
        }, updateAxisPointer: function (t, e, i, n) {
            Md(this, t, e, i, n, !1)
        }, remove: function (t, e) {
            var i = this._axisPointer;
            i && i.remove(e), IP.superApply(this, "remove", arguments)
        }, dispose: function (t, e) {
            Id(this, e), IP.superApply(this, "dispose", arguments)
        }
    }), TP = [];
    IP.registerAxisPointerClass = function (t, e) {
        if (BS && TP[t]) throw new Error("axisPointer " + t + " exists");
        TP[t] = e
    }, IP.getAxisPointerClass = function (t) {
        return t && TP[t]
    };
    var AP = ["axisLine", "axisTickLabel", "axisName"], DP = ["splitArea", "splitLine", "minorSplitLine"],
        CP = IP.extend({
            type: "cartesianAxis", axisPointerClass: "CartesianAxisPointer", render: function (t, e, i, n) {
                this.group.removeAll();
                var o = this._axisGroup;
                if (this._axisGroup = new iI, this.group.add(this._axisGroup), t.get("show")) {
                    var a = t.getCoordSysModel(), r = Td(a, t), s = new yP(t, r);
                    f(AP, s.add, s), this._axisGroup.add(s.getGroup()), f(DP, function (e) {
                        t.get(e + ".show") && this["_" + e](t, a)
                    }, this), ur(o, this._axisGroup, t), CP.superCall(this, "render", t, e, i, n)
                }
            }, remove: function () {
                Dd(this)
            }, _splitLine: function (t, e) {
                var i = t.axis;
                if (!i.scale.isBlank()) {
                    var n = t.getModel("splitLine"), o = n.getModel("lineStyle"), a = o.get("color");
                    a = _(a) ? a : [a];
                    for (var r = e.coordinateSystem.getRect(), l = i.isHorizontal(), u = 0, h = i.getTicksCoords({tickModel: n}), c = [], d = [], f = o.getLineStyle(), p = 0; p < h.length; p++) {
                        var g = i.toGlobalCoord(h[p].coord);
                        l ? (c[0] = g, c[1] = r.y, d[0] = g, d[1] = r.y + r.height) : (c[0] = r.x, c[1] = g, d[0] = r.x + r.width, d[1] = g);
                        var m = u++ % a.length, v = h[p].tickValue;
                        this._axisGroup.add(new kA({
                            anid: null != v ? "line_" + h[p].tickValue : null,
                            subPixelOptimize: !0,
                            shape: {x1: c[0], y1: c[1], x2: d[0], y2: d[1]},
                            style: s({stroke: a[m]}, f),
                            silent: !0
                        }))
                    }
                }
            }, _minorSplitLine: function (t, e) {
                var i = t.axis, n = t.getModel("minorSplitLine"), o = n.getModel("lineStyle"),
                    a = e.coordinateSystem.getRect(), r = i.isHorizontal(), s = i.getMinorTicksCoords();
                if (s.length) for (var l = [], u = [], h = o.getLineStyle(), c = 0; c < s.length; c++) for (var d = 0; d < s[c].length; d++) {
                    var f = i.toGlobalCoord(s[c][d].coord);
                    r ? (l[0] = f, l[1] = a.y, u[0] = f, u[1] = a.y + a.height) : (l[0] = a.x, l[1] = f, u[0] = a.x + a.width, u[1] = f), this._axisGroup.add(new kA({
                        anid: "minor_line_" + s[c][d].tickValue,
                        subPixelOptimize: !0,
                        shape: {x1: l[0], y1: l[1], x2: u[0], y2: u[1]},
                        style: h,
                        silent: !0
                    }))
                }
            }, _splitArea: function (t, e) {
                Ad(this, this._axisGroup, t, e)
            }
        });
    CP.extend({type: "xAxis"}), CP.extend({type: "yAxis"}), Gu({
        type: "grid", render: function (t) {
            this.group.removeAll(), t.get("show") && this.group.add(new CA({
                shape: t.coordinateSystem.getRect(),
                style: s({fill: t.get("backgroundColor")}, t.getItemStyle()),
                silent: !0,
                z2: -1
            }))
        }
    }), Cu(function (t) {
        t.xAxis && t.yAxis && !t.grid && (t.grid = {})
    }), Nu(mL.VISUAL.LAYOUT, x(Wh, "bar")), Nu(mL.VISUAL.PROGRESSIVE_LAYOUT, uk), Ru({
        seriesType: "bar",
        reset: function (t) {
            t.getData().setVisual("legendSymbol", "roundRect")
        }
    }), dC.extend({
        type: "series.line",
        dependencies: ["grid", "polar"],
        getInitialData: function (t) {
            if (BS) {
                var e = t.coordinateSystem;
                if ("polar" !== e && "cartesian2d" !== e) throw new Error("Line not support coordinateSystem besides cartesian and polar")
            }
            return Sh(this.getSource(), this, {useEncodeDefaulter: !0})
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            hoverAnimation: !0,
            clip: !0,
            label: {position: "top"},
            lineStyle: {width: 2, type: "solid"},
            step: !1,
            smooth: !1,
            smoothMonotone: null,
            symbol: "emptyCircle",
            symbolSize: 4,
            symbolRotate: null,
            showSymbol: !0,
            showAllSymbol: "auto",
            connectNulls: !1,
            sampling: "none",
            animationEasing: "linear",
            progressive: 0,
            hoverLayerThreshold: 1 / 0
        }
    });
    var LP = Cd.prototype, kP = Cd.getSymbolSize = function (t, e) {
        var i = t.getItemVisual(e, "symbolSize");
        return i instanceof Array ? i.slice() : [+i, +i]
    };
    LP._createSymbol = function (t, e, i, n, o) {
        this.removeAll();
        var a = e.getItemVisual(i, "color"), r = ac(t, -1, -1, 2, 2, a, o);
        r.attr({z2: 100, culling: !0, scale: Ld(n)}), r.drift = kd, this._symbolType = t, this.add(r)
    }, LP.stopSymbolAnimation = function (t) {
        this.childAt(0).stopAnimation(t)
    }, LP.getSymbolPath = function () {
        return this.childAt(0)
    }, LP.getScale = function () {
        return this.childAt(0).scale
    }, LP.highlight = function () {
        this.childAt(0).trigger("emphasis")
    }, LP.downplay = function () {
        this.childAt(0).trigger("normal")
    }, LP.setZ = function (t, e) {
        var i = this.childAt(0);
        i.zlevel = t, i.z = e
    }, LP.setDraggable = function (t) {
        var e = this.childAt(0);
        e.draggable = t, e.cursor = t ? "move" : e.cursor
    }, LP.updateData = function (t, e, i) {
        this.silent = !1;
        var n = t.getItemVisual(e, "symbol") || "circle", o = t.hostModel, a = kP(t, e), r = n !== this._symbolType;
        if (r) {
            var s = t.getItemVisual(e, "symbolKeepAspect");
            this._createSymbol(n, t, e, a, s)
        } else {
            var l = this.childAt(0);
            l.silent = !1, or(l, {scale: Ld(a)}, o, e)
        }
        if (this._updateCommon(t, e, a, i), r) {
            var l = this.childAt(0), u = i && i.fadeIn, h = {scale: l.scale.slice()};
            u && (h.style = {opacity: l.style.opacity}), l.scale = [0, 0], u && (l.style.opacity = 0), ar(l, h, o, e)
        }
        this._seriesModel = o
    };
    var PP = ["itemStyle"], OP = ["emphasis", "itemStyle"], EP = ["label"], NP = ["emphasis", "label"];
    LP._updateCommon = function (t, e, i, n) {
        function o(e) {
            return b ? t.getName(e) : Gc(t, e)
        }

        var a = this.childAt(0), s = t.hostModel, l = t.getItemVisual(e, "color");
        "image" !== a.type ? a.useStyle({strokeNoScale: !0}) : a.setStyle({
            opacity: 1,
            shadowBlur: null,
            shadowOffsetX: null,
            shadowOffsetY: null,
            shadowColor: null
        });
        var u = n && n.itemStyle, h = n && n.hoverItemStyle, c = n && n.symbolOffset, d = n && n.labelModel,
            f = n && n.hoverLabelModel, p = n && n.hoverAnimation, g = n && n.cursorStyle;
        if (!n || t.hasItemOption) {
            var m = n && n.itemModel ? n.itemModel : t.getItemModel(e);
            u = m.getModel(PP).getItemStyle(["color"]), h = m.getModel(OP).getItemStyle(), c = m.getShallow("symbolOffset"), d = m.getModel(EP), f = m.getModel(NP), p = m.getShallow("hoverAnimation"), g = m.getShallow("cursor")
        } else h = r({}, h);
        var v = a.style, y = t.getItemVisual(e, "symbolRotate");
        a.attr("rotation", (y || 0) * Math.PI / 180 || 0), c && a.attr("position", [Ir(c[0], i[0]), Ir(c[1], i[1])]), g && a.attr("cursor", g), a.setColor(l, n && n.symbolInnerColor), a.setStyle(u);
        var x = t.getItemVisual(e, "opacity");
        null != x && (v.opacity = x);
        var _ = t.getItemVisual(e, "liftZ"), w = a.__z2Origin;
        null != _ ? null == w && (a.__z2Origin = a.z2, a.z2 += _) : null != w && (a.z2 = w, a.__z2Origin = null);
        var b = n && n.useNameLabel;
        Xa(v, h, d, f, {
            labelFetcher: s,
            labelDataIndex: e,
            defaultText: o,
            isRectText: !0,
            autoColor: l
        }), a.__symbolOriginalScale = Ld(i), a.hoverStyle = h, a.highDownOnUpdate = p && s.isAnimationEnabled() ? Pd : null, Wa(a)
    }, LP.fadeOut = function (t, e) {
        var i = this.childAt(0);
        this.silent = i.silent = !0, !(e && e.keepLabel) && (i.style.text = null), or(i, {
            style: {opacity: 0},
            scale: [0, 0]
        }, this._seriesModel, this.dataIndex, t)
    }, h(Cd, iI);
    var RP = Od.prototype;
    RP.updateData = function (t, e) {
        e = Nd(e);
        var i = this.group, n = t.hostModel, o = this._data, a = this._symbolCtor, r = Rd(t);
        o || i.removeAll(), t.diff(o).add(function (n) {
            var o = t.getItemLayout(n);
            if (Ed(t, o, n, e)) {
                var s = new a(t, n, r);
                s.attr("position", o), t.setItemGraphicEl(n, s), i.add(s)
            }
        }).update(function (s, l) {
            var u = o.getItemGraphicEl(l), h = t.getItemLayout(s);
            return Ed(t, h, s, e) ? (u ? (u.updateData(t, s, r), or(u, {position: h}, n)) : (u = new a(t, s), u.attr("position", h)), i.add(u), void t.setItemGraphicEl(s, u)) : void i.remove(u)
        }).remove(function (t) {
            var e = o.getItemGraphicEl(t);
            e && e.fadeOut(function () {
                i.remove(e)
            })
        }).execute(), this._data = t
    }, RP.isPersistent = function () {
        return !0
    }, RP.updateLayout = function () {
        var t = this._data;
        t && t.eachItemGraphicEl(function (e, i) {
            var n = t.getItemLayout(i);
            e.attr("position", n)
        })
    }, RP.incrementalPrepareUpdate = function (t) {
        this._seriesScope = Rd(t), this._data = null, this.group.removeAll()
    }, RP.incrementalUpdate = function (t, e, i) {
        function n(t) {
            t.isGroup || (t.incremental = t.useHoverLayer = !0)
        }

        i = Nd(i);
        for (var o = t.start; o < t.end; o++) {
            var a = e.getItemLayout(o);
            if (Ed(e, a, o, i)) {
                var r = new this._symbolCtor(e, o, this._seriesScope);
                r.traverse(n), r.attr("position", a), this.group.add(r), e.setItemGraphicEl(o, r)
            }
        }
    }, RP.remove = function (t) {
        var e = this.group, i = this._data;
        i && t ? i.eachItemGraphicEl(function (t) {
            t.fadeOut(function () {
                e.remove(t)
            })
        }) : e.removeAll()
    };
    var zP = function (t, e, i, n, o, a, r, s) {
        for (var l = Gd(t, e), u = [], h = [], c = [], d = [], f = [], p = [], g = [], m = zd(o, e, r), v = zd(a, t, s), y = 0; y < l.length; y++) {
            var x = l[y], _ = !0;
            switch (x.cmd) {
                case"=":
                    var w = t.getItemLayout(x.idx), b = e.getItemLayout(x.idx1);
                    (isNaN(w[0]) || isNaN(w[1])) && (w = b.slice()), u.push(w), h.push(b), c.push(i[x.idx]), d.push(n[x.idx1]), g.push(e.getRawIndex(x.idx1));
                    break;
                case"+":
                    var S = x.idx;
                    u.push(o.dataToPoint([e.get(m.dataDimsForPoint[0], S), e.get(m.dataDimsForPoint[1], S)])), h.push(e.getItemLayout(S).slice()), c.push(Vd(m, o, e, S)), d.push(n[S]), g.push(e.getRawIndex(S));
                    break;
                case"-":
                    var S = x.idx, M = t.getRawIndex(S);
                    M !== S ? (u.push(t.getItemLayout(S)), h.push(a.dataToPoint([t.get(v.dataDimsForPoint[0], S), t.get(v.dataDimsForPoint[1], S)])), c.push(i[S]), d.push(Vd(v, a, t, S)), g.push(M)) : _ = !1
            }
            _ && (f.push(x), p.push(p.length))
        }
        p.sort(function (t, e) {
            return g[t] - g[e]
        });
        for (var I = [], T = [], A = [], D = [], C = [], y = 0; y < p.length; y++) {
            var S = p[y];
            I[y] = u[S], T[y] = h[S], A[y] = c[S], D[y] = d[S], C[y] = f[S]
        }
        return {current: I, next: T, stackedOnCurrent: A, stackedOnNext: D, status: C}
    }, BP = re, VP = se, GP = X, FP = W, WP = [], HP = [], ZP = [], UP = aa.extend({
        type: "ec-polyline",
        shape: {points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1},
        style: {fill: null, stroke: "#000"},
        brush: _A(aa.prototype.brush),
        buildPath: function (t, e) {
            var i = e.points, n = 0, o = i.length, a = Ud(i, e.smoothConstraint);
            if (e.connectNulls) {
                for (; o > 0 && Fd(i[o - 1]); o--) ;
                for (; o > n && Fd(i[n]); n++) ;
            }
            for (; o > n;) n += Wd(t, i, n, o, o, 1, a.min, a.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1
        }
    }), XP = aa.extend({
        type: "ec-polygon",
        shape: {
            points: [],
            stackedOnPoints: [],
            smooth: 0,
            stackedOnSmooth: 0,
            smoothConstraint: !0,
            smoothMonotone: null,
            connectNulls: !1
        },
        brush: _A(aa.prototype.brush),
        buildPath: function (t, e) {
            var i = e.points, n = e.stackedOnPoints, o = 0, a = i.length, r = e.smoothMonotone,
                s = Ud(i, e.smoothConstraint), l = Ud(n, e.smoothConstraint);
            if (e.connectNulls) {
                for (; a > 0 && Fd(i[a - 1]); a--) ;
                for (; a > o && Fd(i[o]); o++) ;
            }
            for (; a > o;) {
                var u = Wd(t, i, o, a, a, 1, s.min, s.max, e.smooth, r, e.connectNulls);
                Wd(t, n, o + u - 1, u, a, -1, l.min, l.max, e.stackedOnSmooth, r, e.connectNulls), o += u + 1, t.closePath()
            }
        }
    });
    yl.extend({
        type: "line", init: function () {
            var t = new iI, e = new Od;
            this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
        }, render: function (t, e, i) {
            var n = t.coordinateSystem, o = this.group, a = t.getData(), r = t.getModel("lineStyle"),
                l = t.getModel("areaStyle"), u = a.mapArray(a.getItemLayout), h = "polar" === n.type,
                c = this._coordSys, d = this._symbolDraw, f = this._polyline, p = this._polygon, g = this._lineGroup,
                m = t.get("animation"), v = !l.isEmpty(), y = l.get("origin"), x = zd(n, a, y), _ = qd(n, a, x),
                w = t.get("showSymbol"), b = w && !h && Jd(t, a, n), S = this._data;
            S && S.eachItemGraphicEl(function (t, e) {
                t.__temp && (o.remove(t), S.setItemGraphicEl(e, null))
            }), w || d.remove(), o.add(g);
            var M, I = !h && t.get("step");
            n && n.getArea && t.get("clip", !0) && (M = n.getArea(), null != M.width ? (M.x -= .1, M.y -= .1, M.width += .2, M.height += .2) : M.r0 && (M.r0 -= .5, M.r1 += .5)), this._clipShapeForSymbol = M, f && c.type === n.type && I === this._step ? (v && !p ? p = this._newPolygon(u, _, n, m) : p && !v && (g.remove(p), p = this._polygon = null), g.setClipPath(tf(n, !1, t)), w && d.updateData(a, {
                isIgnore: b,
                clipShape: M
            }), a.eachItemGraphicEl(function (t) {
                t.stopAnimation(!0)
            }), Xd(this._stackedOnPoints, _) && Xd(this._points, u) || (m ? this._updateAnimation(a, _, n, i, I, y) : (I && (u = Kd(u, n, I), _ = Kd(_, n, I)), f.setShape({points: u}), p && p.setShape({
                points: u,
                stackedOnPoints: _
            })))) : (w && d.updateData(a, {
                isIgnore: b,
                clipShape: M
            }), I && (u = Kd(u, n, I), _ = Kd(_, n, I)), f = this._newPolyline(u, n, m), v && (p = this._newPolygon(u, _, n, m)), g.setClipPath(tf(n, !0, t)));
            var T = $d(a, n) || a.getVisual("color");
            f.useStyle(s(r.getLineStyle(), {fill: "none", stroke: T, lineJoin: "bevel"}));
            var A = t.get("smooth");
            if (A = jd(t.get("smooth")), f.setShape({
                smooth: A,
                smoothMonotone: t.get("smoothMonotone"),
                connectNulls: t.get("connectNulls")
            }), p) {
                var D = a.getCalculationInfo("stackedOnSeries"), C = 0;
                p.useStyle(s(l.getAreaStyle(), {
                    fill: T,
                    opacity: .7,
                    lineJoin: "bevel"
                })), D && (C = jd(D.get("smooth"))), p.setShape({
                    smooth: A,
                    stackedOnSmooth: C,
                    smoothMonotone: t.get("smoothMonotone"),
                    connectNulls: t.get("connectNulls")
                })
            }
            this._data = a, this._coordSys = n, this._stackedOnPoints = _, this._points = u, this._step = I, this._valueOrigin = y
        }, dispose: function () {
        }, highlight: function (t, e, i, n) {
            var o = t.getData(), a = ho(o, n);
            if (!(a instanceof Array) && null != a && a >= 0) {
                var r = o.getItemGraphicEl(a);
                if (!r) {
                    var s = o.getItemLayout(a);
                    if (!s) return;
                    if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(s[0], s[1])) return;
                    r = new Cd(o, a), r.position = s, r.setZ(t.get("zlevel"), t.get("z")), r.ignore = isNaN(s[0]) || isNaN(s[1]), r.__temp = !0, o.setItemGraphicEl(a, r), r.stopSymbolAnimation(!0), this.group.add(r)
                }
                r.highlight()
            } else yl.prototype.highlight.call(this, t, e, i, n)
        }, downplay: function (t, e, i, n) {
            var o = t.getData(), a = ho(o, n);
            if (null != a && a >= 0) {
                var r = o.getItemGraphicEl(a);
                r && (r.__temp ? (o.setItemGraphicEl(a, null), this.group.remove(r)) : r.downplay())
            } else yl.prototype.downplay.call(this, t, e, i, n)
        }, _newPolyline: function (t) {
            var e = this._polyline;
            return e && this._lineGroup.remove(e), e = new UP({
                shape: {points: t},
                silent: !0,
                z2: 10
            }), this._lineGroup.add(e), this._polyline = e, e
        }, _newPolygon: function (t, e) {
            var i = this._polygon;
            return i && this._lineGroup.remove(i), i = new XP({
                shape: {points: t, stackedOnPoints: e},
                silent: !0
            }), this._lineGroup.add(i), this._polygon = i, i
        }, _updateAnimation: function (t, e, i, n, o, a) {
            var r = this._polyline, s = this._polygon, l = t.hostModel,
                u = zP(this._data, t, this._stackedOnPoints, e, this._coordSys, i, this._valueOrigin, a), h = u.current,
                c = u.stackedOnCurrent, d = u.next, f = u.stackedOnNext;
            if (o && (h = Kd(u.current, i, o), c = Kd(u.stackedOnCurrent, i, o), d = Kd(u.next, i, o), f = Kd(u.stackedOnNext, i, o)), Yd(h, d) > 3e3 || s && Yd(c, f) > 3e3) return r.setShape({points: d}), void (s && s.setShape({
                points: d,
                stackedOnPoints: f
            }));
            r.shape.__points = u.current, r.shape.points = h, or(r, {shape: {points: d}}, l), s && (s.setShape({
                points: h,
                stackedOnPoints: c
            }), or(s, {shape: {points: d, stackedOnPoints: f}}, l));
            for (var p = [], g = u.status, m = 0; m < g.length; m++) {
                var v = g[m].cmd;
                if ("=" === v) {
                    var y = t.getItemGraphicEl(g[m].idx1);
                    y && p.push({el: y, ptIdx: m})
                }
            }
            r.animators && r.animators.length && r.animators[0].during(function () {
                for (var t = 0; t < p.length; t++) {
                    var e = p[t].el;
                    e.attr("position", r.shape.__points[p[t].ptIdx])
                }
            })
        }, remove: function () {
            var t = this.group, e = this._data;
            this._lineGroup.removeAll(), this._symbolDraw.remove(!0), e && e.eachItemGraphicEl(function (i, n) {
                i.__temp && (t.remove(i), e.setItemGraphicEl(n, null))
            }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
        }
    });
    var YP = function (t, e, i) {
        return {
            seriesType: t, performRawSeries: !0, reset: function (t, n) {
                function o(e, i) {
                    if (f) {
                        var n = t.getRawValue(i), o = t.getDataParams(i);
                        h && e.setItemVisual(i, "symbol", r(n, o)), c && e.setItemVisual(i, "symbolSize", s(n, o)), d && e.setItemVisual(i, "symbolRotate", u(n, o))
                    }
                    if (e.hasItemOption) {
                        var a = e.getItemModel(i), l = a.getShallow("symbol", !0), p = a.getShallow("symbolSize", !0),
                            g = a.getShallow("symbolRotate", !0), m = a.getShallow("symbolKeepAspect", !0);
                        null != l && e.setItemVisual(i, "symbol", l), null != p && e.setItemVisual(i, "symbolSize", p), null != g && e.setItemVisual(i, "symbolRotate", g), null != m && e.setItemVisual(i, "symbolKeepAspect", m)
                    }
                }

                var a = t.getData(), r = t.get("symbol"), s = t.get("symbolSize"), l = t.get("symbolKeepAspect"),
                    u = t.get("symbolRotate"), h = w(r), c = w(s), d = w(u), f = h || c || d, p = !h && r ? r : e,
                    g = c ? null : s;
                return a.setVisual({
                    legendSymbol: i || p,
                    symbol: p,
                    symbolSize: g,
                    symbolKeepAspect: l,
                    symbolRotate: u
                }), n.isSeriesFiltered(t) ? void 0 : {dataEach: a.hasItemOption || f ? o : null}
            }
        }
    }, jP = function (t) {
        return {
            seriesType: t, plan: gC(), reset: function (t) {
                function e(t, e) {
                    for (var i = t.end - t.start, o = a && new Float32Array(i * s), l = t.start, u = 0, h = [], c = []; l < t.end; l++) {
                        var d;
                        if (1 === s) {
                            var f = e.get(r[0], l);
                            d = !isNaN(f) && n.dataToPoint(f, null, c)
                        } else {
                            var f = h[0] = e.get(r[0], l), p = h[1] = e.get(r[1], l);
                            d = !isNaN(f) && !isNaN(p) && n.dataToPoint(h, null, c)
                        }
                        a ? (o[u++] = d ? d[0] : 0 / 0, o[u++] = d ? d[1] : 0 / 0) : e.setItemLayout(l, d && d.slice() || [0 / 0, 0 / 0])
                    }
                    a && e.setLayout("symbolPoints", o)
                }

                var i = t.getData(), n = t.coordinateSystem, o = t.pipelineContext, a = o.large;
                if (n) {
                    var r = p(n.dimensions, function (t) {
                        return i.mapDimension(t)
                    }).slice(0, 2), s = r.length, l = i.getCalculationInfo("stackResultDimension");
                    return wh(i, r[0]) && (r[0] = l), wh(i, r[1]) && (r[1] = l), s && {progress: e}
                }
            }
        }
    }, qP = {
        average: function (t) {
            for (var e = 0, i = 0, n = 0; n < t.length; n++) isNaN(t[n]) || (e += t[n], i++);
            return 0 === i ? 0 / 0 : e / i
        }, sum: function (t) {
            for (var e = 0, i = 0; i < t.length; i++) e += t[i] || 0;
            return e
        }, max: function (t) {
            for (var e = -1 / 0, i = 0; i < t.length; i++) t[i] > e && (e = t[i]);
            return isFinite(e) ? e : 0 / 0
        }, min: function (t) {
            for (var e = 1 / 0, i = 0; i < t.length; i++) t[i] < e && (e = t[i]);
            return isFinite(e) ? e : 0 / 0
        }, nearest: function (t) {
            return t[0]
        }
    }, KP = function (t) {
        return Math.round(t.length / 2)
    }, $P = function (t) {
        return {
            seriesType: t, modifyOutputEnd: !0, reset: function (t) {
                var e = t.getData(), i = t.get("sampling"), n = t.coordinateSystem;
                if ("cartesian2d" === n.type && i) {
                    var o = n.getBaseAxis(), a = n.getOtherAxis(o), r = o.getExtent(), s = Math.abs(r[1] - r[0]),
                        l = Math.round(e.count() / s);
                    if (l > 1) {
                        var u;
                        "string" == typeof i ? u = qP[i] : "function" == typeof i && (u = i), u && t.setData(e.downSample(e.mapDimension(a.dim), 1 / l, u, KP))
                    }
                }
            }
        }
    };
    Ru(YP("line", "circle", "line")), Nu(jP("line")), Lu(mL.PROCESSOR.STATISTIC, $P("line"));
    var JP = function (t, e, i) {
        e = _(e) && {coordDimensions: e} || r({}, e);
        var n = t.getSource(), o = JL(n, e), a = new qL(o, t);
        return a.initData(n, i), a
    }, QP = {
        updateSelectedMap: function (t) {
            this._targetList = _(t) ? t.slice() : [], this._selectTargetMap = g(t || [], function (t, e) {
                return t.set(e.name, e), t
            }, B())
        }, select: function (t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t), n = this.get("selectedMode");
            "single" === n && this._selectTargetMap.each(function (t) {
                t.selected = !1
            }), i && (i.selected = !0)
        }, unSelect: function (t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
            i && (i.selected = !1)
        }, toggleSelected: function (t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
            return null != i ? (this[i.selected ? "unSelect" : "select"](t, e), i.selected) : void 0
        }, isSelected: function (t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
            return i && i.selected
        }
    }, tO = Fu({
        type: "series.pie",
        init: function (t) {
            tO.superApply(this, "init", arguments), this.legendVisualProvider = new ef(y(this.getData, this), y(this.getRawData, this)), this.updateSelectedMap(this._createSelectableList()), this._defaultLabelLine(t)
        },
        mergeOption: function (t) {
            tO.superCall(this, "mergeOption", t), this.updateSelectedMap(this._createSelectableList())
        },
        getInitialData: function () {
            return JP(this, {coordDimensions: ["value"], encodeDefaulter: x(xs, this)})
        },
        _createSelectableList: function () {
            for (var t = this.getRawData(), e = t.mapDimension("value"), i = [], n = 0, o = t.count(); o > n; n++) i.push({
                name: t.getName(n),
                value: t.get(e, n),
                selected: al(t, n, "selected")
            });
            return i
        },
        getDataParams: function (t) {
            var e = this.getData(), i = tO.superCall(this, "getDataParams", t), n = [];
            return e.each(e.mapDimension("value"), function (t) {
                n.push(t)
            }), i.percent = kr(n, t, e.hostModel.get("percentPrecision")), i.$vars.push("percent"), i
        },
        _defaultLabelLine: function (t) {
            io(t, "labelLine", ["show"]);
            var e = t.labelLine, i = t.emphasis.labelLine;
            e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            hoverAnimation: !0,
            center: ["50%", "50%"],
            radius: [0, "75%"],
            clockwise: !0,
            startAngle: 90,
            minAngle: 0,
            minShowLabelAngle: 0,
            selectedOffset: 10,
            hoverOffset: 10,
            avoidLabelOverlap: !0,
            percentPrecision: 2,
            stillShowZeroSum: !0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            width: null,
            height: null,
            label: {
                rotate: !1,
                show: !0,
                position: "outer",
                alignTo: "none",
                margin: "25%",
                bleedMargin: 10,
                distanceToLabelLine: 5
            },
            labelLine: {show: !0, length: 15, length2: 15, smooth: !1, lineStyle: {width: 1, type: "solid"}},
            itemStyle: {borderWidth: 1},
            animationType: "expansion",
            animationTypeUpdate: "transition",
            animationEasing: "cubicOut"
        }
    });
    c(tO, QP);
    var eO = af.prototype;
    eO.updateData = function (t, e, i) {
        var n = this.childAt(0), o = this.childAt(1), a = this.childAt(2), l = t.hostModel, u = t.getItemModel(e),
            h = t.getItemLayout(e), c = r({}, h);
        c.label = null;
        var d = l.getShallow("animationTypeUpdate");
        if (i) {
            n.setShape(c);
            var f = l.getShallow("animationType");
            "scale" === f ? (n.shape.r = h.r0, ar(n, {shape: {r: h.r}}, l, e)) : (n.shape.endAngle = h.startAngle, or(n, {shape: {endAngle: h.endAngle}}, l, e))
        } else "expansion" === d ? n.setShape(c) : or(n, {shape: c}, l, e);
        var p = t.getItemVisual(e, "color");
        n.useStyle(s({
            lineJoin: "bevel",
            fill: p
        }, u.getModel("itemStyle").getItemStyle())), n.hoverStyle = u.getModel("emphasis.itemStyle").getItemStyle();
        var g = u.getShallow("cursor");
        g && n.attr("cursor", g), of(this, t.getItemLayout(e), l.isSelected(t.getName(e)), l.get("selectedOffset"), l.get("animation"));
        var m = !i && "transition" === d;
        this._updateLabel(t, e, m), this.highDownOnUpdate = l.get("silent") ? null : function (t, e) {
            var i = l.isAnimationEnabled() && u.get("hoverAnimation");
            "emphasis" === e ? (o.ignore = o.hoverIgnore, a.ignore = a.hoverIgnore, i && (n.stopAnimation(!0), n.animateTo({shape: {r: h.r + l.get("hoverOffset")}}, 300, "elasticOut"))) : (o.ignore = o.normalIgnore, a.ignore = a.normalIgnore, i && (n.stopAnimation(!0), n.animateTo({shape: {r: h.r}}, 300, "elasticOut")))
        }, Wa(this)
    }, eO._updateLabel = function (t, e, i) {
        var n = this.childAt(1), o = this.childAt(2), a = t.hostModel, r = t.getItemModel(e), s = t.getItemLayout(e),
            l = s.label, u = t.getItemVisual(e, "color");
        if (!l || isNaN(l.x) || isNaN(l.y)) return void (o.ignore = o.normalIgnore = o.hoverIgnore = n.ignore = n.normalIgnore = n.hoverIgnore = !0);
        var h = {points: l.linePoints || [[l.x, l.y], [l.x, l.y], [l.x, l.y]]}, c = {x: l.x, y: l.y};
        i ? (or(n, {shape: h}, a, e), or(o, {style: c}, a, e)) : (n.attr({shape: h}), o.attr({style: c})), o.attr({
            rotation: l.rotation,
            origin: [l.x, l.y],
            z2: 10
        });
        var d = r.getModel("label"), f = r.getModel("emphasis.label"), p = r.getModel("labelLine"),
            g = r.getModel("emphasis.labelLine"), u = t.getItemVisual(e, "color");
        Xa(o.style, o.hoverStyle = {}, d, f, {
            labelFetcher: t.hostModel,
            labelDataIndex: e,
            defaultText: l.text,
            autoColor: u,
            useInsideStyle: !!l.inside
        }, {
            textAlign: l.textAlign,
            textVerticalAlign: l.verticalAlign,
            opacity: t.getItemVisual(e, "opacity")
        }), o.ignore = o.normalIgnore = !d.get("show"), o.hoverIgnore = !f.get("show"), n.ignore = n.normalIgnore = !p.get("show"), n.hoverIgnore = !g.get("show"), n.setStyle({
            stroke: u,
            opacity: t.getItemVisual(e, "opacity")
        }), n.setStyle(p.getModel("lineStyle").getLineStyle()), n.hoverStyle = g.getModel("lineStyle").getLineStyle();
        var m = p.get("smooth");
        m && m === !0 && (m = .4), n.setShape({smooth: m})
    }, h(af, iI);
    var iO = (yl.extend({
        type: "pie", init: function () {
            var t = new iI;
            this._sectorGroup = t
        }, render: function (t, e, i, n) {
            if (!n || n.from !== this.uid) {
                var o = t.getData(), a = this._data, r = this.group, s = e.get("animation"), l = !a,
                    u = t.get("animationType"), h = t.get("animationTypeUpdate"), c = x(nf, this.uid, t, s, i),
                    d = t.get("selectedMode");
                if (o.diff(a).add(function (t) {
                    var e = new af(o, t);
                    l && "scale" !== u && e.eachChild(function (t) {
                        t.stopAnimation(!0)
                    }), d && e.on("click", c), o.setItemGraphicEl(t, e), r.add(e)
                }).update(function (t, e) {
                    var i = a.getItemGraphicEl(e);
                    l || "transition" === h || i.eachChild(function (t) {
                        t.stopAnimation(!0)
                    }), i.updateData(o, t), i.off("click"), d && i.on("click", c), r.add(i), o.setItemGraphicEl(t, i)
                }).remove(function (t) {
                    var e = a.getItemGraphicEl(t);
                    r.remove(e)
                }).execute(), s && o.count() > 0 && (l ? "scale" !== u : "transition" !== h)) {
                    for (var f = o.getItemLayout(0), p = 1; isNaN(f.startAngle) && p < o.count(); ++p) f = o.getItemLayout(p);
                    var g = Math.max(i.getWidth(), i.getHeight()) / 2, m = y(r.removeClipPath, r);
                    r.setClipPath(this._createClipPath(f.cx, f.cy, g, f.startAngle, f.clockwise, m, t, l))
                } else r.removeClipPath();
                this._data = o
            }
        }, dispose: function () {
        }, _createClipPath: function (t, e, i, n, o, a, r, s) {
            var l = new wA({shape: {cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: o}}),
                u = s ? ar : or;
            return u(l, {shape: {endAngle: n + (o ? 1 : -1) * Math.PI * 2}}, r, a), l
        }, containPoint: function (t, e) {
            var i = e.getData(), n = i.getItemLayout(0);
            if (n) {
                var o = t[0] - n.cx, a = t[1] - n.cy, r = Math.sqrt(o * o + a * a);
                return r <= n.r && r >= n.r0
            }
        }
    }), function (t, e) {
        f(e, function (e) {
            e.update = "updateView", Pu(e, function (i, n) {
                var o = {};
                return n.eachComponent({mainType: "series", subType: t, query: i}, function (t) {
                    t[e.method] && t[e.method](i.name, i.dataIndex);
                    var n = t.getData();
                    n.each(function (e) {
                        var i = n.getName(e);
                        o[i] = t.isSelected(i) || !1
                    })
                }), {name: i.name, selected: o, seriesId: i.seriesId}
            })
        })
    }), nO = function (t) {
        return {
            getTargetSeries: function (e) {
                var i = {}, n = B();
                return e.eachSeriesByType(t, function (t) {
                    t.__paletteScope = i, n.set(t.uid, t)
                }), n
            }, reset: function (t) {
                var e = t.getRawData(), i = {}, n = t.getData();
                n.each(function (t) {
                    var e = n.getRawIndex(t);
                    i[e] = t
                }), e.each(function (o) {
                    var a, r = i[o], s = null != r && n.getItemVisual(r, "color", !0),
                        l = null != r && n.getItemVisual(r, "borderColor", !0);
                    if (s && l || (a = e.getItemModel(o)), !s) {
                        var u = a.get("itemStyle.color") || t.getColorFromPalette(e.getName(o) || o + "", t.__paletteScope, e.count());
                        null != r && n.setItemVisual(r, "color", u)
                    }
                    if (!l) {
                        var h = a.get("itemStyle.borderColor");
                        null != r && n.setItemVisual(r, "borderColor", h)
                    }
                })
            }
        }
    }, oO = Math.PI / 180, aO = function (t, e, i, n, o, a) {
        var r, s, l = t.getData(), u = [], h = !1, c = (t.get("minShowLabelAngle") || 0) * oO;
        l.each(function (n) {
            var a = l.getItemLayout(n), d = l.getItemModel(n), f = d.getModel("label"),
                p = f.get("position") || d.get("emphasis.label.position"), g = f.get("distanceToLabelLine"),
                m = f.get("alignTo"), v = Ir(f.get("margin"), i), y = f.get("bleedMargin"), x = f.getFont(),
                _ = d.getModel("labelLine"), w = _.get("length");
            w = Ir(w, i);
            var b = _.get("length2");
            if (b = Ir(b, i), !(a.angle < c)) {
                var S, M, I, T, A = (a.startAngle + a.endAngle) / 2, D = Math.cos(A), C = Math.sin(A);
                r = a.cx, s = a.cy;
                var L = t.getFormattedLabel(n, "normal") || l.getName(n), k = Xi(L, x, T, "top"),
                    P = "inside" === p || "inner" === p;
                if ("center" === p) S = a.cx, M = a.cy, T = "center"; else {
                    var O = (P ? (a.r + a.r0) / 2 * D : a.r * D) + r, E = (P ? (a.r + a.r0) / 2 * C : a.r * C) + s;
                    if (S = O + 3 * D, M = E + 3 * C, !P) {
                        var N = O + D * (w + e - a.r), R = E + C * (w + e - a.r), z = N + (0 > D ? -1 : 1) * b, B = R;
                        S = "edge" === m ? 0 > D ? o + v : o + i - v : z + (0 > D ? -g : g), M = B, I = [[O, E], [N, R], [z, B]]
                    }
                    T = P ? "center" : "edge" === m ? D > 0 ? "right" : "left" : D > 0 ? "left" : "right"
                }
                var V, G = f.get("rotate");
                V = "number" == typeof G ? G * (Math.PI / 180) : G ? 0 > D ? -A + Math.PI : -A : 0, h = !!V, a.label = {
                    x: S,
                    y: M,
                    position: p,
                    height: k.height,
                    len: w,
                    len2: b,
                    linePoints: I,
                    textAlign: T,
                    verticalAlign: "middle",
                    rotation: V,
                    inside: P,
                    labelDistance: g,
                    labelAlignTo: m,
                    labelMargin: v,
                    bleedMargin: y,
                    textRect: k,
                    text: L,
                    font: x
                }, P || u.push(a.label)
            }
        }), !h && t.get("avoidLabelOverlap") && sf(u, r, s, e, i, n, o, a)
    }, rO = 2 * Math.PI, sO = Math.PI / 180, lO = function (t, e, i) {
        e.eachSeriesByType(t, function (t) {
            var e = t.getData(), n = e.mapDimension("value"), o = uf(t, i), a = t.get("center"), r = t.get("radius");
            _(r) || (r = [0, r]), _(a) || (a = [a, a]);
            var s = Ir(o.width, i.getWidth()), l = Ir(o.height, i.getHeight()), u = Math.min(s, l),
                h = Ir(a[0], s) + o.x, c = Ir(a[1], l) + o.y, d = Ir(r[0], u / 2), f = Ir(r[1], u / 2),
                p = -t.get("startAngle") * sO, g = t.get("minAngle") * sO, m = 0;
            e.each(n, function (t) {
                !isNaN(t) && m++
            });
            var v = e.getSum(n), y = Math.PI / (v || m) * 2, x = t.get("clockwise"), w = t.get("roseType"),
                b = t.get("stillShowZeroSum"), S = e.getDataExtent(n);
            S[0] = 0;
            var M = rO, I = 0, T = p, A = x ? 1 : -1;
            if (e.each(n, function (t, i) {
                var n;
                if (isNaN(t)) return void e.setItemLayout(i, {
                    angle: 0 / 0,
                    startAngle: 0 / 0,
                    endAngle: 0 / 0,
                    clockwise: x,
                    cx: h,
                    cy: c,
                    r0: d,
                    r: w ? 0 / 0 : f,
                    viewRect: o
                });
                n = "area" !== w ? 0 === v && b ? y : t * y : rO / m, g > n ? (n = g, M -= g) : I += t;
                var a = T + A * n;
                e.setItemLayout(i, {
                    angle: n,
                    startAngle: T,
                    endAngle: a,
                    clockwise: x,
                    cx: h,
                    cy: c,
                    r0: d,
                    r: w ? Mr(t, S, [d, f]) : f,
                    viewRect: o
                }), T = a
            }), rO > M && m) if (.001 >= M) {
                var D = rO / m;
                e.each(n, function (t, i) {
                    if (!isNaN(t)) {
                        var n = e.getItemLayout(i);
                        n.angle = D, n.startAngle = p + A * i * D, n.endAngle = p + A * (i + 1) * D
                    }
                })
            } else y = M / I, T = p, e.each(n, function (t, i) {
                if (!isNaN(t)) {
                    var n = e.getItemLayout(i), o = n.angle === g ? g : t * y;
                    n.startAngle = T, n.endAngle = T + A * o, T += A * o
                }
            });
            aO(t, f, o.width, o.height, o.x, o.y)
        })
    }, uO = function (t) {
        return {
            seriesType: t, reset: function (t, e) {
                var i = e.findComponents({mainType: "legend"});
                if (i && i.length) {
                    var n = t.getData();
                    n.filterSelf(function (t) {
                        for (var e = n.getName(t), o = 0; o < i.length; o++) if (!i[o].isSelected(e)) return !1;
                        return !0
                    })
                }
            }
        }
    };
    iO("pie", [{type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected"}, {
        type: "pieSelect",
        event: "pieselected",
        method: "select"
    }, {
        type: "pieUnSelect",
        event: "pieunselected",
        method: "unSelect"
    }]), Ru(nO("pie")), Nu(x(lO, "pie")), Lu(uO("pie")), dC.extend({
        type: "series.scatter",
        dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
        getInitialData: function () {
            return Sh(this.getSource(), this, {useEncodeDefaulter: !0})
        },
        brushSelector: "point",
        getProgressive: function () {
            var t = this.option.progressive;
            return null == t ? this.option.large ? 5e3 : this.get("progressive") : t
        },
        getProgressiveThreshold: function () {
            var t = this.option.progressiveThreshold;
            return null == t ? this.option.large ? 1e4 : this.get("progressiveThreshold") : t
        },
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            hoverAnimation: !0,
            symbolSize: 10,
            large: !1,
            largeThreshold: 2e3,
            itemStyle: {opacity: .8},
            clip: !0
        }
    });
    var hO = 4, cO = xa({
        shape: {points: null}, symbolProxy: null, softClipShape: null, buildPath: function (t, e) {
            var i = e.points, n = e.size, o = this.symbolProxy, a = o.shape, r = t.getContext ? t.getContext() : t,
                s = r && n[0] < hO;
            if (!s) for (var l = 0; l < i.length;) {
                var u = i[l++], h = i[l++];
                isNaN(u) || isNaN(h) || (!this.softClipShape || this.softClipShape.contain(u, h)) && (a.x = u - n[0] / 2, a.y = h - n[1] / 2, a.width = n[0], a.height = n[1], o.buildPath(t, a, !0))
            }
        }, afterBrush: function (t) {
            var e = this.shape, i = e.points, n = e.size, o = n[0] < hO;
            if (o) {
                this.setTransform(t);
                for (var a = 0; a < i.length;) {
                    var r = i[a++], s = i[a++];
                    isNaN(r) || isNaN(s) || (!this.softClipShape || this.softClipShape.contain(r, s)) && t.fillRect(r - n[0] / 2, s - n[1] / 2, n[0], n[1])
                }
                this.restoreTransform(t)
            }
        }, findDataIndex: function (t, e) {
            for (var i = this.shape, n = i.points, o = i.size, a = Math.max(o[0], 4), r = Math.max(o[1], 4), s = n.length / 2 - 1; s >= 0; s--) {
                var l = 2 * s, u = n[l] - a / 2, h = n[l + 1] - r / 2;
                if (t >= u && e >= h && u + a >= t && h + r >= e) return s
            }
            return -1
        }
    }), dO = hf.prototype;
    dO.isPersistent = function () {
        return !this._incremental
    }, dO.updateData = function (t, e) {
        this.group.removeAll();
        var i = new cO({rectHover: !0, cursor: "default"});
        i.setShape({points: t.getLayout("symbolPoints")}), this._setCommon(i, t, !1, e), this.group.add(i), this._incremental = null
    }, dO.updateLayout = function (t) {
        if (!this._incremental) {
            var e = t.getLayout("symbolPoints");
            this.group.eachChild(function (t) {
                if (null != t.startIndex) {
                    var i = 2 * (t.endIndex - t.startIndex), n = 4 * t.startIndex * 2;
                    e = new Float32Array(e.buffer, n, i)
                }
                t.setShape("points", e)
            })
        }
    }, dO.incrementalPrepareUpdate = function (t) {
        this.group.removeAll(), this._clearIncremental(), t.count() > 2e6 ? (this._incremental || (this._incremental = new ya({silent: !0})), this.group.add(this._incremental)) : this._incremental = null
    }, dO.incrementalUpdate = function (t, e, i) {
        var n;
        this._incremental ? (n = new cO, this._incremental.addDisplayable(n, !0)) : (n = new cO({
            rectHover: !0,
            cursor: "default",
            startIndex: t.start,
            endIndex: t.end
        }), n.incremental = !0, this.group.add(n)), n.setShape({points: e.getLayout("symbolPoints")}), this._setCommon(n, e, !!this._incremental, i)
    }, dO._setCommon = function (t, e, i, n) {
        var o = e.hostModel;
        n = n || {};
        var a = e.getVisual("symbolSize");
        t.setShape("size", a instanceof Array ? a : [a, a]), t.softClipShape = n.clipShape || null, t.symbolProxy = ac(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
        var r = t.shape.size[0] < hO;
        t.useStyle(o.getModel("itemStyle").getItemStyle(r ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
        var s = e.getVisual("color");
        s && t.setColor(s), i || (t.seriesIndex = o.seriesIndex, t.on("mousemove", function (e) {
            t.dataIndex = null;
            var i = t.findDataIndex(e.offsetX, e.offsetY);
            i >= 0 && (t.dataIndex = i + (t.startIndex || 0))
        }))
    }, dO.remove = function () {
        this._clearIncremental(), this._incremental = null, this.group.removeAll()
    }, dO._clearIncremental = function () {
        var t = this._incremental;
        t && t.clearDisplaybles()
    }, Wu({
        type: "scatter", render: function (t) {
            var e = t.getData(), i = this._updateSymbolDraw(e, t);
            i.updateData(e, {clipShape: this._getClipShape(t)}), this._finished = !0
        }, incrementalPrepareRender: function (t) {
            var e = t.getData(), i = this._updateSymbolDraw(e, t);
            i.incrementalPrepareUpdate(e), this._finished = !1
        }, incrementalRender: function (t, e) {
            this._symbolDraw.incrementalUpdate(t, e.getData(), {clipShape: this._getClipShape(e)}), this._finished = t.end === e.getData().count()
        }, updateTransform: function (t) {
            var e = t.getData();
            if (this.group.dirty(), !this._finished || e.count() > 1e4 || !this._symbolDraw.isPersistent()) return {update: !0};
            var i = jP().reset(t);
            i.progress && i.progress({start: 0, end: e.count()}, e), this._symbolDraw.updateLayout(e)
        }, _getClipShape: function (t) {
            var e = t.coordinateSystem, i = e && e.getArea && e.getArea();
            return t.get("clip", !0) ? i : null
        }, _updateSymbolDraw: function (t, e) {
            var i = this._symbolDraw, n = e.pipelineContext, o = n.large;
            return i && o === this._isLargeDraw || (i && i.remove(), i = this._symbolDraw = o ? new hf : new Od, this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i
        }, remove: function () {
            this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null
        }, dispose: function () {
        }
    }), Ru(YP("scatter", "circle")), Nu(jP("scatter")), dC.extend({
        type: "series.effectScatter",
        dependencies: ["grid", "polar"],
        getInitialData: function () {
            return Sh(this.getSource(), this, {useEncodeDefaulter: !0})
        },
        brushSelector: "point",
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            effectType: "ripple",
            progressive: 0,
            showEffectOn: "render",
            rippleEffect: {period: 4, scale: 2.5, brushType: "fill"},
            symbolSize: 10
        }
    });
    var fO = 3, pO = ff.prototype;
    pO.stopEffectAnimation = function () {
        this.childAt(1).removeAll()
    }, pO.startEffectAnimation = function (t) {
        for (var e = t.symbolType, i = t.color, n = this.childAt(1), o = 0; fO > o; o++) {
            var a = ac(e, -1, -1, 2, 2, i);
            a.attr({style: {strokeNoScale: !0}, z2: 99, silent: !0, scale: [.5, .5]});
            var r = -o / fO * t.period + t.effectOffset;
            a.animate("", !0).when(t.period, {scale: [t.rippleScale / 2, t.rippleScale / 2]}).delay(r).start(), a.animateStyle(!0).when(t.period, {opacity: 0}).delay(r).start(), n.add(a)
        }
        df(n, t)
    }, pO.updateEffectAnimation = function (t) {
        for (var e = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale"], o = 0; o < n.length; o++) {
            var a = n[o];
            if (e[a] !== t[a]) return this.stopEffectAnimation(), void this.startEffectAnimation(t)
        }
        df(i, t)
    }, pO.highlight = function () {
        this.trigger("emphasis")
    }, pO.downplay = function () {
        this.trigger("normal")
    }, pO.updateData = function (t, e) {
        var i = t.hostModel;
        this.childAt(0).updateData(t, e);
        var n = this.childAt(1), o = t.getItemModel(e), a = t.getItemVisual(e, "symbol"),
            r = cf(t.getItemVisual(e, "symbolSize")), s = t.getItemVisual(e, "color");
        n.attr("scale", r), n.traverse(function (t) {
            t.attr({fill: s})
        });
        var l = o.getShallow("symbolOffset");
        if (l) {
            var u = n.position;
            u[0] = Ir(l[0], r[0]), u[1] = Ir(l[1], r[1])
        }
        var h = t.getItemVisual(e, "symbolRotate");
        n.rotation = (h || 0) * Math.PI / 180 || 0;
        var c = {};
        if (c.showEffectOn = i.get("showEffectOn"), c.rippleScale = o.get("rippleEffect.scale"), c.brushType = o.get("rippleEffect.brushType"), c.period = 1e3 * o.get("rippleEffect.period"), c.effectOffset = e / t.count(), c.z = o.getShallow("z") || 0, c.zlevel = o.getShallow("zlevel") || 0, c.symbolType = a, c.color = s, c.rippleEffectColor = o.get("rippleEffect.color"), this.off("mouseover").off("mouseout").off("emphasis").off("normal"), "render" === c.showEffectOn) this._effectCfg ? this.updateEffectAnimation(c) : this.startEffectAnimation(c), this._effectCfg = c; else {
            this._effectCfg = null, this.stopEffectAnimation();
            var d = this.childAt(0), f = function () {
                d.highlight(), "render" !== c.showEffectOn && this.startEffectAnimation(c)
            }, p = function () {
                d.downplay(), "render" !== c.showEffectOn && this.stopEffectAnimation()
            };
            this.on("mouseover", f, this).on("mouseout", p, this).on("emphasis", f, this).on("normal", p, this)
        }
        this._effectCfg = c
    }, pO.fadeOut = function (t) {
        this.off("mouseover").off("mouseout").off("emphasis").off("normal"), t && t()
    }, h(ff, iI), Wu({
        type: "effectScatter", init: function () {
            this._symbolDraw = new Od(ff)
        }, render: function (t) {
            var e = t.getData(), i = this._symbolDraw;
            i.updateData(e), this.group.add(i.group)
        }, updateTransform: function (t) {
            var e = t.getData();
            this.group.dirty();
            var i = jP().reset(t);
            i.progress && i.progress({start: 0, end: e.count()}, e), this._symbolDraw.updateLayout(e)
        }, _updateGroupTransform: function (t) {
            var e = t.coordinateSystem;
            e && e.getRoamTransform && (this.group.transform = Fe(e.getRoamTransform()), this.group.decomposeTransform())
        }, remove: function (t, e) {
            this._symbolDraw && this._symbolDraw.remove(e)
        }, dispose: function () {
        }
    }), Ru(YP("effectScatter", "circle")), Nu(jP("effectScatter"));
    var gO = {
        _baseAxisDim: null, getInitialData: function (t, e) {
            var i, n, o = e.getComponent("xAxis", this.get("xAxisIndex")),
                a = e.getComponent("yAxis", this.get("yAxisIndex")), r = o.get("type"), s = a.get("type");
            "category" === r ? (t.layout = "horizontal", i = o.getOrdinalMeta(), n = !0) : "category" === s ? (t.layout = "vertical", i = a.getOrdinalMeta(), n = !0) : t.layout = t.layout || "horizontal";
            var l = ["x", "y"], u = "horizontal" === t.layout ? 0 : 1, h = this._baseAxisDim = l[u], c = l[1 - u],
                d = [o, a], p = d[u].get("type"), g = d[1 - u].get("type"), m = t.data;
            if (m && n) {
                var v = [];
                f(m, function (t, e) {
                    var i;
                    t.value && _(t.value) ? (i = t.value.slice(), t.value.unshift(e)) : _(t) ? (i = t.slice(), t.unshift(e)) : i = t, v.push(i)
                }), t.data = v
            }
            var y = this.defaultValueDimensions, w = [{
                name: h,
                type: $u(p),
                ordinalMeta: i,
                otherDims: {tooltip: !1, itemName: 0},
                dimsDef: ["base"]
            }, {name: c, type: $u(g), dimsDef: y.slice()}];
            return JP(this, {coordDimensions: w, dimensionsCount: y.length + 1, encodeDefaulter: x(ys, w, this)})
        }, getBaseAxis: function () {
            var t = this._baseAxisDim;
            return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis
        }
    }, mO = dC.extend({
        type: "series.candlestick",
        dependencies: ["xAxis", "yAxis", "grid"],
        defaultValueDimensions: [{name: "open", defaultTooltip: !0}, {
            name: "close",
            defaultTooltip: !0
        }, {name: "lowest", defaultTooltip: !0}, {name: "highest", defaultTooltip: !0}],
        dimensions: null,
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            hoverAnimation: !0,
            layout: null,
            clip: !0,
            itemStyle: {
                color: "#c23531",
                color0: "#314656",
                borderWidth: 1,
                borderColor: "#c23531",
                borderColor0: "#314656"
            },
            emphasis: {itemStyle: {borderWidth: 2}},
            barMaxWidth: null,
            barMinWidth: null,
            barWidth: null,
            large: !0,
            largeThreshold: 600,
            progressive: 3e3,
            progressiveThreshold: 1e4,
            progressiveChunkMode: "mod",
            animationUpdate: !1,
            animationEasing: "linear",
            animationDuration: 300
        },
        getShadowDim: function () {
            return "open"
        },
        brushSelector: function (t, e, i) {
            var n = e.getItemLayout(t);
            return n && i.rect(n.brushRect)
        }
    });
    c(mO, gO, !0);
    var vO = ["itemStyle"], yO = ["emphasis", "itemStyle"], xO = ["color", "color0", "borderColor", "borderColor0"],
        _O = (yl.extend({
            type: "candlestick", render: function (t) {
                this.group.removeClipPath(), this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t)
            }, incrementalPrepareRender: function (t) {
                this._clear(), this._updateDrawMode(t)
            }, incrementalRender: function (t, e) {
                this._isLargeDraw ? this._incrementalRenderLarge(t, e) : this._incrementalRenderNormal(t, e)
            }, _updateDrawMode: function (t) {
                var e = t.pipelineContext.large;
                (null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear())
            }, _renderNormal: function (t) {
                var e = t.getData(), i = this._data, n = this.group, o = e.getLayout("isSimpleBox"),
                    a = t.get("clip", !0), r = t.coordinateSystem, s = r.getArea && r.getArea();
                this._data || n.removeAll(), e.diff(i).add(function (i) {
                    if (e.hasValue(i)) {
                        var r, l = e.getItemLayout(i);
                        if (a && gf(s, l)) return;
                        r = pf(l, i, !0), ar(r, {shape: {points: l.ends}}, t, i), mf(r, e, i, o), n.add(r), e.setItemGraphicEl(i, r)
                    }
                }).update(function (r, l) {
                    var u = i.getItemGraphicEl(l);
                    if (!e.hasValue(r)) return void n.remove(u);
                    var h = e.getItemLayout(r);
                    return a && gf(s, h) ? void n.remove(u) : (u ? or(u, {shape: {points: h.ends}}, t, r) : u = pf(h, r), mf(u, e, r, o), n.add(u), void e.setItemGraphicEl(r, u))
                }).remove(function (t) {
                    var e = i.getItemGraphicEl(t);
                    e && n.remove(e)
                }).execute(), this._data = e
            }, _renderLarge: function (t) {
                this._clear(), yf(t, this.group);
                var e = t.get("clip", !0) ? Uc(t.coordinateSystem, !1, t) : null;
                e ? this.group.setClipPath(e) : this.group.removeClipPath()
            }, _incrementalRenderNormal: function (t, e) {
                for (var i, n = e.getData(), o = n.getLayout("isSimpleBox"); null != (i = t.next());) {
                    var a, r = n.getItemLayout(i);
                    a = pf(r, i), mf(a, n, i, o), a.incremental = !0, this.group.add(a)
                }
            }, _incrementalRenderLarge: function (t, e) {
                yf(e, this.group, !0)
            }, remove: function () {
                this._clear()
            }, _clear: function () {
                this.group.removeAll(), this._data = null
            }, dispose: G
        }), aa.extend({
            type: "normalCandlestickBox", shape: {}, buildPath: function (t, e) {
                var i = e.points;
                this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1]))
            }
        })), wO = aa.extend({
            type: "largeCandlestickBox", shape: {}, buildPath: function (t, e) {
                for (var i = e.points, n = 0; n < i.length;) if (this.__sign === i[n++]) {
                    var o = i[n++];
                    t.moveTo(o, i[n++]), t.lineTo(o, i[n++])
                } else n += 3
            }
        }), bO = function (t) {
            t && _(t.series) && f(t.series, function (t) {
                S(t) && "k" === t.type && (t.type = "candlestick")
            })
        }, SO = ["itemStyle", "borderColor"], MO = ["itemStyle", "borderColor0"], IO = ["itemStyle", "color"],
        TO = ["itemStyle", "color0"], AO = {
            seriesType: "candlestick", plan: gC(), performRawSeries: !0, reset: function (t, e) {
                function i(t, e) {
                    for (var i; null != (i = t.next());) {
                        var a = e.getItemModel(i), r = e.getItemLayout(i).sign;
                        e.setItemVisual(i, {color: n(r, a), borderColor: o(r, a)})
                    }
                }

                function n(t, e) {
                    return e.get(t > 0 ? IO : TO)
                }

                function o(t, e) {
                    return e.get(t > 0 ? SO : MO)
                }

                var a = t.getData();
                if (a.setVisual({
                    legendSymbol: "roundRect",
                    colorP: n(1, t),
                    colorN: n(-1, t),
                    borderColorP: o(1, t),
                    borderColorN: o(-1, t)
                }), !e.isSeriesFiltered(t)) {
                    var r = t.pipelineContext.large;
                    return !r && {progress: i}
                }
            }
        }, DO = "undefined" != typeof Float32Array ? Float32Array : Array, CO = {
            seriesType: "candlestick", plan: gC(), reset: function (t) {
                function e(t, e) {
                    function i(t, e) {
                        var i = [];
                        return i[r] = e, i[s] = t, isNaN(e) || isNaN(t) ? [0 / 0, 0 / 0] : n.dataToPoint(i)
                    }

                    function o(t, e, i) {
                        var n = e.slice(), o = e.slice();
                        n[r] = $A(n[r] + a / 2, 1, !1), o[r] = $A(o[r] - a / 2, 1, !0), i ? t.push(n, o) : t.push(o, n)
                    }

                    function l(t, e, n) {
                        var o = i(t, n), l = i(e, n);
                        return o[r] -= a / 2, l[r] -= a / 2, {
                            x: o[0],
                            y: o[1],
                            width: s ? a : l[0] - o[0],
                            height: s ? l[1] - o[1] : a
                        }
                    }

                    function h(t) {
                        return t[r] = $A(t[r], 1), t
                    }

                    for (var g; null != (g = t.next());) {
                        var m = e.get(u, g), v = e.get(c, g), y = e.get(d, g), x = e.get(f, g), _ = e.get(p, g),
                            w = Math.min(v, y), b = Math.max(v, y), S = i(w, m), M = i(b, m), I = i(x, m), T = i(_, m),
                            A = [];
                        o(A, M, 0), o(A, S, 1), A.push(h(T), h(M), h(I), h(S)), e.setItemLayout(g, {
                            sign: _f(e, g, v, y, d),
                            initBaseline: v > y ? M[s] : S[s],
                            ends: A,
                            brushRect: l(x, _, m)
                        })
                    }
                }

                function i(t, e) {
                    for (var i, o, a = new DO(4 * t.count), l = 0, h = [], g = []; null != (o = t.next());) {
                        var m = e.get(u, o), v = e.get(c, o), y = e.get(d, o), x = e.get(f, o), _ = e.get(p, o);
                        isNaN(m) || isNaN(x) || isNaN(_) ? (a[l++] = 0 / 0, l += 3) : (a[l++] = _f(e, o, v, y, d), h[r] = m, h[s] = x, i = n.dataToPoint(h, null, g), a[l++] = i ? i[0] : 0 / 0, a[l++] = i ? i[1] : 0 / 0, h[s] = _, i = n.dataToPoint(h, null, g), a[l++] = i ? i[1] : 0 / 0)
                    }
                    e.setLayout("largePoints", a)
                }

                var n = t.coordinateSystem, o = t.getData(), a = wf(t, o), r = 0, s = 1, l = ["x", "y"],
                    u = o.mapDimension(l[r]), h = o.mapDimension(l[s], !0), c = h[0], d = h[1], f = h[2], p = h[3];
                return o.setLayout({
                    candleWidth: a,
                    isSimpleBox: 1.3 >= a
                }), null == u || h.length < 4 ? void 0 : {progress: t.pipelineContext.large ? i : e}
            }
        };
    Cu(bO), Ru(AO), Nu(CO), h(bf, Zk), Sf.prototype.getIndicatorAxes = function () {
        return this._indicatorAxes
    }, Sf.prototype.dataToPoint = function (t, e) {
        var i = this._indicatorAxes[e];
        return this.coordToPoint(i.dataToCoord(t), e)
    }, Sf.prototype.coordToPoint = function (t, e) {
        var i = this._indicatorAxes[e], n = i.angle, o = this.cx + t * Math.cos(n), a = this.cy - t * Math.sin(n);
        return [o, a]
    }, Sf.prototype.pointToData = function (t) {
        var e = t[0] - this.cx, i = t[1] - this.cy, n = Math.sqrt(e * e + i * i);
        e /= n, i /= n;
        for (var o, a = Math.atan2(-i, e), r = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) {
            var u = this._indicatorAxes[l], h = Math.abs(a - u.angle);
            r > h && (o = u, s = l, r = h)
        }
        return [s, +(o && o.coordToData(n))]
    }, Sf.prototype.resize = function (t, e) {
        var i = t.get("center"), n = e.getWidth(), o = e.getHeight(), a = Math.min(n, o) / 2;
        this.cx = Ir(i[0], n), this.cy = Ir(i[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180;
        var r = t.get("radius");
        ("string" == typeof r || "number" == typeof r) && (r = [0, r]), this.r0 = Ir(r[0], a), this.r = Ir(r[1], a), f(this._indicatorAxes, function (t, e) {
            t.setExtent(this.r0, this.r);
            var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length;
            i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i
        }, this)
    }, Sf.prototype.update = function (t) {
        function e(t) {
            var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)), i = t / e;
            return 2 === i ? i = 5 : i *= 2, i * e
        }

        var i = this._indicatorAxes, n = this._model;
        f(i, function (t) {
            t.scale.setExtent(1 / 0, -1 / 0)
        }), t.eachSeriesByType("radar", function (e) {
            if ("radar" === e.get("coordinateSystem") && t.getComponent("radar", e.get("radarIndex")) === n) {
                var o = e.getData();
                f(i, function (t) {
                    t.scale.unionExtentFromData(o, o.mapDimension(t.dim))
                })
            }
        }, this);
        var o = n.get("splitNumber");
        f(i, function (t) {
            var i = Yh(t.scale, t.model).extent;
            qh(t.scale, t.model);
            var n = t.model, a = t.scale, r = n.getMin(), s = n.getMax(), l = a.getInterval();
            if (null != r && null != s) a.setExtent(+r, +s), a.setInterval((s - r) / o); else if (null != r) {
                var u;
                do u = r + l * o, a.setExtent(+r, u), a.setInterval(l), l = e(l); while (u < i[1] && isFinite(u) && isFinite(i[1]))
            } else if (null != s) {
                var h;
                do h = s - l * o, a.setExtent(h, +s), a.setInterval(l), l = e(l); while (h > i[0] && isFinite(h) && isFinite(i[0]))
            } else {
                var c = a.getTicks().length - 1;
                c > o && (l = e(l));
                var u = Math.ceil(i[1] / l) * l, h = Tr(u - l * o);
                a.setExtent(h, u), a.setInterval(l)
            }
        })
    }, Sf.dimensions = [], Sf.create = function (t, e) {
        var i = [];
        return t.eachComponent("radar", function (n) {
            var o = new Sf(n, t, e);
            i.push(o), n.coordinateSystem = o
        }), t.eachSeriesByType("radar", function (t) {
            "radar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("radarIndex") || 0])
        }), i
    }, Ps.register("radar", Sf);
    var LO = $k.valueAxis, kO = (Vu({
        type: "radar",
        optionUpdated: function () {
            var t = this.get("boundaryGap"), e = this.get("splitNumber"), i = this.get("scale"),
                a = this.get("axisLine"), l = this.get("axisTick"), u = this.get("axisType"), h = this.get("axisLabel"),
                c = this.get("name"), d = this.get("name.show"), f = this.get("name.formatter"),
                g = this.get("nameGap"), m = this.get("triggerEvent"), v = p(this.get("indicator") || [], function (p) {
                    null != p.max && p.max > 0 && !p.min ? p.min = 0 : null != p.min && p.min < 0 && !p.max && (p.max = 0);
                    var v = c;
                    if (null != p.color && (v = s({color: p.color}, c)), p = o(n(p), {
                        boundaryGap: t,
                        splitNumber: e,
                        scale: i,
                        axisLine: a,
                        axisTick: l,
                        axisType: u,
                        axisLabel: h,
                        name: p.text,
                        nameLocation: "end",
                        nameGap: g,
                        nameTextStyle: v,
                        triggerEvent: m
                    }, !1), d || (p.name = ""), "string" == typeof f) {
                        var y = p.name;
                        p.name = f.replace("{value}", null != y ? y : "")
                    } else "function" == typeof f && (p.name = f(p.name, p));
                    var x = r(new vr(p, null, this.ecModel), Ck);
                    return x.mainType = "radar", x.componentIndex = this.componentIndex, x
                }, this);
            this.getIndicatorModels = function () {
                return v
            }
        },
        defaultOption: {
            zlevel: 0,
            z: 0,
            center: ["50%", "50%"],
            radius: "75%",
            startAngle: 90,
            name: {show: !0},
            boundaryGap: [0, 0],
            splitNumber: 5,
            nameGap: 15,
            scale: !1,
            shape: "polygon",
            axisLine: o({lineStyle: {color: "#bbb"}}, LO.axisLine),
            axisLabel: Mf(LO.axisLabel, !1),
            axisTick: Mf(LO.axisTick, !1),
            axisType: "interval",
            splitLine: Mf(LO.splitLine, !0),
            splitArea: Mf(LO.splitArea, !0),
            indicator: []
        }
    }), ["axisLine", "axisTickLabel", "axisName"]);
    Gu({
        type: "radar", render: function (t) {
            var e = this.group;
            e.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t)
        }, _buildAxes: function (t) {
            var e = t.coordinateSystem, i = e.getIndicatorAxes(), n = p(i, function (t) {
                var i = new yP(t.model, {
                    position: [e.cx, e.cy],
                    rotation: t.angle,
                    labelDirection: -1,
                    tickDirection: -1,
                    nameDirection: 1
                });
                return i
            });
            f(n, function (t) {
                f(kO, t.add, t), this.group.add(t.getGroup())
            }, this)
        }, _buildSplitLineAndArea: function (t) {
            function e(t, e, i) {
                var n = i % e.length;
                return t[n] = t[n] || [], n
            }

            var i = t.coordinateSystem, n = i.getIndicatorAxes();
            if (n.length) {
                var o = t.get("shape"), a = t.getModel("splitLine"), r = t.getModel("splitArea"),
                    l = a.getModel("lineStyle"), u = r.getModel("areaStyle"), h = a.get("show"), c = r.get("show"),
                    d = l.get("color"), g = u.get("color");
                d = _(d) ? d : [d], g = _(g) ? g : [g];
                var m = [], v = [];
                if ("circle" === o) for (var y = n[0].getTicksCoords(), x = i.cx, w = i.cy, b = 0; b < y.length; b++) {
                    if (h) {
                        var S = e(m, d, b);
                        m[S].push(new yA({shape: {cx: x, cy: w, r: y[b].coord}}))
                    }
                    if (c && b < y.length - 1) {
                        var S = e(v, g, b);
                        v[S].push(new bA({shape: {cx: x, cy: w, r0: y[b].coord, r: y[b + 1].coord}}))
                    }
                } else for (var M, I = p(n, function (t, e) {
                    var n = t.getTicksCoords();
                    return M = null == M ? n.length - 1 : Math.min(n.length - 1, M), p(n, function (t) {
                        return i.coordToPoint(t.coord, e)
                    })
                }), T = [], b = 0; M >= b; b++) {
                    for (var A = [], D = 0; D < n.length; D++) A.push(I[D][b]);
                    if (A[0] ? A.push(A[0].slice()) : BS && console.error("Can't draw value axis " + b), h) {
                        var S = e(m, d, b);
                        m[S].push(new TA({shape: {points: A}}))
                    }
                    if (c && T) {
                        var S = e(v, g, b - 1);
                        v[S].push(new IA({shape: {points: A.concat(T)}}))
                    }
                    T = A.slice().reverse()
                }
                var C = l.getLineStyle(), L = u.getAreaStyle();
                f(v, function (t, e) {
                    this.group.add(KA(t, {style: s({stroke: "none", fill: g[e % g.length]}, L), silent: !0}))
                }, this), f(m, function (t, e) {
                    this.group.add(KA(t, {style: s({fill: "none", stroke: d[e % d.length]}, C), silent: !0}))
                }, this)
            }
        }
    });
    var PO = dC.extend({
        type: "series.radar",
        dependencies: ["radar"],
        init: function () {
            PO.superApply(this, "init", arguments), this.legendVisualProvider = new ef(y(this.getData, this), y(this.getRawData, this))
        },
        getInitialData: function () {
            return JP(this, {generateCoord: "indicator_", generateCoordCount: 1 / 0})
        },
        formatTooltip: function (t, e, i, n) {
            var o = this.getData(), a = this.coordinateSystem, r = a.getIndicatorAxes(), s = this.getData().getName(t),
                l = "html" === n ? "<br/>" : "\n";
            return Hr("" === s ? this.name : s) + l + p(r, function (e) {
                var i = o.get(o.mapDimension(e.dim), t);
                return Hr(e.name + " : " + i)
            }).join(l)
        },
        getTooltipPosition: function (t) {
            if (null != t) for (var e = this.getData(), i = this.coordinateSystem, n = e.getValues(p(i.dimensions, function (t) {
                return e.mapDimension(t)
            }), t, !0), o = 0, a = n.length; a > o; o++) if (!isNaN(n[o])) {
                var r = i.getIndicatorAxes();
                return i.coordToPoint(r[o].dataToCoord(n[o]), o)
            }
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "radar",
            legendHoverLink: !0,
            radarIndex: 0,
            lineStyle: {width: 2, type: "solid"},
            label: {position: "top"},
            symbol: "emptyCircle",
            symbolSize: 4
        }
    });
    Wu({
        type: "radar", render: function (t) {
            function e(t, e) {
                var i = t.getItemVisual(e, "symbol") || "circle", n = t.getItemVisual(e, "color");
                if ("none" !== i) {
                    var o = If(t.getItemVisual(e, "symbolSize")), a = ac(i, -1, -1, 2, 2, n),
                        r = t.getItemVisual(e, "symbolRotate") || 0;
                    return a.attr({
                        style: {strokeNoScale: !0},
                        z2: 100,
                        scale: [o[0] / 2, o[1] / 2],
                        rotation: r * Math.PI / 180 || 0
                    }), a
                }
            }

            function i(i, n, o, a, r, s) {
                o.removeAll();
                for (var l = 0; l < n.length - 1; l++) {
                    var u = e(a, r);
                    u && (u.__dimIdx = l, i[l] ? (u.attr("position", i[l]), tD[s ? "initProps" : "updateProps"](u, {position: n[l]}, t, r)) : u.attr("position", n[l]), o.add(u))
                }
            }

            function o(t) {
                return p(t, function () {
                    return [a.cx, a.cy]
                })
            }

            var a = t.coordinateSystem, r = this.group, l = t.getData(), u = this._data;
            l.diff(u).add(function (e) {
                var n = l.getItemLayout(e);
                if (n) {
                    var a = new IA, r = new TA, s = {shape: {points: n}};
                    a.shape.points = o(n), r.shape.points = o(n), ar(a, s, t, e), ar(r, s, t, e);
                    var u = new iI, h = new iI;
                    u.add(r), u.add(a), u.add(h), i(r.shape.points, n, h, l, e, !0), l.setItemGraphicEl(e, u)
                }
            }).update(function (e, n) {
                var o = u.getItemGraphicEl(n), a = o.childAt(0), r = o.childAt(1), s = o.childAt(2),
                    h = {shape: {points: l.getItemLayout(e)}};
                h.shape.points && (i(a.shape.points, h.shape.points, s, l, e, !1), or(a, h, t), or(r, h, t), l.setItemGraphicEl(e, o))
            }).remove(function (t) {
                r.remove(u.getItemGraphicEl(t))
            }).execute(), l.eachItemGraphicEl(function (t, e) {
                var i = l.getItemModel(e), o = t.childAt(0), a = t.childAt(1), u = t.childAt(2),
                    h = l.getItemVisual(e, "color");
                r.add(t), o.useStyle(s(i.getModel("lineStyle").getLineStyle(), {
                    fill: "none",
                    stroke: h
                })), o.hoverStyle = i.getModel("emphasis.lineStyle").getLineStyle();
                var c = i.getModel("areaStyle"), d = i.getModel("emphasis.areaStyle"),
                    f = c.isEmpty() && c.parentModel.isEmpty(), p = d.isEmpty() && d.parentModel.isEmpty();
                p = p && f, a.ignore = f, a.useStyle(s(c.getAreaStyle(), {
                    fill: h,
                    opacity: .7
                })), a.hoverStyle = d.getAreaStyle();
                var g = i.getModel("itemStyle").getItemStyle(["color"]),
                    m = i.getModel("emphasis.itemStyle").getItemStyle(), v = i.getModel("label"),
                    y = i.getModel("emphasis.label");
                u.eachChild(function (t) {
                    t.setStyle(g), t.hoverStyle = n(m);
                    var i = l.get(l.dimensions[t.__dimIdx], e);
                    (null == i || isNaN(i)) && (i = ""), Xa(t.style, t.hoverStyle, v, y, {
                        labelFetcher: l.hostModel,
                        labelDataIndex: e,
                        labelDimIndex: t.__dimIdx,
                        defaultText: i,
                        autoColor: h,
                        isRectText: !0
                    })
                }), t.highDownOnUpdate = function (t, e) {
                    a.attr("ignore", "emphasis" === e ? p : f)
                }, Wa(t)
            }), this._data = l
        }, remove: function () {
            this.group.removeAll(), this._data = null
        }, dispose: function () {
        }
    });
    var OO = function (t) {
        t.eachSeriesByType("radar", function (t) {
            var e = t.getData(), i = [], n = t.coordinateSystem;
            if (n) {
                var o = n.getIndicatorAxes();
                f(o, function (t, a) {
                    e.each(e.mapDimension(o[a].dim), function (t, e) {
                        i[e] = i[e] || [];
                        var o = n.dataToPoint(t, a);
                        i[e][a] = Tf(o) ? o : Af(n)
                    })
                }), e.each(function (t) {
                    var o = v(i[t], function (t) {
                        return Tf(t)
                    }) || Af(n);
                    i[t].push(o.slice()), e.setItemLayout(t, i[t])
                })
            }
        })
    }, EO = function (t) {
        var e = t.polar;
        if (e) {
            _(e) || (e = [e]);
            var i = [];
            f(e, function (e) {
                e.indicator ? (e.type && !e.shape && (e.shape = e.type), t.radar = t.radar || [], _(t.radar) || (t.radar = [t.radar]), t.radar.push(e)) : i.push(e)
            }), t.polar = i
        }
        f(t.series, function (t) {
            t && "radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex)
        })
    };
    Ru(nO("radar")), Ru(YP("radar", "circle")), Nu(OO), Lu(uO("radar")), Cu(EO), dC.extend({
        type: "series.heatmap",
        getInitialData: function () {
            return Sh(this.getSource(), this, {generateCoord: "value"})
        },
        preventIncremental: function () {
            var t = Ps.get(this.get("coordinateSystem"));
            return t && t.dimensions ? "lng" === t.dimensions[0] && "lat" === t.dimensions[1] : void 0
        },
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            geoIndex: 0,
            blurSize: 30,
            pointSize: 20,
            maxOpacity: 1,
            minOpacity: 0
        }
    });
    var NO = 256;
    Df.prototype = {
        update: function (t, e, i, n, o, a) {
            var r = this._getBrush(), s = this._getGradient(t, o, "inRange"), l = this._getGradient(t, o, "outOfRange"),
                u = this.pointSize + this.blurSize, h = this.canvas, c = h.getContext("2d"), d = t.length;
            h.width = e, h.height = i;
            for (var f = 0; d > f; ++f) {
                var p = t[f], g = p[0], m = p[1], v = p[2], y = n(v);
                c.globalAlpha = y, c.drawImage(r, g - u, m - u)
            }
            if (!h.width || !h.height) return h;
            for (var x = c.getImageData(0, 0, h.width, h.height), _ = x.data, w = 0, b = _.length, S = this.minOpacity, M = this.maxOpacity, I = M - S; b > w;) {
                var y = _[w + 3] / 256, T = 4 * Math.floor(y * (NO - 1));
                if (y > 0) {
                    var A = a(y) ? s : l;
                    y > 0 && (y = y * I + S), _[w++] = A[T], _[w++] = A[T + 1], _[w++] = A[T + 2], _[w++] = A[T + 3] * y * 256
                } else w += 4
            }
            return c.putImageData(x, 0, 0), h
        }, _getBrush: function () {
            var t = this._brushCanvas || (this._brushCanvas = QS()), e = this.pointSize + this.blurSize, i = 2 * e;
            t.width = i, t.height = i;
            var n = t.getContext("2d");
            return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = "#000", n.beginPath(), n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), t
        }, _getGradient: function (t, e, i) {
            for (var n = this._gradientPixels, o = n[i] || (n[i] = new Uint8ClampedArray(1024)), a = [0, 0, 0, 0], r = 0, s = 0; 256 > s; s++) e[i](s / 255, !0, a), o[r++] = a[0], o[r++] = a[1], o[r++] = a[2], o[r++] = a[3];
            return o
        }
    }, Wu({
        type: "heatmap", render: function (t, e, i) {
            var n;
            if (e.eachComponent("visualMap", function (e) {
                e.eachTargetSeries(function (i) {
                    i === t && (n = e)
                })
            }), BS && !n) throw new Error("Heatmap must use with visualMap");
            this.group.removeAll(), this._incrementalDisplayable = null;
            var o = t.coordinateSystem;
            "cartesian2d" === o.type || "calendar" === o.type ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : kf(o) && this._renderOnGeo(o, t, n, i)
        }, incrementalPrepareRender: function () {
            this.group.removeAll()
        }, incrementalRender: function (t, e, i, n) {
            var o = e.coordinateSystem;
            o && this._renderOnCartesianAndCalendar(e, n, t.start, t.end, !0)
        }, _renderOnCartesianAndCalendar: function (t, e, i, n, o) {
            var a, s, l = t.coordinateSystem;
            if ("cartesian2d" === l.type) {
                var u = l.getAxis("x"), h = l.getAxis("y");
                if (BS) {
                    if ("category" !== u.type || "category" !== h.type) throw new Error("Heatmap on cartesian must have two category axes");
                    if (!u.onBand || !h.onBand) throw new Error("Heatmap on cartesian must have two axes with boundaryGap true")
                }
                a = u.getBandWidth(), s = h.getBandWidth()
            }
            for (var c = this.group, d = t.getData(), f = "itemStyle", p = "emphasis.itemStyle", g = "label", m = "emphasis.label", v = t.getModel(f).getItemStyle(["color"]), y = t.getModel(p).getItemStyle(), x = t.getModel(g), _ = t.getModel(m), w = l.type, b = "cartesian2d" === w ? [d.mapDimension("x"), d.mapDimension("y"), d.mapDimension("value")] : [d.mapDimension("time"), d.mapDimension("value")], S = i; n > S; S++) {
                var M;
                if ("cartesian2d" === w) {
                    if (isNaN(d.get(b[2], S))) continue;
                    var I = l.dataToPoint([d.get(b[0], S), d.get(b[1], S)]);
                    M = new CA({
                        shape: {
                            x: Math.floor(Math.round(I[0]) - a / 2),
                            y: Math.floor(Math.round(I[1]) - s / 2),
                            width: Math.ceil(a),
                            height: Math.ceil(s)
                        }, style: {fill: d.getItemVisual(S, "color"), opacity: d.getItemVisual(S, "opacity")}
                    })
                } else {
                    if (isNaN(d.get(b[1], S))) continue;
                    M = new CA({
                        z2: 1,
                        shape: l.dataToRect([d.get(b[0], S)]).contentShape,
                        style: {fill: d.getItemVisual(S, "color"), opacity: d.getItemVisual(S, "opacity")}
                    })
                }
                var T = d.getItemModel(S);
                d.hasItemOption && (v = T.getModel(f).getItemStyle(["color"]), y = T.getModel(p).getItemStyle(), x = T.getModel(g), _ = T.getModel(m));
                var A = t.getRawValue(S), D = "-";
                A && null != A[2] && (D = A[2]), Xa(v, y, x, _, {
                    labelFetcher: t,
                    labelDataIndex: S,
                    defaultText: D,
                    isRectText: !0
                }), M.setStyle(v), Wa(M, d.hasItemOption ? y : r({}, y)), M.incremental = o, o && (M.useHoverLayer = !0), c.add(M), d.setItemGraphicEl(S, M)
            }
        }, _renderOnGeo: function (t, e, i, n) {
            var o = i.targetVisuals.inRange, a = i.targetVisuals.outOfRange, r = e.getData(),
                s = this._hmLayer || this._hmLayer || new Df;
            s.blurSize = e.get("blurSize"), s.pointSize = e.get("pointSize"), s.minOpacity = e.get("minOpacity"), s.maxOpacity = e.get("maxOpacity");
            var l = t.getViewRect().clone(), u = t.getRoamTransform();
            l.applyTransform(u);
            var h = Math.max(l.x, 0), c = Math.max(l.y, 0), d = Math.min(l.width + l.x, n.getWidth()),
                f = Math.min(l.height + l.y, n.getHeight()), p = d - h, g = f - c,
                m = [r.mapDimension("lng"), r.mapDimension("lat"), r.mapDimension("value")],
                v = r.mapArray(m, function (e, i, n) {
                    var o = t.dataToPoint([e, i]);
                    return o[0] -= h, o[1] -= c, o.push(n), o
                }), y = i.getExtent(),
                x = "visualMap.continuous" === i.type ? Lf(y, i.option.range) : Cf(y, i.getPieceList(), i.option.selected);
            s.update(v, p, g, o.color.getNormalizer(), {
                inRange: o.color.getColorMapper(),
                outOfRange: a.color.getColorMapper()
            }, x);
            var _ = new Cn({style: {width: p, height: g, x: h, y: c, image: s.canvas}, silent: !0});
            this.group.add(_)
        }, dispose: function () {
        }
    });
    var RO = f, zO = "\x00__link_datas", BO = "\x00__link_mainData", VO = function (t, e) {
        this.name = t || "", this.depth = 0, this.height = 0, this.parentNode = null, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.hostTree = e
    };
    VO.prototype = {
        constructor: VO, isRemoved: function () {
            return this.dataIndex < 0
        }, eachNode: function (t, e, i) {
            "function" == typeof t && (i = e, e = t, t = null), t = t || {}, b(t) && (t = {order: t});
            var n, o = t.order || "preorder", a = this[t.attr || "children"];
            "preorder" === o && (n = e.call(i, this));
            for (var r = 0; !n && r < a.length; r++) a[r].eachNode(t, e, i);
            "postorder" === o && e.call(i, this)
        }, updateDepthAndHeight: function (t) {
            var e = 0;
            this.depth = t;
            for (var i = 0; i < this.children.length; i++) {
                var n = this.children[i];
                n.updateDepthAndHeight(t + 1), n.height > e && (e = n.height)
            }
            this.height = e + 1
        }, getNodeById: function (t) {
            if (this.getId() === t) return this;
            for (var e = 0, i = this.children, n = i.length; n > e; e++) {
                var o = i[e].getNodeById(t);
                if (o) return o
            }
        }, contains: function (t) {
            if (t === this) return !0;
            for (var e = 0, i = this.children, n = i.length; n > e; e++) {
                var o = i[e].contains(t);
                if (o) return o
            }
        }, getAncestors: function (t) {
            for (var e = [], i = t ? this : this.parentNode; i;) e.push(i), i = i.parentNode;
            return e.reverse(), e
        }, getValue: function (t) {
            var e = this.hostTree.data;
            return e.get(e.getDimension(t || "value"), this.dataIndex)
        }, setLayout: function (t, e) {
            this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e)
        }, getLayout: function () {
            return this.hostTree.data.getItemLayout(this.dataIndex)
        }, getModel: function (t) {
            if (!(this.dataIndex < 0)) {
                var e = this.hostTree, i = e.data.getItemModel(this.dataIndex);
                return i.getModel(t)
            }
        }, setVisual: function (t, e) {
            this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e)
        }, getVisual: function (t, e) {
            return this.hostTree.data.getItemVisual(this.dataIndex, t, e)
        }, getRawIndex: function () {
            return this.hostTree.data.getRawIndex(this.dataIndex)
        }, getId: function () {
            return this.hostTree.data.getId(this.dataIndex)
        }, isAncestorOf: function (t) {
            for (var e = t.parentNode; e;) {
                if (e === this) return !0;
                e = e.parentNode
            }
            return !1
        }, isDescendantOf: function (t) {
            return t !== this && t.isAncestorOf(this)
        }
    }, Gf.prototype = {
        constructor: Gf, type: "tree", eachNode: function (t, e, i) {
            this.root.eachNode(t, e, i)
        }, getNodeByDataIndex: function (t) {
            var e = this.data.getRawIndex(t);
            return this._nodes[e]
        }, getNodeByName: function (t) {
            return this.root.getNodeByName(t)
        }, update: function () {
            for (var t = this.data, e = this._nodes, i = 0, n = e.length; n > i; i++) e[i].dataIndex = -1;
            for (var i = 0, n = t.count(); n > i; i++) e[t.getRawIndex(i)].dataIndex = i
        }, clearLayouts: function () {
            this.data.clearItemLayouts()
        }
    }, Gf.createTree = function (t, e, i) {
        function n(t, e) {
            var i = t.value;
            r = Math.max(r, _(i) ? i.length : 1), a.push(t);
            var s = new VO(t.name, o);
            e ? Ff(s, e) : o.root = s, o._nodes.push(s);
            var l = t.children;
            if (l) for (var u = 0; u < l.length; u++) n(l[u], s)
        }

        var o = new Gf(e), a = [], r = 1;
        n(t), o.root.updateDepthAndHeight(0);
        var s = JL(a, {coordDimensions: ["value"], dimensionsCount: r}), l = new qL(s, e);
        return l.initData(a), i && i(l), Pf({mainData: l, struct: o, structAttr: "tree"}), o.update(), o
    }, dC.extend({
        type: "series.tree",
        layoutInfo: null,
        layoutMode: "box",
        getInitialData: function (t) {
            function e(t) {
                t.wrapMethod("getItemModel", function (t, e) {
                    var i = a.getNodeByDataIndex(e);
                    return i.children.length && i.isExpand || (t.parentModel = o), t
                })
            }

            var i = {name: t.name, children: t.data}, n = t.leaves || {}, o = new vr(n, this, this.ecModel),
                a = Gf.createTree(i, this, e), r = 0;
            a.eachNode("preorder", function (t) {
                t.depth > r && (r = t.depth)
            });
            var s = t.expandAndCollapse, l = s && t.initialTreeDepth >= 0 ? t.initialTreeDepth : r;
            return a.root.eachNode("preorder", function (t) {
                var e = t.hostTree.data.getRawDataItem(t.dataIndex);
                t.isExpand = e && null != e.collapsed ? !e.collapsed : t.depth <= l
            }), a.data
        },
        getOrient: function () {
            var t = this.get("orient");
            return "horizontal" === t ? t = "LR" : "vertical" === t && (t = "TB"), t
        },
        setZoom: function (t) {
            this.option.zoom = t
        },
        setCenter: function (t) {
            this.option.center = t
        },
        formatTooltip: function (t) {
            for (var e = this.getData().tree, i = e.root.children[0], n = e.getNodeByDataIndex(t), o = n.getValue(), a = n.name; n && n !== i;) a = n.parentNode.name + "." + a, n = n.parentNode;
            return Hr(a + (isNaN(o) || null == o ? "" : " : " + o))
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "view",
            left: "12%",
            top: "12%",
            right: "12%",
            bottom: "12%",
            layout: "orthogonal",
            edgeShape: "curve",
            edgeForkPosition: "50%",
            roam: !1,
            nodeScaleRatio: .4,
            center: null,
            zoom: 1,
            orient: "LR",
            symbol: "emptyCircle",
            symbolSize: 7,
            expandAndCollapse: !0,
            initialTreeDepth: 2,
            lineStyle: {color: "#ccc", width: 1.5, curveness: .5},
            itemStyle: {color: "lightsteelblue", borderColor: "#c23531", borderWidth: 1.5},
            label: {show: !0, color: "#555"},
            leaves: {label: {show: !0}},
            animationEasing: "linear",
            animationDuration: 700,
            animationDurationUpdate: 1e3
        }
    });
    var GO = ae;
    c(ep, AM), ip.prototype = {
        constructor: ip, type: "view", dimensions: ["x", "y"], setBoundingRect: function (t, e, i, n) {
            return this._rect = new Ti(t, e, i, n), this._rect
        }, getBoundingRect: function () {
            return this._rect
        }, setViewRect: function (t, e, i, n) {
            this.transformTo(t, e, i, n), this._viewRect = new Ti(t, e, i, n)
        }, transformTo: function (t, e, i, n) {
            var o = this.getBoundingRect(), a = this._rawTransformable;
            a.transform = o.calculateTransform(new Ti(t, e, i, n)), a.decomposeTransform(), this._updateTransform()
        }, setCenter: function (t) {
            t && (this._center = t, this._updateCenterAndZoom())
        }, setZoom: function (t) {
            t = t || 1;
            var e = this.zoomLimit;
            e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom()
        }, getDefaultCenter: function () {
            var t = this.getBoundingRect(), e = t.x + t.width / 2, i = t.y + t.height / 2;
            return [e, i]
        }, getCenter: function () {
            return this._center || this.getDefaultCenter()
        }, getZoom: function () {
            return this._zoom || 1
        }, getRoamTransform: function () {
            return this._roamTransformable.getLocalTransform()
        }, _updateCenterAndZoom: function () {
            var t = this._rawTransformable.getLocalTransform(), e = this._roamTransformable,
                i = this.getDefaultCenter(), n = this.getCenter(), o = this.getZoom();
            n = ae([], n, t), i = ae([], i, t), e.origin = n, e.position = [i[0] - n[0], i[1] - n[1]], e.scale = [o, o], this._updateTransform()
        }, _updateTransform: function () {
            var t = this._roamTransformable, e = this._rawTransformable;
            e.parent = t, t.updateTransform(), e.updateTransform(), Ne(this.transform || (this.transform = []), e.transform || Oe()), this._rawTransform = e.getLocalTransform(), this.invTransform = this.invTransform || [], Ge(this.invTransform, this.transform), this.decomposeTransform()
        }, getTransformInfo: function () {
            var t = this._roamTransformable.transform, e = this._rawTransformable;
            return {roamTransform: t ? k(t) : Oe(), rawScale: k(e.scale), rawPosition: k(e.position)}
        }, getViewRect: function () {
            return this._viewRect
        }, getViewRectAfterRoam: function () {
            var t = this.getBoundingRect().clone();
            return t.applyTransform(this.transform), t
        }, dataToPoint: function (t, e, i) {
            var n = e ? this._rawTransform : this.transform;
            return i = i || [], n ? GO(i, t, n) : W(i, t)
        }, pointToData: function (t) {
            var e = this.invTransform;
            return e ? GO([], t, e) : [t[0], t[1]]
        }, convertToPixel: x(np, "dataToPoint"), convertFromPixel: x(np, "pointToData"), containPoint: function (t) {
            return this.getViewRectAfterRoam().contain(t[0], t[1])
        }
    }, c(ip, AM);
    var FO = "\x00_ec_interaction_mutex";
    Pu({type: "takeGlobalCursor", event: "globalCursorTaken", update: "update"}, function () {
    }), c(hp, hM);
    var WO = {axisPointer: 1, tooltip: 1, brush: 1}, HO = xa({
        shape: {parentPoint: [], childPoints: [], orient: "", forkPosition: ""},
        style: {stroke: "#000", fill: null},
        buildPath: function (t, e) {
            var i = e.childPoints, n = i.length, o = e.parentPoint, a = i[0], r = i[n - 1];
            if (1 === n) return t.moveTo(o[0], o[1]), void t.lineTo(a[0], a[1]);
            var s = e.orient, l = "TB" === s || "BT" === s ? 0 : 1, u = 1 - l, h = Ir(e.forkPosition, 1), c = [];
            c[l] = o[l], c[u] = o[u] + (r[u] - o[u]) * h, t.moveTo(o[0], o[1]), t.lineTo(c[0], c[1]), t.moveTo(a[0], a[1]), c[l] = a[l], t.lineTo(c[0], c[1]), c[l] = r[l], t.lineTo(c[0], c[1]), t.lineTo(r[0], r[1]);
            for (var d = 1; n - 1 > d; d++) {
                var f = i[d];
                t.moveTo(f[0], f[1]), c[l] = f[l], t.lineTo(c[0], c[1])
            }
        }
    });
    Wu({
        type: "tree", init: function (t, e) {
            this._oldTree, this._mainGroup = new iI, this._controller = new hp(e.getZr()), this._controllerHost = {target: this.group}, this.group.add(this._mainGroup)
        }, render: function (t, e, i) {
            var n = t.getData(), o = t.layoutInfo, a = this._mainGroup, r = t.get("layout");
            "radial" === r ? a.attr("position", [o.x + o.width / 2, o.y + o.height / 2]) : a.attr("position", [o.x, o.y]), this._updateViewCoordSys(t, o, r), this._updateController(t, e, i);
            var s = this._data, l = {
                expandAndCollapse: t.get("expandAndCollapse"),
                layout: r,
                edgeShape: t.get("edgeShape"),
                edgeForkPosition: t.get("edgeForkPosition"),
                orient: t.getOrient(),
                curvature: t.get("lineStyle.curveness"),
                symbolRotate: t.get("symbolRotate"),
                symbolOffset: t.get("symbolOffset"),
                hoverAnimation: t.get("hoverAnimation"),
                useNameLabel: !0,
                fadeIn: !0
            };
            n.diff(s).add(function (e) {
                _p(n, e) && bp(n, e, null, a, t, l)
            }).update(function (e, i) {
                var o = s.getItemGraphicEl(i);
                return _p(n, e) ? void bp(n, e, o, a, t, l) : void (o && Mp(s, i, o, a, t, l))
            }).remove(function (e) {
                var i = s.getItemGraphicEl(e);
                i && Mp(s, e, i, a, t, l)
            }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), l.expandAndCollapse === !0 && n.eachItemGraphicEl(function (e, n) {
                e.off("click").on("click", function () {
                    i.dispatchAction({type: "treeExpandAndCollapse", seriesId: t.id, dataIndex: n})
                })
            }), this._data = n
        }, _updateViewCoordSys: function (t) {
            var e = t.getData(), i = [];
            e.each(function (t) {
                var n = e.getItemLayout(t);
                !n || isNaN(n.x) || isNaN(n.y) || i.push([+n.x, +n.y])
            });
            var n = [], o = [];
            Go(i, n, o);
            var a = this._min, r = this._max;
            o[0] - n[0] === 0 && (n[0] = a ? a[0] : n[0] - 1, o[0] = r ? r[0] : o[0] + 1), o[1] - n[1] === 0 && (n[1] = a ? a[1] : n[1] - 1, o[1] = r ? r[1] : o[1] + 1);
            var s = t.coordinateSystem = new ip;
            s.zoomLimit = t.get("scaleLimit"), s.setBoundingRect(n[0], n[1], o[0] - n[0], o[1] - n[1]), s.setCenter(t.get("center")), s.setZoom(t.get("zoom")), this.group.attr({
                position: s.position,
                scale: s.scale
            }), this._viewCoordSys = s, this._min = n, this._max = o
        }, _updateController: function (t, e, i) {
            var n = this._controller, o = this._controllerHost, a = this.group;
            n.setPointerChecker(function (e, n, o) {
                var r = a.getBoundingRect();
                return r.applyTransform(a.transform), r.contain(n, o) && !xp(e, i, t)
            }), n.enable(t.get("roam")), o.zoomLimit = t.get("scaleLimit"), o.zoom = t.coordinateSystem.getZoom(), n.off("pan").off("zoom").on("pan", function (e) {
                op(o, e.dx, e.dy), i.dispatchAction({seriesId: t.id, type: "treeRoam", dx: e.dx, dy: e.dy})
            }, this).on("zoom", function (e) {
                ap(o, e.scale, e.originX, e.originY), i.dispatchAction({
                    seriesId: t.id,
                    type: "treeRoam",
                    zoom: e.scale,
                    originX: e.originX,
                    originY: e.originY
                }), this._updateNodeAndLinkScale(t)
            }, this)
        }, _updateNodeAndLinkScale: function (t) {
            var e = t.getData(), i = this._getNodeGlobalScale(t), n = [i, i];
            e.eachItemGraphicEl(function (t) {
                t.attr("scale", n)
            })
        }, _getNodeGlobalScale: function (t) {
            var e = t.coordinateSystem;
            if ("view" !== e.type) return 1;
            var i = this._nodeScaleRatio, n = e.scale, o = n && n[0] || 1, a = e.getZoom(), r = (a - 1) * i + 1;
            return r / o
        }, dispose: function () {
            this._controller && this._controller.dispose(), this._controllerHost = {}
        }, remove: function () {
            this._mainGroup.removeAll(), this._data = null
        }
    }), Pu({type: "treeExpandAndCollapse", event: "treeExpandAndCollapse", update: "update"}, function (t, e) {
        e.eachComponent({mainType: "series", subType: "tree", query: t}, function (e) {
            var i = t.dataIndex, n = e.getData().tree, o = n.getNodeByDataIndex(i);
            o.isExpand = !o.isExpand
        })
    }), Pu({type: "treeRoam", event: "treeRoam", update: "none"}, function (t, e) {
        e.eachComponent({mainType: "series", subType: "tree", query: t}, function (e) {
            var i = e.coordinateSystem, n = Tp(i, t);
            e.setCenter && e.setCenter(n.center), e.setZoom && e.setZoom(n.zoom)
        })
    });
    var ZO = function (t, e) {
        t.eachSeriesByType("tree", function (t) {
            Cp(t, e)
        })
    };
    Ru(YP("tree", "circle")), Nu(ZO), dC.extend({
        type: "series.treemap",
        layoutMode: "box",
        dependencies: ["grid", "polar"],
        preventUsingHoverLayer: !0,
        _viewRoot: null,
        defaultOption: {
            progressive: 0,
            left: "center",
            top: "middle",
            right: null,
            bottom: null,
            width: "80%",
            height: "80%",
            sort: !0,
            clipWindow: "origin",
            squareRatio: .5 * (1 + Math.sqrt(5)),
            leafDepth: null,
            drillDownIcon: "▶",
            zoomToNodeRatio: .1024,
            roam: !0,
            nodeClick: "zoomToNode",
            animation: !0,
            animationDurationUpdate: 900,
            animationEasing: "quinticInOut",
            breadcrumb: {
                show: !0,
                height: 22,
                left: "center",
                top: "bottom",
                emptyItemWidth: 25,
                itemStyle: {
                    color: "rgba(0,0,0,0.7)",
                    borderColor: "rgba(255,255,255,0.7)",
                    borderWidth: 1,
                    shadowColor: "rgba(150,150,150,1)",
                    shadowBlur: 3,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    textStyle: {color: "#fff"}
                },
                emphasis: {textStyle: {}}
            },
            label: {show: !0, distance: 0, padding: 5, position: "inside", color: "#fff", ellipsis: !0},
            upperLabel: {
                show: !1,
                position: [0, "50%"],
                height: 20,
                color: "#fff",
                ellipsis: !0,
                verticalAlign: "middle"
            },
            itemStyle: {
                color: null,
                colorAlpha: null,
                colorSaturation: null,
                borderWidth: 0,
                gapWidth: 0,
                borderColor: "#fff",
                borderColorSaturation: null
            },
            emphasis: {
                upperLabel: {
                    show: !0,
                    position: [0, "50%"],
                    color: "#fff",
                    ellipsis: !0,
                    verticalAlign: "middle"
                }
            },
            visualDimension: 0,
            visualMin: null,
            visualMax: null,
            color: [],
            colorAlpha: null,
            colorSaturation: null,
            colorMappingBy: "index",
            visibleMin: 10,
            childrenVisibleMin: null,
            levels: []
        },
        getInitialData: function (t, e) {
            function i(t) {
                t.wrapMethod("getItemModel", function (t, e) {
                    var i = l.getNodeByDataIndex(e), n = s[i.depth];
                    return t.parentModel = n || r, t
                })
            }

            var n = {name: t.name, children: t.data};
            Ep(n);
            var o = t.levels || [], a = this.designatedVisualItemStyle = {}, r = new vr({itemStyle: a}, this, e);
            o = t.levels = Np(o, e);
            var s = p(o || [], function (t) {
                return new vr(t, r, e)
            }, this), l = Gf.createTree(n, this, i);
            return l.data
        },
        optionUpdated: function () {
            this.resetViewRoot()
        },
        formatTooltip: function (t) {
            var e = this.getData(), i = this.getRawValue(t), n = Fr(_(i) ? i[0] : i), o = e.getName(t);
            return Hr(o + ": " + n)
        },
        getDataParams: function (t) {
            var e = dC.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
            return e.treePathInfo = Op(i, this), e
        },
        setLayoutInfo: function (t) {
            this.layoutInfo = this.layoutInfo || {}, r(this.layoutInfo, t)
        },
        mapIdToIndex: function (t) {
            var e = this._idIndexMap;
            e || (e = this._idIndexMap = B(), this._idIndexMapCount = 0);
            var i = e.get(t);
            return null == i && e.set(t, i = this._idIndexMapCount++), i
        },
        getViewRoot: function () {
            return this._viewRoot
        },
        resetViewRoot: function (t) {
            t ? this._viewRoot = t : t = this._viewRoot;
            var e = this.getRawData().tree.root;
            (!t || t !== e && !e.contains(t)) && (this._viewRoot = e)
        }
    });
    var UO = 8, XO = 8, YO = 5;
    Rp.prototype = {
        constructor: Rp, render: function (t, e, i, n) {
            var o = t.getModel("breadcrumb"), a = this.group;
            if (a.removeAll(), o.get("show") && i) {
                var r = o.getModel("itemStyle"), s = r.getModel("textStyle"), l = {
                    pos: {left: o.get("left"), right: o.get("right"), top: o.get("top"), bottom: o.get("bottom")},
                    box: {width: e.getWidth(), height: e.getHeight()},
                    emptyItemWidth: o.get("emptyItemWidth"),
                    totalWidth: 0,
                    renderList: []
                };
                this._prepare(i, l, s), this._renderContent(t, l, r, s, n), is(a, l.pos, l.box)
            }
        }, _prepare: function (t, e, i) {
            for (var n = t; n; n = n.parentNode) {
                var o = n.getModel().get("name"), a = i.getTextRect(o),
                    r = Math.max(a.width + 2 * UO, e.emptyItemWidth);
                e.totalWidth += r + XO, e.renderList.push({node: n, text: o, width: r})
            }
        }, _renderContent: function (t, e, i, n, o) {
            for (var a = 0, r = e.emptyItemWidth, l = t.get("breadcrumb.height"), u = ts(e.pos, e.box), h = e.totalWidth, c = e.renderList, d = c.length - 1; d >= 0; d--) {
                var f = c[d], p = f.node, g = f.width, m = f.text;
                h > u.width && (h -= g - r, g = r, m = null);
                var v = new IA({
                    shape: {points: zp(a, 0, g, l, d === c.length - 1, 0 === d)},
                    style: s(i.getItemStyle(), {
                        lineJoin: "bevel",
                        text: m,
                        textFill: n.getTextColor(),
                        textFont: n.getFont()
                    }),
                    z: 10,
                    onclick: x(o, p)
                });
                this.group.add(v), Bp(v, t, p), a += g + XO
            }
        }, remove: function () {
            this.group.removeAll()
        }
    };
    var jO = y, qO = iI, KO = CA, $O = f, JO = 3, QO = ["label"], tE = ["emphasis", "label"], eE = ["upperLabel"],
        iE = ["emphasis", "upperLabel"], nE = 10, oE = 1, aE = 2,
        rE = hT([["fill", "color"], ["stroke", "strokeColor"], ["lineWidth", "strokeWidth"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]),
        sE = function (t) {
            var e = rE(t);
            return e.stroke = e.fill = e.lineWidth = null, e
        };
    Wu({
        type: "treemap", init: function () {
            this._containerGroup, this._storage = Gp(), this._oldTree, this._breadcrumb, this._controller, this._state = "ready"
        }, render: function (t, e, i, n) {
            var o = e.findComponents({mainType: "series", subType: "treemap", query: n});
            if (!(u(o, t) < 0)) {
                this.seriesModel = t, this.api = i, this.ecModel = e;
                var a = ["treemapZoomToNode", "treemapRootToNode"], r = Lp(n, a, t), s = n && n.type, l = t.layoutInfo,
                    h = !this._oldTree, c = this._storage, d = "treemapRootToNode" === s && r && c ? {
                        rootNodeGroup: c.nodeGroup[r.node.getRawIndex()],
                        direction: n.direction
                    } : null, f = this._giveContainerGroup(l), p = this._doRender(f, t, d);
                h || s && "treemapZoomToNode" !== s && "treemapRootToNode" !== s ? p.renderFinally() : this._doAnimation(f, p, t, d), this._resetController(i), this._renderBreadcrumb(t, i, r)
            }
        }, _giveContainerGroup: function (t) {
            var e = this._containerGroup;
            return e || (e = this._containerGroup = new qO, this._initEvents(e), this.group.add(e)), e.attr("position", [t.x, t.y]), e
        }, _doRender: function (t, e, i) {
            function n(t, e, i, o, a) {
                function r(t) {
                    return t.getId()
                }

                function s(r, s) {
                    var l = null != r ? t[r] : null, u = null != s ? e[s] : null, h = d(l, u, i, a);
                    h && n(l && l.viewChildren || [], u && u.viewChildren || [], h, o, a + 1)
                }

                o ? (e = t, $O(t, function (t, e) {
                    !t.isRemoved() && s(e, e)
                })) : new Yu(e, t, r, r).add(s).update(s).remove(x(s, null)).execute()
            }

            function o(t) {
                var e = Gp();
                return t && $O(t, function (t, i) {
                    var n = e[i];
                    $O(t, function (t) {
                        t && (n.push(t), t.__tmWillDelete = 1)
                    })
                }), e
            }

            function a() {
                $O(f, function (t) {
                    $O(t, function (t) {
                        t.parent && t.parent.remove(t)
                    })
                }), $O(c, function (t) {
                    t.invisible = !0, t.dirty()
                })
            }

            var r = e.getData().tree, s = this._oldTree, l = Gp(), u = Gp(), h = this._storage, c = [],
                d = x(Fp, e, u, h, i, l, c);
            n(r.root ? [r.root] : [], s && s.root ? [s.root] : [], t, r === s || !s, 0);
            var f = o(h);
            return this._oldTree = r, this._storage = u, {lastsForAnimation: l, willDeleteEls: f, renderFinally: a}
        }, _doAnimation: function (t, e, i, n) {
            if (i.get("animation")) {
                var o = i.get("animationDurationUpdate"), a = i.get("animationEasing"), s = Vp();
                $O(e.willDeleteEls, function (t, e) {
                    $O(t, function (t) {
                        if (!t.invisible) {
                            var i, r = t.parent;
                            if (n && "drillDown" === n.direction) i = r === n.rootNodeGroup ? {
                                shape: {
                                    x: 0,
                                    y: 0,
                                    width: r.__tmNodeWidth,
                                    height: r.__tmNodeHeight
                                }, style: {opacity: 0}
                            } : {style: {opacity: 0}}; else {
                                var l = 0, u = 0;
                                r.__tmWillDelete || (l = r.__tmNodeWidth / 2, u = r.__tmNodeHeight / 2), i = "nodeGroup" === e ? {
                                    position: [l, u],
                                    style: {opacity: 0}
                                } : {shape: {x: l, y: u, width: 0, height: 0}, style: {opacity: 0}}
                            }
                            i && s.add(t, i, o, a)
                        }
                    })
                }), $O(this._storage, function (t, i) {
                    $O(t, function (t, n) {
                        var l = e.lastsForAnimation[i][n], u = {};
                        l && ("nodeGroup" === i ? l.old && (u.position = t.position.slice(), t.attr("position", l.old)) : (l.old && (u.shape = r({}, t.shape), t.setShape(l.old)), l.fadein ? (t.setStyle("opacity", 0), u.style = {opacity: 1}) : 1 !== t.style.opacity && (u.style = {opacity: 1})), s.add(t, u, o, a))
                    })
                }, this), this._state = "animating", s.done(jO(function () {
                    this._state = "ready", e.renderFinally()
                }, this)).start()
            }
        }, _resetController: function (t) {
            var e = this._controller;
            e || (e = this._controller = new hp(t.getZr()), e.enable(this.seriesModel.get("roam")), e.on("pan", jO(this._onPan, this)), e.on("zoom", jO(this._onZoom, this)));
            var i = new Ti(0, 0, t.getWidth(), t.getHeight());
            e.setPointerChecker(function (t, e, n) {
                return i.contain(e, n)
            })
        }, _clearController: function () {
            var t = this._controller;
            t && (t.dispose(), t = null)
        }, _onPan: function (t) {
            if ("animating" !== this._state && (Math.abs(t.dx) > JO || Math.abs(t.dy) > JO)) {
                var e = this.seriesModel.getData().tree.root;
                if (!e) return;
                var i = e.getLayout();
                if (!i) return;
                this.api.dispatchAction({
                    type: "treemapMove",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {x: i.x + t.dx, y: i.y + t.dy, width: i.width, height: i.height}
                })
            }
        }, _onZoom: function (t) {
            var e = t.originX, i = t.originY;
            if ("animating" !== this._state) {
                var n = this.seriesModel.getData().tree.root;
                if (!n) return;
                var o = n.getLayout();
                if (!o) return;
                var a = new Ti(o.x, o.y, o.width, o.height), r = this.seriesModel.layoutInfo;
                e -= r.x, i -= r.y;
                var s = Oe();
                ze(s, s, [-e, -i]), Ve(s, s, [t.scale, t.scale]), ze(s, s, [e, i]), a.applyTransform(s), this.api.dispatchAction({
                    type: "treemapRender",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {x: a.x, y: a.y, width: a.width, height: a.height}
                })
            }
        }, _initEvents: function (t) {
            t.on("click", function (t) {
                if ("ready" === this._state) {
                    var e = this.seriesModel.get("nodeClick", !0);
                    if (e) {
                        var i = this.findTarget(t.offsetX, t.offsetY);
                        if (i) {
                            var n = i.node;
                            if (n.getLayout().isLeafRoot) this._rootToNode(i); else if ("zoomToNode" === e) this._zoomToNode(i); else if ("link" === e) {
                                var o = n.hostTree.data.getItemModel(n.dataIndex), a = o.get("link", !0),
                                    r = o.get("target", !0) || "blank";
                                a && Jr(a, r)
                            }
                        }
                    }
                }
            }, this)
        }, _renderBreadcrumb: function (t, e, i) {
            function n(e) {
                "animating" !== this._state && (Pp(t.getViewRoot(), e) ? this._rootToNode({node: e}) : this._zoomToNode({node: e}))
            }

            i || (i = null != t.get("leafDepth", !0) ? {node: t.getViewRoot()} : this.findTarget(e.getWidth() / 2, e.getHeight() / 2), i || (i = {node: t.getData().tree.root})), (this._breadcrumb || (this._breadcrumb = new Rp(this.group))).render(t, e, i.node, jO(n, this))
        }, remove: function () {
            this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = Gp(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove()
        }, dispose: function () {
            this._clearController()
        }, _zoomToNode: function (t) {
            this.api.dispatchAction({
                type: "treemapZoomToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            })
        }, _rootToNode: function (t) {
            this.api.dispatchAction({
                type: "treemapRootToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            })
        }, findTarget: function (t, e) {
            var i, n = this.seriesModel.getViewRoot();
            return n.eachNode({attr: "viewChildren", order: "preorder"}, function (n) {
                var o = this._storage.background[n.getRawIndex()];
                if (o) {
                    var a = o.transformCoordToLocal(t, e), r = o.shape;
                    if (!(r.x <= a[0] && a[0] <= r.x + r.width && r.y <= a[1] && a[1] <= r.y + r.height)) return !1;
                    i = {node: n, offsetX: a[0], offsetY: a[1]}
                }
            }, this), i
        }
    });
    for (var lE = function () {
    }, uE = ["treemapZoomToNode", "treemapRender", "treemapMove"], hE = 0; hE < uE.length; hE++) Pu({
        type: uE[hE],
        update: "updateView"
    }, lE);
    Pu({type: "treemapRootToNode", update: "updateView"}, function (t, e) {
        function i(e) {
            var i = ["treemapZoomToNode", "treemapRootToNode"], n = Lp(t, i, e);
            if (n) {
                var o = e.getViewRoot();
                o && (t.direction = Pp(o, n.node) ? "rollUp" : "drillDown"), e.resetViewRoot(n.node)
            }
        }

        e.eachComponent({mainType: "series", subType: "treemap", query: t}, i)
    });
    var cE = f, dE = S, fE = -1, pE = function (t) {
        var e = t.mappingMethod, i = t.type, o = this.option = n(t);
        this.type = i, this.mappingMethod = e, this._normalizeData = mE[e];
        var a = gE[i];
        this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._doMap = a._doMap[e], "piecewise" === e ? (Up(o), Hp(o)) : "category" === e ? o.categories ? Zp(o) : Up(o, !0) : (O("linear" !== e || o.dataExtent), Up(o))
    };
    pE.prototype = {
        constructor: pE, mapValueToVisual: function (t) {
            var e = this._normalizeData(t);
            return this._doMap(e, t)
        }, getNormalizer: function () {
            return y(this._normalizeData, this)
        }
    };
    var gE = pE.visualHandlers = {
        color: {
            applyVisual: jp("color"), getColorMapper: function () {
                var t = this.option;
                return y("category" === t.mappingMethod ? function (t, e) {
                    return !e && (t = this._normalizeData(t)), qp.call(this, t)
                } : function (e, i, n) {
                    var o = !!n;
                    return !i && (e = this._normalizeData(e)), n = ai(e, t.parsedVisual, n), o ? n : ui(n, "rgba")
                }, this)
            }, _doMap: {
                linear: function (t) {
                    return ui(ai(t, this.option.parsedVisual), "rgba")
                }, category: qp, piecewise: function (t, e) {
                    var i = Jp.call(this, e);
                    return null == i && (i = ui(ai(t, this.option.parsedVisual), "rgba")), i
                }, fixed: Kp
            }
        },
        colorHue: Xp(function (t, e) {
            return si(t, e)
        }),
        colorSaturation: Xp(function (t, e) {
            return si(t, null, e)
        }),
        colorLightness: Xp(function (t, e) {
            return si(t, null, null, e)
        }),
        colorAlpha: Xp(function (t, e) {
            return li(t, e)
        }),
        opacity: {applyVisual: jp("opacity"), _doMap: $p([0, 1])},
        liftZ: {applyVisual: jp("liftZ"), _doMap: {linear: Kp, category: Kp, piecewise: Kp, fixed: Kp}},
        symbol: {
            applyVisual: function (t, e, i) {
                var n = this.mapValueToVisual(t);
                if (b(n)) i("symbol", n); else if (dE(n)) for (var o in n) n.hasOwnProperty(o) && i(o, n[o])
            }, _doMap: {
                linear: Yp, category: qp, piecewise: function (t, e) {
                    var i = Jp.call(this, e);
                    return null == i && (i = Yp.call(this, t)), i
                }, fixed: Kp
            }
        },
        symbolSize: {applyVisual: jp("symbolSize"), _doMap: $p([0, 1])}
    }, mE = {
        linear: function (t) {
            return Mr(t, this.option.dataExtent, [0, 1], !0)
        }, piecewise: function (t) {
            var e = this.option.pieceList, i = pE.findPieceIndex(t, e, !0);
            return null != i ? Mr(i, [0, e.length - 1], [0, 1], !0) : void 0
        }, category: function (t) {
            var e = this.option.categories ? this.option.categoryMap[t] : t;
            return null == e ? fE : e
        }, fixed: G
    };
    pE.listVisualTypes = function () {
        var t = [];
        return f(gE, function (e, i) {
            t.push(i)
        }), t
    }, pE.addVisualHandler = function (t, e) {
        gE[t] = e
    }, pE.isValidType = function (t) {
        return gE.hasOwnProperty(t)
    }, pE.eachVisual = function (t, e, i) {
        S(t) ? f(t, e, i) : e.call(i, t)
    }, pE.mapVisual = function (t, e, i) {
        var n, o = _(t) ? [] : S(t) ? {} : (n = !0, null);
        return pE.eachVisual(t, function (t, a) {
            var r = e.call(i, t, a);
            n ? o = r : o[a] = r
        }), o
    }, pE.retrieveVisuals = function (t) {
        var e, i = {};
        return t && cE(gE, function (n, o) {
            t.hasOwnProperty(o) && (i[o] = t[o], e = !0)
        }), e ? i : null
    }, pE.prepareVisualTypes = function (t) {
        if (dE(t)) {
            var e = [];
            cE(t, function (t, i) {
                e.push(i)
            }), t = e
        } else {
            if (!_(t)) return [];
            t = t.slice()
        }
        return t.sort(function (t, e) {
            return "color" === e && "color" !== t && 0 === t.indexOf("color") ? 1 : -1
        }), t
    }, pE.dependsOn = function (t, e) {
        return "color" === e ? !(!t || 0 !== t.indexOf(e)) : t === e
    }, pE.findPieceIndex = function (t, e, i) {
        function n(e, i) {
            var n = Math.abs(e - t);
            a > n && (a = n, o = i)
        }

        for (var o, a = 1 / 0, r = 0, s = e.length; s > r; r++) {
            var l = e[r].value;
            if (null != l) {
                if (l === t || "string" == typeof l && l === t + "") return r;
                i && n(l, r)
            }
        }
        for (var r = 0, s = e.length; s > r; r++) {
            var u = e[r], h = u.interval, c = u.close;
            if (h) {
                if (h[0] === -1 / 0) {
                    if (tg(c[1], t, h[1])) return r
                } else if (1 / 0 === h[1]) {
                    if (tg(c[0], h[0], t)) return r
                } else if (tg(c[0], h[0], t) && tg(c[1], t, h[1])) return r;
                i && n(h[0], r), i && n(h[1], r)
            }
        }
        return i ? 1 / 0 === t ? e.length - 1 : t === -1 / 0 ? 0 : o : void 0
    };
    var vE = _, yE = "itemStyle", xE = {
            seriesType: "treemap", reset: function (t) {
                var e = t.getData().tree, i = e.root;
                i.isRemoved() || eg(i, {}, t.getViewRoot().getAncestors(), t)
            }
        }, _E = Math.max, wE = Math.min, bE = D, SE = f, ME = ["itemStyle", "borderWidth"], IE = ["itemStyle", "gapWidth"],
        TE = ["upperLabel", "show"], AE = ["upperLabel", "height"], DE = {
            seriesType: "treemap", reset: function (t, e, i, n) {
                var o = i.getWidth(), a = i.getHeight(), s = t.option,
                    l = es(t.getBoxLayoutParams(), {width: i.getWidth(), height: i.getHeight()}), u = s.size || [],
                    h = Ir(bE(l.width, u[0]), o), c = Ir(bE(l.height, u[1]), a), d = n && n.type,
                    f = ["treemapZoomToNode", "treemapRootToNode"], p = Lp(n, f, t),
                    g = "treemapRender" === d || "treemapMove" === d ? n.rootRect : null, m = t.getViewRoot(), v = kp(m);
                if ("treemapMove" !== d) {
                    var y = "treemapZoomToNode" === d ? mg(t, p, m, h, c) : g ? [g.width, g.height] : [h, c], x = s.sort;
                    x && "asc" !== x && "desc" !== x && (x = "desc");
                    var _ = {squareRatio: s.squareRatio, sort: x, leafDepth: s.leafDepth};
                    m.hostTree.clearLayouts();
                    var w = {x: 0, y: 0, width: y[0], height: y[1], area: y[0] * y[1]};
                    m.setLayout(w), ug(m, _, !1, 0);
                    var w = m.getLayout();
                    SE(v, function (t, e) {
                        var i = (v[e + 1] || m).getValue();
                        t.setLayout(r({dataExtent: [i, i], borderWidth: 0, upperHeight: 0}, w))
                    })
                }
                var b = t.getData().tree.root;
                b.setLayout(vg(l, g, p), !0), t.setLayoutInfo(l), yg(b, new Ti(-l.x, -l.y, o, a), v, m, 0)
            }
        };
    Ru(xE), Nu(DE), dC.extend({
        type: "series.sunburst",
        _viewRoot: null,
        getInitialData: function (t, e) {
            function i(t) {
                t.wrapMethod("getItemModel", function (t, e) {
                    var i = a.getNodeByDataIndex(e), n = o[i.depth];
                    return n && (t.parentModel = n), t
                })
            }

            var n = {name: t.name, children: t.data};
            _g(n);
            var o = p(t.levels || [], function (t) {
                return new vr(t, this, e)
            }, this), a = Gf.createTree(n, this, i);
            return a.data
        },
        optionUpdated: function () {
            this.resetViewRoot()
        },
        getDataParams: function (t) {
            var e = dC.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
            return e.treePathInfo = Op(i, this), e
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            center: ["50%", "50%"],
            radius: [0, "75%"],
            clockwise: !0,
            startAngle: 90,
            minAngle: 0,
            percentPrecision: 2,
            stillShowZeroSum: !0,
            highlightPolicy: "descendant",
            nodeClick: "rootToNode",
            renderLabelForZeroData: !1,
            label: {
                rotate: "radial",
                show: !0,
                opacity: 1,
                align: "center",
                position: "inside",
                distance: 5,
                silent: !0
            },
            itemStyle: {
                borderWidth: 1,
                borderColor: "white",
                borderType: "solid",
                shadowBlur: 0,
                shadowColor: "rgba(0, 0, 0, 0.2)",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                opacity: 1
            },
            highlight: {itemStyle: {opacity: 1}},
            downplay: {itemStyle: {opacity: .5}, label: {opacity: .6}},
            animationType: "expansion",
            animationDuration: 1e3,
            animationDurationUpdate: 500,
            animationEasing: "cubicOut",
            data: [],
            levels: [],
            sort: "desc"
        },
        getViewRoot: function () {
            return this._viewRoot
        },
        resetViewRoot: function (t) {
            t ? this._viewRoot = t : t = this._viewRoot;
            var e = this.getRawData().tree.root;
            (!t || t !== e && !e.contains(t)) && (this._viewRoot = e)
        }
    });
    var CE = {NONE: "none", DESCENDANT: "descendant", ANCESTOR: "ancestor", SELF: "self"}, LE = 2, kE = 4,
        PE = wg.prototype;
    PE.updateData = function (t, e, i, n, a) {
        this.node = e, e.piece = this, n = n || this._seriesModel, a = a || this._ecModel;
        var l = this.childAt(0);
        l.dataIndex = e.dataIndex;
        var u = e.getModel(), h = e.getLayout(), c = r({}, h);
        c.label = null;
        var d = bg(e, n, a);
        Ig(e, n, d);
        var f, p = u.getModel("itemStyle").getItemStyle();
        if ("normal" === i) f = p; else {
            var g = u.getModel(i + ".itemStyle").getItemStyle();
            f = o(g, p)
        }
        f = s({
            lineJoin: "bevel",
            fill: f.fill || d
        }, f), t ? (l.setShape(c), l.shape.r = h.r0, or(l, {shape: {r: h.r}}, n, e.dataIndex), l.useStyle(f)) : "object" == typeof f.fill && f.fill.type || "object" == typeof l.style.fill && l.style.fill.type ? (or(l, {shape: c}, n), l.useStyle(f)) : or(l, {
            shape: c,
            style: f
        }, n), this._updateLabel(n, d, i);
        var m = u.getShallow("cursor");
        if (m && l.attr("cursor", m), t) {
            var v = n.getShallow("highlightPolicy");
            this._initEvents(l, e, n, v)
        }
        this._seriesModel = n || this._seriesModel, this._ecModel = a || this._ecModel, Wa(this)
    }, PE.onEmphasis = function (t) {
        var e = this;
        this.node.hostTree.root.eachNode(function (i) {
            i.piece && (e.node === i ? i.piece.updateData(!1, i, "emphasis") : Mg(i, e.node, t) ? i.piece.childAt(0).trigger("highlight") : t !== CE.NONE && i.piece.childAt(0).trigger("downplay"))
        })
    }, PE.onNormal = function () {
        this.node.hostTree.root.eachNode(function (t) {
            t.piece && t.piece.updateData(!1, t, "normal")
        })
    }, PE.onHighlight = function () {
        this.updateData(!1, this.node, "highlight")
    }, PE.onDownplay = function () {
        this.updateData(!1, this.node, "downplay")
    }, PE._updateLabel = function (t, e, i) {
        function n(t) {
            var e = r.get(t);
            return null == e ? a.get(t) : e
        }

        var o = this.node.getModel(), a = o.getModel("label"),
            r = "normal" === i || "emphasis" === i ? a : o.getModel(i + ".label"), s = o.getModel("emphasis.label"),
            l = r.get("formatter"), u = l ? i : "normal",
            h = D(t.getFormattedLabel(this.node.dataIndex, u, null, null, "label"), this.node.name);
        n("show") === !1 && (h = "");
        var c = this.node.getLayout(), d = r.get("minAngle");
        null == d && (d = a.get("minAngle")), d = d / 180 * Math.PI;
        var f = c.endAngle - c.startAngle;
        null != d && Math.abs(f) < d && (h = "");
        var p = this.childAt(1);
        Xa(p.style, p.hoverStyle || {}, a, s, {
            defaultText: r.getShallow("show") ? h : null,
            autoColor: e,
            useInsideStyle: !0
        });
        var g, m = (c.startAngle + c.endAngle) / 2, v = Math.cos(m), y = Math.sin(m), x = n("position"),
            _ = n("distance") || 0, w = n("align");
        "outside" === x ? (g = c.r + _, w = m > Math.PI / 2 ? "right" : "left") : w && "center" !== w ? "left" === w ? (g = c.r0 + _, m > Math.PI / 2 && (w = "right")) : "right" === w && (g = c.r - _, m > Math.PI / 2 && (w = "left")) : (g = (c.r + c.r0) / 2, w = "center"), p.attr("style", {
            text: h,
            textAlign: w,
            textVerticalAlign: n("verticalAlign") || "middle",
            opacity: n("opacity")
        });
        var b = g * v + c.cx, S = g * y + c.cy;
        p.attr("position", [b, S]);
        var M = n("rotate"), I = 0;
        "radial" === M ? (I = -m, I < -Math.PI / 2 && (I += Math.PI)) : "tangential" === M ? (I = Math.PI / 2 - m, I > Math.PI / 2 ? I -= Math.PI : I < -Math.PI / 2 && (I += Math.PI)) : "number" == typeof M && (I = M * Math.PI / 180), p.attr("rotation", I)
    }, PE._initEvents = function (t, e, i, n) {
        t.off("mouseover").off("mouseout").off("emphasis").off("normal");
        var o = this, a = function () {
            o.onEmphasis(n)
        }, r = function () {
            o.onNormal()
        }, s = function () {
            o.onDownplay()
        }, l = function () {
            o.onHighlight()
        };
        i.isAnimationEnabled() && t.on("mouseover", a).on("mouseout", r).on("emphasis", a).on("normal", r).on("downplay", s).on("highlight", l)
    }, h(wg, iI);
    var OE = "sunburstRootToNode", EE = (yl.extend({
        type: "sunburst", init: function () {
        }, render: function (t, e, i, n) {
            function o(t, e) {
                function i(t) {
                    return t.getId()
                }

                function n(i, n) {
                    var o = null == i ? null : t[i], r = null == n ? null : e[n];
                    a(o, r)
                }

                (0 !== t.length || 0 !== e.length) && new Yu(e, t, i, i).add(n).update(n).remove(x(n, null)).execute()
            }

            function a(i, n) {
                if (f || !i || i.getValue() || (i = null), i !== h && n !== h) if (n && n.piece) i ? (n.piece.updateData(!1, i, "normal", t, e), u.setItemGraphicEl(i.dataIndex, n.piece)) : r(n); else if (i) {
                    var o = new wg(i, t, e);
                    d.add(o), u.setItemGraphicEl(i.dataIndex, o)
                }
            }

            function r(t) {
                t && t.piece && (d.remove(t.piece), t.piece = null)
            }

            function s(i, n) {
                if (n.depth > 0) {
                    l.virtualPiece ? l.virtualPiece.updateData(!1, i, "normal", t, e) : (l.virtualPiece = new wg(i, t, e), d.add(l.virtualPiece)), n.piece._onclickEvent && n.piece.off("click", n.piece._onclickEvent);
                    var o = function () {
                        l._rootToNode(n.parentNode)
                    };
                    n.piece._onclickEvent = o, l.virtualPiece.on("click", o)
                } else l.virtualPiece && (d.remove(l.virtualPiece), l.virtualPiece = null)
            }

            var l = this;
            this.seriesModel = t, this.api = i, this.ecModel = e;
            var u = t.getData(), h = u.tree.root, c = t.getViewRoot(), d = this.group,
                f = t.get("renderLabelForZeroData"), p = [];
            c.eachNode(function (t) {
                p.push(t)
            });
            var g = this._oldChildren || [];
            if (o(p, g), s(h, c), n && n.highlight && n.highlight.piece) {
                var m = t.getShallow("highlightPolicy");
                n.highlight.piece.onEmphasis(m)
            } else if (n && n.unhighlight) {
                var v = this.virtualPiece;
                !v && h.children.length && (v = h.children[0].piece), v && v.onNormal()
            }
            this._initEvents(), this._oldChildren = p
        }, dispose: function () {
        }, _initEvents: function () {
            var t = this, e = function (e) {
                var i = !1, n = t.seriesModel.getViewRoot();
                n.eachNode(function (n) {
                    if (!i && n.piece && n.piece.childAt(0) === e.target) {
                        var o = n.getModel().get("nodeClick");
                        if ("rootToNode" === o) t._rootToNode(n); else if ("link" === o) {
                            var a = n.getModel(), r = a.get("link");
                            if (r) {
                                var s = a.get("target", !0) || "_blank";
                                Jr(r, s)
                            }
                        }
                        i = !0
                    }
                })
            };
            this.group._onclickEvent && this.group.off("click", this.group._onclickEvent), this.group.on("click", e), this.group._onclickEvent = e
        }, _rootToNode: function (t) {
            t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
                type: OE,
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t
            })
        }, containPoint: function (t, e) {
            var i = e.getData(), n = i.getItemLayout(0);
            if (n) {
                var o = t[0] - n.cx, a = t[1] - n.cy, r = Math.sqrt(o * o + a * a);
                return r <= n.r && r >= n.r0
            }
        }
    }), "sunburstRootToNode");
    Pu({type: EE, update: "updateView"}, function (t, e) {
        function i(e) {
            var i = Lp(t, [EE], e);
            if (i) {
                var n = e.getViewRoot();
                n && (t.direction = Pp(n, i.node) ? "rollUp" : "drillDown"), e.resetViewRoot(i.node)
            }
        }

        e.eachComponent({mainType: "series", subType: "sunburst", query: t}, i)
    });
    var NE = "sunburstHighlight";
    Pu({type: NE, update: "updateView"}, function (t, e) {
        function i(e) {
            var i = Lp(t, [NE], e);
            i && (t.highlight = i.node)
        }

        e.eachComponent({mainType: "series", subType: "sunburst", query: t}, i)
    });
    var RE = "sunburstUnhighlight";
    Pu({type: RE, update: "updateView"}, function (t, e) {
        function i() {
            t.unhighlight = !0
        }

        e.eachComponent({mainType: "series", subType: "sunburst", query: t}, i)
    });
    var zE = Math.PI / 180, BE = function (t, e, i) {
        e.eachSeriesByType(t, function (t) {
            var e = t.get("center"), n = t.get("radius");
            _(n) || (n = [0, n]), _(e) || (e = [e, e]);
            var o = i.getWidth(), a = i.getHeight(), r = Math.min(o, a), s = Ir(e[0], o), l = Ir(e[1], a),
                u = Ir(n[0], r / 2), h = Ir(n[1], r / 2), c = -t.get("startAngle") * zE, d = t.get("minAngle") * zE,
                p = t.getData().tree.root, g = t.getViewRoot(), m = g.depth, v = t.get("sort");
            null != v && Tg(g, v);
            var y = 0;
            f(g.children, function (t) {
                !isNaN(t.getValue()) && y++
            });
            var x = g.getValue(), w = Math.PI / (x || y) * 2, b = g.depth > 0, S = g.height - (b ? -1 : 1),
                M = (h - u) / (S || 1), I = t.get("clockwise"), T = t.get("stillShowZeroSum"), A = I ? 1 : -1,
                D = function (t, e) {
                    if (t) {
                        var i = e;
                        if (t !== p) {
                            var n = t.getValue(), o = 0 === x && T ? w : n * w;
                            d > o && (o = d), i = e + A * o;
                            var a = t.depth - m - (b ? -1 : 1), h = u + M * a, c = u + M * (a + 1), g = t.getModel();
                            null != g.get("r0") && (h = Ir(g.get("r0"), r / 2)), null != g.get("r") && (c = Ir(g.get("r"), r / 2)), t.setLayout({
                                angle: o,
                                startAngle: e,
                                endAngle: i,
                                clockwise: I,
                                cx: s,
                                cy: l,
                                r0: h,
                                r: c
                            })
                        }
                        if (t.children && t.children.length) {
                            var v = 0;
                            f(t.children, function (t) {
                                v += D(t, e + v)
                            })
                        }
                        return i - e
                    }
                };
            if (b) {
                var C = u, L = u + M, k = 2 * Math.PI;
                p.setLayout({angle: k, startAngle: c, endAngle: c + k, clockwise: I, cx: s, cy: l, r0: C, r: L})
            }
            D(g, c)
        })
    };
    Ru(x(nO, "sunburst")), Nu(x(BE, "sunburst")), Lu(x(uO, "sunburst"));
    for (var VE = [126, 25], GE = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], FE = 0; FE < GE.length; FE++) for (var WE = 0; WE < GE[FE].length; WE++) GE[FE][WE][0] /= 10.5, GE[FE][WE][1] /= -14, GE[FE][WE][0] += VE[0], GE[FE][WE][1] += VE[1];
    var HE = function (t, e) {
            "china" === t && e.push(new cc("南海诸岛", p(GE, function (t) {
                return {type: "polygon", exterior: t}
            }), VE))
        }, ZE = {"南海诸岛": [32, 80], "广东": [0, -10], "香港": [10, 5], "澳门": [-10, 10], "天津": [5, 5]}, UE = function (t, e) {
            if ("china" === t) {
                var i = ZE[e.name];
                if (i) {
                    var n = e.center;
                    n[0] += i[0] / 10.5, n[1] += -i[1] / 14
                }
            }
        }, XE = {Russia: [100, 60], "United States": [-99, 38], "United States of America": [-99, 38]},
        YE = function (t, e) {
            if ("world" === t) {
                var i = XE[e.name];
                if (i) {
                    var n = e.center;
                    n[0] = i[0], n[1] = i[1]
                }
            }
        },
        jE = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]],
        qE = function (t, e) {
            "china" === t && "台湾" === e.name && e.geometries.push({type: "polygon", exterior: jE[0]})
        }, KE = co(), $E = {
            load: function (t, e, i) {
                var n = KE(e).parsed;
                if (n) return n;
                var o, a = e.specialAreas || {}, r = e.geoJSON;
                try {
                    o = r ? Fk(r, i) : []
                } catch (s) {
                    throw new Error("Invalid geoJson format\n" + s.message)
                }
                return HE(t, o), f(o, function (e) {
                    var i = e.name;
                    UE(t, e), YE(t, e), qE(t, e);
                    var n = a[i];
                    n && e.transformTo(n.left, n.top, n.width, n.height)
                }), KE(e).parsed = {regions: o, boundingRect: Dg(o)}
            }
        }, JE = co(), QE = {
            load: function (t, e) {
                var i = JE(e).originRoot;
                if (i) return {root: i, boundingRect: JE(e).boundingRect};
                var n = Cg(e);
                return JE(e).originRoot = n.root, JE(e).boundingRect = n.boundingRect, n
            }, makeGraphic: function (t, e, i) {
                var n = JE(e), o = n.rootMap || (n.rootMap = B()), a = o.get(i);
                if (a) return a;
                var r = n.originRoot, s = n.boundingRect;
                return n.originRootHostKey ? a = Cg(e, s).root : (n.originRootHostKey = i, a = r), o.set(i, a)
            }, removeGraphic: function (t, e, i) {
                var n = JE(e), o = n.rootMap;
                o && o.removeKey(i), i === n.originRootHostKey && (n.originRootHostKey = null)
            }
        }, tN = {geoJSON: $E, svg: QE}, eN = {
            load: function (t, e, i) {
                var n, o = [], a = B(), r = B(), s = Pg(t);
                return f(s, function (s) {
                    var l = tN[s.type].load(t, s, i);
                    f(l.regions, function (t) {
                        var i = t.name;
                        e && e.hasOwnProperty(i) && (t = t.cloneShallow(i = e[i])), o.push(t), a.set(i, t), r.set(i, t.center)
                    });
                    var u = l.boundingRect;
                    u && (n ? n.union(u) : n = u.clone())
                }), {regions: o, regionsMap: a, nameCoordMap: r, boundingRect: n || new Ti(0, 0, 0, 0)}
            }, makeGraphic: Lg("makeGraphic"), removeGraphic: Lg("removeGraphic")
        }, iN = dC.extend({
            type: "series.map",
            dependencies: ["geo"],
            layoutMode: "box",
            needsDrawMap: !1,
            seriesGroup: [],
            getInitialData: function () {
                for (var t = JP(this, {
                    coordDimensions: ["value"],
                    encodeDefaulter: x(xs, this)
                }), e = t.mapDimension("value"), i = B(), n = [], o = [], a = 0, r = t.count(); r > a; a++) {
                    var s = t.getName(a);
                    i.set(s, !0), n.push({name: s, value: t.get(e, a), selected: al(t, a, "selected")})
                }
                var l = eN.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
                return f(l.regions, function (t) {
                    var e = t.name;
                    i.get(e) || (n.push({name: e}), o.push(e))
                }), this.updateSelectedMap(n), t.appendValues([], o), t
            },
            getHostGeoModel: function () {
                var t = this.option.geoIndex;
                return null != t ? this.dependentModels.geo[t] : null
            },
            getMapType: function () {
                return (this.getHostGeoModel() || this).option.map
            },
            getRawValue: function (t) {
                var e = this.getData();
                return e.get(e.mapDimension("value"), t)
            },
            getRegionModel: function (t) {
                var e = this.getData();
                return e.getItemModel(e.indexOfName(t))
            },
            formatTooltip: function (t, e, i, n) {
                for (var o = this.getData(), a = Fr(this.getRawValue(t)), r = o.getName(t), s = this.seriesGroup, l = [], u = 0; u < s.length; u++) {
                    var h = s[u].originalData.indexOfName(r), c = o.mapDimension("value");
                    isNaN(s[u].originalData.get(c, h)) || l.push(Hr(s[u].name))
                }
                var d = "html" === n ? "<br/>" : "\n";
                return l.join(", ") + d + Hr(r + " : " + a)
            },
            getTooltipPosition: function (t) {
                if (null != t) {
                    var e = this.getData().getName(t), i = this.coordinateSystem, n = i.getRegion(e);
                    return n && i.dataToPoint(n.center)
                }
            },
            setZoom: function (t) {
                this.option.zoom = t
            },
            setCenter: function (t) {
                this.option.center = t
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "geo",
                map: "",
                left: "center",
                top: "center",
                aspectScale: .75,
                showLegendSymbol: !0,
                dataRangeHoverLink: !0,
                boundingCoords: null,
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {show: !1, color: "#000"},
                itemStyle: {borderWidth: .5, borderColor: "#444", areaColor: "#eee"},
                emphasis: {label: {show: !0, color: "rgb(100,0,0)"}, itemStyle: {areaColor: "rgba(255,215,0,0.8)"}},
                nameProperty: "name"
            }
        });
    c(iN, QP), Rg.prototype = {
        constructor: Rg, draw: function (t, e, i, n, o) {
            var a = "geo" === t.mainType, r = t.getData && t.getData();
            a && e.eachComponent({mainType: "series", subType: "map"}, function (e) {
                r || e.getHostGeoModel() !== t || (r = e.getData())
            });
            var s = t.coordinateSystem;
            this._updateBackground(s);
            var l, u = this._regionsGroup, h = this.group, c = s.getTransformInfo(), d = !u.childAt(0) || o;
            if (d) h.transform = c.roamTransform, h.decomposeTransform(), h.dirty(); else {
                var p = new AM;
                p.transform = c.roamTransform, p.decomposeTransform();
                var g = {scale: p.scale, position: p.position};
                l = p.scale, or(h, g, t)
            }
            var m = c.rawScale, v = c.rawPosition;
            u.removeAll();
            var y = ["itemStyle"], x = ["emphasis", "itemStyle"], _ = ["label"], w = ["emphasis", "label"], b = B();
            f(s.regions, function (e) {
                var i = b.get(e.name) || b.set(e.name, new iI),
                    n = new NA({segmentIgnoreThreshold: 1, shape: {paths: []}});
                i.add(n);
                var o, s = t.getRegionModel(e.name) || t, c = s.getModel(y), p = s.getModel(x), g = Og(c), S = Og(p),
                    M = s.getModel(_), I = s.getModel(w);
                if (r) {
                    o = r.indexOfName(e.name);
                    var T = r.getItemVisual(o, "color", !0);
                    T && (g.fill = T)
                }
                var A = function (t) {
                    return [t[0] * m[0] + v[0], t[1] * m[1] + v[1]]
                };
                f(e.geometries, function (t) {
                    if ("polygon" === t.type) {
                        for (var e = [], i = 0; i < t.exterior.length; ++i) e.push(A(t.exterior[i]));
                        n.shape.paths.push(new IA({segmentIgnoreThreshold: 1, shape: {points: e}}));
                        for (var i = 0; i < (t.interiors ? t.interiors.length : 0); ++i) {
                            for (var o = t.interiors[i], e = [], a = 0; a < o.length; ++a) e.push(A(o[a]));
                            n.shape.paths.push(new IA({segmentIgnoreThreshold: 1, shape: {points: e}}))
                        }
                    }
                }), n.setStyle(g), n.style.strokeNoScale = !0, n.culling = !0;
                var D = M.get("show"), C = I.get("show"), L = r && isNaN(r.get(r.mapDimension("value"), o)),
                    k = r && r.getItemLayout(o);
                if (a || L && (D || C) || k && k.showLabel) {
                    var P, O = a ? e.name : o;
                    (!r || o >= 0) && (P = t);
                    var E = new vA({
                        position: A(e.center.slice()),
                        scale: [1 / h.scale[0], 1 / h.scale[1]],
                        z2: 10,
                        silent: !0
                    });
                    if (Xa(E.style, E.hoverStyle = {}, M, I, {
                        labelFetcher: P,
                        labelDataIndex: O,
                        defaultText: e.name,
                        useInsideStyle: !1
                    }, {textAlign: "center", textVerticalAlign: "middle"}), !d) {
                        var N = [1 / l[0], 1 / l[1]];
                        or(E, {scale: N}, t)
                    }
                    i.add(E)
                }
                if (r) r.setItemGraphicEl(o, i); else {
                    var s = t.getRegionModel(e.name);
                    n.eventData = {
                        componentType: "geo",
                        componentIndex: t.componentIndex,
                        geoIndex: t.componentIndex,
                        name: e.name,
                        region: s && s.option || {}
                    }
                }
                var R = i.__regions || (i.__regions = []);
                R.push(e), i.highDownSilentOnTouch = !!t.get("selectedMode"), Wa(i, S), u.add(i)
            }), this._updateController(t, e, i), Eg(this, t, u, i, n), Ng(t, u)
        }, remove: function () {
            this._regionsGroup.removeAll(), this._backgroundGroup.removeAll(), this._controller.dispose(), this._mapName && eN.removeGraphic(this._mapName, this.uid), this._mapName = null, this._controllerHost = {}
        }, _updateBackground: function (t) {
            var e = t.map;
            this._mapName !== e && f(eN.makeGraphic(e, this.uid), function (t) {
                this._backgroundGroup.add(t)
            }, this), this._mapName = e
        }, _updateController: function (t, e, i) {
            function n() {
                var e = {type: "geoRoam", componentType: l};
                return e[l + "Id"] = t.id, e
            }

            var o = t.coordinateSystem, a = this._controller, s = this._controllerHost;
            s.zoomLimit = t.get("scaleLimit"), s.zoom = o.getZoom(), a.enable(t.get("roam") || !1);
            var l = t.mainType;
            a.off("pan").on("pan", function (t) {
                this._mouseDownFlag = !1, op(s, t.dx, t.dy), i.dispatchAction(r(n(), {dx: t.dx, dy: t.dy}))
            }, this), a.off("zoom").on("zoom", function (t) {
                if (this._mouseDownFlag = !1, ap(s, t.scale, t.originX, t.originY), i.dispatchAction(r(n(), {
                    zoom: t.scale,
                    originX: t.originX,
                    originY: t.originY
                })), this._updateGroup) {
                    var e = this.group.scale;
                    this._regionsGroup.traverse(function (t) {
                        "text" === t.type && t.attr("scale", [1 / e[0], 1 / e[1]])
                    })
                }
            }, this), a.setPointerChecker(function (e, n, a) {
                return o.getViewRectAfterRoam().contain(n, a) && !xp(e, i, t)
            })
        }
    };
    var nN = "__seriesMapHighDown", oN = "__seriesMapCallKey";
    Wu({
        type: "map", render: function (t, e, i, n) {
            if (!n || "mapToggleSelect" !== n.type || n.from !== this.uid) {
                var o = this.group;
                if (o.removeAll(), !t.getHostGeoModel()) {
                    if (n && "geoRoam" === n.type && "series" === n.componentType && n.seriesId === t.id) {
                        var a = this._mapDraw;
                        a && o.add(a.group)
                    } else if (t.needsDrawMap) {
                        var a = this._mapDraw || new Rg(i, !0);
                        o.add(a.group), a.draw(t, e, i, this, n), this._mapDraw = a
                    } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
                    t.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(t, e, i)
                }
            }
        }, remove: function () {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll()
        }, dispose: function () {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null
        }, _renderSymbols: function (t) {
            var e = t.originalData, i = this.group;
            e.each(e.mapDimension("value"), function (n, o) {
                if (!isNaN(n)) {
                    var a = e.getItemLayout(o);
                    if (a && a.point) {
                        var s = a.point, l = a.offset, u = new yA({
                            style: {fill: t.getData().getVisual("color")},
                            shape: {cx: s[0] + 9 * l, cy: s[1], r: 3},
                            silent: !0,
                            z2: 8 + (l ? 0 : HA + 1)
                        });
                        if (!l) {
                            var h = t.mainSeries.getData(), c = e.getName(o), d = h.indexOfName(c),
                                f = e.getItemModel(o), p = f.getModel("label"), g = f.getModel("emphasis.label"),
                                m = h.getItemGraphicEl(d), v = C(t.getFormattedLabel(d, "normal"), c),
                                y = C(t.getFormattedLabel(d, "emphasis"), v), _ = m[nN], w = Math.random();
                            if (!_) {
                                _ = m[nN] = {};
                                var b = x(zg, !0), S = x(zg, !1);
                                m.on("mouseover", b).on("mouseout", S).on("emphasis", b).on("normal", S)
                            }
                            m[oN] = w, r(_, {
                                recordVersion: w,
                                circle: u,
                                labelModel: p,
                                hoverLabelModel: g,
                                emphasisText: y,
                                normalText: v
                            }), Bg(_, !1)
                        }
                        i.add(u)
                    }
                }
            })
        }
    }), Pu({type: "geoRoam", event: "geoRoam", update: "updateTransform"}, function (t, e) {
        var i = t.componentType || "series";
        e.eachComponent({mainType: i, query: t}, function (e) {
            var n = e.coordinateSystem;
            if ("geo" === n.type) {
                var o = Tp(n, t, e.get("scaleLimit"));
                e.setCenter && e.setCenter(o.center), e.setZoom && e.setZoom(o.zoom), "series" === i && f(e.seriesGroup, function (t) {
                    t.setCenter(o.center), t.setZoom(o.zoom)
                })
            }
        })
    }), Vg.prototype = {
        constructor: Vg, type: "geo", dimensions: ["lng", "lat"], containCoord: function (t) {
            for (var e = this.regions, i = 0; i < e.length; i++) if (e[i].contain(t)) return !0;
            return !1
        }, transformTo: function (t, e, i, n) {
            var o = this.getBoundingRect(), a = this._invertLongitute;
            o = o.clone(), a && (o.y = -o.y - o.height);
            var r = this._rawTransformable;
            if (r.transform = o.calculateTransform(new Ti(t, e, i, n)), r.decomposeTransform(), a) {
                var s = r.scale;
                s[1] = -s[1]
            }
            r.updateTransform(), this._updateTransform()
        }, getRegion: function (t) {
            return this._regionsMap.get(t)
        }, getRegionByCoord: function (t) {
            for (var e = this.regions, i = 0; i < e.length; i++) if (e[i].contain(t)) return e[i]
        }, addGeoCoord: function (t, e) {
            this._nameCoordMap.set(t, e)
        }, getGeoCoord: function (t) {
            return this._nameCoordMap.get(t)
        }, getBoundingRect: function () {
            return this._rect
        }, dataToPoint: function (t, e, i) {
            return "string" == typeof t && (t = this.getGeoCoord(t)), t ? ip.prototype.dataToPoint.call(this, t, e, i) : void 0
        }, convertToPixel: x(Gg, "dataToPoint"), convertFromPixel: x(Gg, "pointToData")
    }, c(Vg, ip);
    var aN = {
        dimensions: Vg.prototype.dimensions, create: function (t, e) {
            var i = [];
            t.eachComponent("geo", function (t, n) {
                var o = t.get("map"), a = t.get("aspectScale"), r = !0, s = qC.retrieveMap(o);
                s && s[0] && "svg" === s[0].type ? (null == a && (a = 1), r = !1) : null == a && (a = .75);
                var l = new Vg(o + n, o, t.get("nameMap"), r);
                l.aspectScale = a, l.zoomLimit = t.get("scaleLimit"), i.push(l), Wg(l, t), t.coordinateSystem = l, l.model = t, l.resize = Fg, l.resize(t, e)
            }), t.eachSeries(function (t) {
                var e = t.get("coordinateSystem");
                if ("geo" === e) {
                    var n = t.get("geoIndex") || 0;
                    t.coordinateSystem = i[n]
                }
            });
            var n = {};
            return t.eachSeriesByType("map", function (t) {
                if (!t.getHostGeoModel()) {
                    var e = t.getMapType();
                    n[e] = n[e] || [], n[e].push(t)
                }
            }), f(n, function (t, n) {
                var o = p(t, function (t) {
                    return t.get("nameMap")
                }), r = new Vg(n, n, a(o));
                r.zoomLimit = D.apply(null, p(t, function (t) {
                    return t.get("scaleLimit")
                })), i.push(r), r.resize = Fg, r.aspectScale = t[0].get("aspectScale"), r.resize(t[0], e), f(t, function (t) {
                    t.coordinateSystem = r, Wg(r, t)
                })
            }), i
        }, getFilledRegions: function (t, e, i) {
            for (var n = (t || []).slice(), o = B(), a = 0; a < n.length; a++) o.set(n[a].name, n[a]);
            var r = eN.load(e, i);
            return f(r.regions, function (t) {
                var e = t.name;
                !o.get(e) && n.push({name: e})
            }), n
        }
    };
    Ou("geo", aN);
    var rN = function (t) {
        var e = {};
        t.eachSeriesByType("map", function (i) {
            var n = i.getMapType();
            if (!i.getHostGeoModel() && !e[n]) {
                var o = {};
                f(i.seriesGroup, function (e) {
                    var i = e.coordinateSystem, n = e.originalData;
                    e.get("showLegendSymbol") && t.getComponent("legend") && n.each(n.mapDimension("value"), function (t, e) {
                        var a = n.getName(e), r = i.getRegion(a);
                        if (r && !isNaN(t)) {
                            var s = o[a] || 0, l = i.dataToPoint(r.center);
                            o[a] = s + 1, n.setItemLayout(e, {point: l, offset: s})
                        }
                    })
                });
                var a = i.getData();
                a.each(function (t) {
                    var e = a.getName(t), i = a.getItemLayout(t) || {};
                    i.showLabel = !o[e], a.setItemLayout(t, i)
                }), e[n] = !0
            }
        })
    }, sN = function (t) {
        t.eachSeriesByType("map", function (t) {
            var e = t.get("color"), i = t.getModel("itemStyle"), n = i.get("areaColor"),
                o = i.get("color") || e[t.seriesIndex % e.length];
            t.getData().setVisual({areaColor: n, color: o})
        })
    }, lN = function (t) {
        var e = {};
        t.eachSeriesByType("map", function (t) {
            var i = t.getHostGeoModel(), n = i ? "o" + i.id : "i" + t.getMapType();
            (e[n] = e[n] || []).push(t)
        }), f(e, function (t) {
            for (var e = Hg(p(t, function (t) {
                return t.getData()
            }), t[0].get("mapValueCalculation")), i = 0; i < t.length; i++) t[i].originalData = t[i].getData();
            for (var i = 0; i < t.length; i++) t[i].seriesGroup = t, t[i].needsDrawMap = 0 === i && !t[i].getHostGeoModel(), t[i].setData(e.cloneShallow()), t[i].mainSeries = t[0]
        })
    }, uN = function (t) {
        var e = [];
        f(t.series, function (t) {
            t && "map" === t.type && (e.push(t), t.map = t.map || t.mapType, s(t, t.mapLocation))
        })
    };
    Nu(rN), Ru(sN), Lu(mL.PROCESSOR.STATISTIC, lN), Cu(uN), iO("map", [{
        type: "mapToggleSelect",
        event: "mapselectchanged",
        method: "toggleSelected"
    }, {type: "mapSelect", event: "mapselected", method: "select"}, {
        type: "mapUnSelect",
        event: "mapunselected",
        method: "unSelect"
    }]);
    var hN = "undefined" == typeof Uint32Array ? Array : Uint32Array,
        cN = "undefined" == typeof Float64Array ? Array : Float64Array, dN = dC.extend({
            type: "series.lines",
            dependencies: ["grid", "polar"],
            visualColorAccessPath: "lineStyle.color",
            init: function (t) {
                t.data = t.data || [], Zg(t);
                var e = this._processFlatCoordsArray(t.data);
                this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count)), dN.superApply(this, "init", arguments)
            },
            mergeOption: function (t) {
                if (Zg(t), t.data) {
                    var e = this._processFlatCoordsArray(t.data);
                    this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count))
                }
                dN.superApply(this, "mergeOption", arguments)
            },
            appendData: function (t) {
                var e = this._processFlatCoordsArray(t.data);
                e.flatCoords && (this._flatCoords ? (this._flatCoords = V(this._flatCoords, e.flatCoords), this._flatCoordsOffset = V(this._flatCoordsOffset, e.flatCoordsOffset)) : (this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset), t.data = new Float32Array(e.count)), this.getRawData().appendData(t.data)
            },
            _getCoordsFromItemModel: function (t) {
                var e = this.getData().getItemModel(t), i = e.option instanceof Array ? e.option : e.getShallow("coords");
                if (BS && !(i instanceof Array && i.length > 0 && i[0] instanceof Array)) throw new Error("Invalid coords " + JSON.stringify(i) + ". Lines must have 2d coords array in data item.");
                return i
            },
            getLineCoordsCount: function (t) {
                return this._flatCoordsOffset ? this._flatCoordsOffset[2 * t + 1] : this._getCoordsFromItemModel(t).length
            },
            getLineCoords: function (t, e) {
                if (this._flatCoordsOffset) {
                    for (var i = this._flatCoordsOffset[2 * t], n = this._flatCoordsOffset[2 * t + 1], o = 0; n > o; o++) e[o] = e[o] || [], e[o][0] = this._flatCoords[i + 2 * o], e[o][1] = this._flatCoords[i + 2 * o + 1];
                    return n
                }
                for (var a = this._getCoordsFromItemModel(t), o = 0; o < a.length; o++) e[o] = e[o] || [], e[o][0] = a[o][0], e[o][1] = a[o][1];
                return a.length
            },
            _processFlatCoordsArray: function (t) {
                var e = 0;
                if (this._flatCoords && (e = this._flatCoords.length), "number" == typeof t[0]) {
                    for (var i = t.length, n = new hN(i), o = new cN(i), a = 0, r = 0, s = 0, l = 0; i > l;) {
                        s++;
                        var u = t[l++];
                        n[r++] = a + e, n[r++] = u;
                        for (var h = 0; u > h; h++) {
                            var c = t[l++], d = t[l++];
                            if (o[a++] = c, o[a++] = d, l > i && BS) throw new Error("Invalid data format.")
                        }
                    }
                    return {flatCoordsOffset: new Uint32Array(n.buffer, 0, r), flatCoords: o, count: s}
                }
                return {flatCoordsOffset: null, flatCoords: null, count: t.length}
            },
            getInitialData: function (t) {
                if (BS) {
                    var e = Ps.get(t.coordinateSystem);
                    if (!e) throw new Error("Unkown coordinate system " + t.coordinateSystem)
                }
                var i = new qL(["value"], this);
                return i.hasItemOption = !1, i.initData(t.data, [], function (t, e, n, o) {
                    if (t instanceof Array) return 0 / 0;
                    i.hasItemOption = !0;
                    var a = t.value;
                    return null != a ? a instanceof Array ? a[o] : a : void 0
                }), i
            },
            formatTooltip: function (t) {
                var e = this.getData(), i = e.getItemModel(t), n = i.get("name");
                if (n) return n;
                var o = i.get("fromName"), a = i.get("toName"), r = [];
                return null != o && r.push(o), null != a && r.push(a), Hr(r.join(" > "))
            },
            preventIncremental: function () {
                return !!this.get("effect.show")
            },
            getProgressive: function () {
                var t = this.option.progressive;
                return null == t ? this.option.large ? 1e4 : this.get("progressive") : t
            },
            getProgressiveThreshold: function () {
                var t = this.option.progressiveThreshold;
                return null == t ? this.option.large ? 2e4 : this.get("progressiveThreshold") : t
            },
            defaultOption: {
                coordinateSystem: "geo",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                symbol: ["none", "none"],
                symbolSize: [10, 10],
                geoIndex: 0,
                effect: {show: !1, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: !0, trailLength: .2},
                large: !1,
                largeThreshold: 2e3,
                polyline: !1,
                clip: !0,
                label: {show: !1, position: "end"},
                lineStyle: {opacity: .5}
            }
        }), fN = kA.prototype, pN = OA.prototype, gN = xa({
            type: "ec-line",
            style: {stroke: "#000", fill: null},
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null},
            buildPath: function (t, e) {
                this[Ug(e) ? "_buildPathLine" : "_buildPathCurve"](t, e)
            },
            _buildPathLine: fN.buildPath,
            _buildPathCurve: pN.buildPath,
            pointAt: function (t) {
                return this[Ug(this.shape) ? "_pointAtLine" : "_pointAtCurve"](t)
            },
            _pointAtLine: fN.pointAt,
            _pointAtCurve: pN.pointAt,
            tangentAt: function (t) {
                var e = this.shape, i = Ug(e) ? [e.x2 - e.x1, e.y2 - e.y1] : this._tangentAtCurve(t);
                return te(i, i)
            },
            _tangentAtCurve: pN.tangentAt
        }), mN = ["fromSymbol", "toSymbol"], vN = $g.prototype;
    vN.beforeUpdate = Kg, vN._createLine = function (t, e, i) {
        var n = t.hostModel, o = t.getItemLayout(e), a = jg(o);
        a.shape.percent = 0, ar(a, {shape: {percent: 1}}, n, e), this.add(a);
        var r = new vA({name: "label", lineLabelOriginalOpacity: 1});
        this.add(r), f(mN, function (i) {
            var n = Yg(i, t, e);
            this.add(n), this[Xg(i)] = t.getItemVisual(e, i)
        }, this), this._updateCommonStl(t, e, i)
    }, vN.updateData = function (t, e, i) {
        var n = t.hostModel, o = this.childOfName("line"), a = t.getItemLayout(e), r = {shape: {}};
        qg(r.shape, a), or(o, r, n, e), f(mN, function (i) {
            var n = t.getItemVisual(e, i), o = Xg(i);
            if (this[o] !== n) {
                this.remove(this.childOfName(i));
                var a = Yg(i, t, e);
                this.add(a)
            }
            this[o] = n
        }, this), this._updateCommonStl(t, e, i)
    }, vN._updateCommonStl = function (t, e, i) {
        var n = t.hostModel, o = this.childOfName("line"), a = i && i.lineStyle, r = i && i.hoverLineStyle,
            l = i && i.labelModel, u = i && i.hoverLabelModel;
        if (!i || t.hasItemOption) {
            var h = t.getItemModel(e);
            a = h.getModel("lineStyle").getLineStyle(), r = h.getModel("emphasis.lineStyle").getLineStyle(), l = h.getModel("label"), u = h.getModel("emphasis.label")
        }
        var c = t.getItemVisual(e, "color"), d = L(t.getItemVisual(e, "opacity"), a.opacity, 1);
        o.useStyle(s({
            strokeNoScale: !0,
            fill: "none",
            stroke: c,
            opacity: d
        }, a)), o.hoverStyle = r, f(mN, function (t) {
            var e = this.childOfName(t);
            e && (e.setColor(c), e.setStyle({opacity: d}))
        }, this);
        var p, g, m = l.getShallow("show"), v = u.getShallow("show"), y = this.childOfName("label");
        if ((m || v) && (p = c || "#000", g = n.getFormattedLabel(e, "normal", t.dataType), null == g)) {
            var x = n.getRawValue(e);
            g = null == x ? t.getName(e) : isFinite(x) ? Tr(x) : x
        }
        var w = m ? g : null, b = v ? C(n.getFormattedLabel(e, "emphasis", t.dataType), g) : null, S = y.style;
        if (null != w || null != b) {
            ja(y.style, l, {text: w}, {autoColor: p}), y.__textAlign = S.textAlign, y.__verticalAlign = S.textVerticalAlign, y.__position = l.get("position") || "middle";
            var M = l.get("distance");
            _(M) || (M = [M, M]), y.__labelDistance = M
        }
        y.hoverStyle = null != b ? {
            text: b,
            textFill: u.getTextColor(!0),
            fontStyle: u.getShallow("fontStyle"),
            fontWeight: u.getShallow("fontWeight"),
            fontSize: u.getShallow("fontSize"),
            fontFamily: u.getShallow("fontFamily")
        } : {text: null}, y.ignore = !m && !v, Wa(this)
    }, vN.highlight = function () {
        this.trigger("emphasis")
    }, vN.downplay = function () {
        this.trigger("normal")
    }, vN.updateLayout = function (t, e) {
        this.setLinePoints(t.getItemLayout(e))
    }, vN.setLinePoints = function (t) {
        var e = this.childOfName("line");
        qg(e.shape, t), e.dirty()
    }, h($g, iI);
    var yN = Jg.prototype;
    yN.isPersistent = function () {
        return !0
    }, yN.updateData = function (t) {
        var e = this, i = e.group, n = e._lineData;
        e._lineData = t, n || i.removeAll();
        var o = im(t);
        t.diff(n).add(function (i) {
            Qg(e, t, i, o)
        }).update(function (i, a) {
            tm(e, n, t, a, i, o)
        }).remove(function (t) {
            i.remove(n.getItemGraphicEl(t))
        }).execute()
    }, yN.updateLayout = function () {
        var t = this._lineData;
        t && t.eachItemGraphicEl(function (e, i) {
            e.updateLayout(t, i)
        }, this)
    }, yN.incrementalPrepareUpdate = function (t) {
        this._seriesScope = im(t), this._lineData = null, this.group.removeAll()
    }, yN.incrementalUpdate = function (t, e) {
        function i(t) {
            t.isGroup || em(t) || (t.incremental = t.useHoverLayer = !0)
        }

        for (var n = t.start; n < t.end; n++) {
            var o = e.getItemLayout(n);
            if (om(o)) {
                var a = new this._ctor(e, n, this._seriesScope);
                a.traverse(i), this.group.add(a), e.setItemGraphicEl(n, a)
            }
        }
    }, yN.remove = function () {
        this._clearIncremental(), this._incremental = null, this.group.removeAll()
    }, yN._clearIncremental = function () {
        var t = this._incremental;
        t && t.clearDisplaybles()
    };
    var xN = am.prototype;
    xN.createLine = function (t, e, i) {
        return new $g(t, e, i)
    }, xN._updateEffectSymbol = function (t, e) {
        var i = t.getItemModel(e), n = i.getModel("effect"), o = n.get("symbolSize"), a = n.get("symbol");
        _(o) || (o = [o, o]);
        var r = n.get("color") || t.getItemVisual(e, "color"), s = this.childAt(1);
        this._symbolType !== a && (this.remove(s), s = ac(a, -.5, -.5, 1, 1, r), s.z2 = 100, s.culling = !0, this.add(s)), s && (s.setStyle("shadowColor", r), s.setStyle(n.getItemStyle(["color"])), s.attr("scale", o), s.setColor(r), s.attr("scale", o), this._symbolType = a, this._symbolScale = o, this._updateEffectAnimation(t, n, e))
    }, xN._updateEffectAnimation = function (t, e, i) {
        var n = this.childAt(1);
        if (n) {
            var o = this, a = t.getItemLayout(i), r = 1e3 * e.get("period"), s = e.get("loop"),
                l = e.get("constantSpeed"), u = D(e.get("delay"), function (e) {
                    return e / t.count() * r / 3
                }), h = "function" == typeof u;
            if (n.ignore = !0, this.updateAnimationPoints(n, a), l > 0 && (r = this.getLineLength(n) / l * 1e3), r !== this._period || s !== this._loop) {
                n.stopAnimation();
                var c = u;
                h && (c = u(i)), n.__t > 0 && (c = -r * n.__t), n.__t = 0;
                var d = n.animate("", s).when(r, {__t: 1}).delay(c).during(function () {
                    o.updateSymbolPosition(n)
                });
                s || d.done(function () {
                    o.remove(n)
                }), d.start()
            }
            this._period = r, this._loop = s
        }
    }, xN.getLineLength = function (t) {
        return rM(t.__p1, t.__cp1) + rM(t.__cp1, t.__p2)
    }, xN.updateAnimationPoints = function (t, e) {
        t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]
    }, xN.updateData = function (t, e, i) {
        this.childAt(0).updateData(t, e, i), this._updateEffectSymbol(t, e)
    }, xN.updateSymbolPosition = function (t) {
        var e = t.__p1, i = t.__p2, n = t.__cp1, o = t.__t, a = t.position, r = [a[0], a[1]], s = Eo, l = No;
        a[0] = s(e[0], n[0], i[0], o), a[1] = s(e[1], n[1], i[1], o);
        var u = l(e[0], n[0], i[0], o), h = l(e[1], n[1], i[1], o);
        if (t.rotation = -Math.atan2(h, u) - Math.PI / 2, "line" === this._symbolType || "rect" === this._symbolType || "roundRect" === this._symbolType) if (void 0 !== t.__lastT && t.__lastT < t.__t) {
            var c = 1.05 * rM(r, a);
            t.attr("scale", [t.scale[0], c]), 1 === o && (a[0] = r[0] + (a[0] - r[0]) / 2, a[1] = r[1] + (a[1] - r[1]) / 2)
        } else if (1 === t.__lastT) {
            var c = 2 * rM(e, a);
            t.attr("scale", [t.scale[0], c])
        } else t.attr("scale", this._symbolScale);
        t.__lastT = t.__t, t.ignore = !1
    }, xN.updateLayout = function (t, e) {
        this.childAt(0).updateLayout(t, e);
        var i = t.getItemModel(e).getModel("effect");
        this._updateEffectAnimation(t, i, e)
    }, h(am, iI);
    var _N = rm.prototype;
    _N._createPolyline = function (t, e, i) {
        var n = t.getItemLayout(e), o = new TA({shape: {points: n}});
        this.add(o), this._updateCommonStl(t, e, i)
    }, _N.updateData = function (t, e, i) {
        var n = t.hostModel, o = this.childAt(0), a = {shape: {points: t.getItemLayout(e)}};
        or(o, a, n, e), this._updateCommonStl(t, e, i)
    }, _N._updateCommonStl = function (t, e, i) {
        var n = this.childAt(0), o = t.getItemModel(e), a = t.getItemVisual(e, "color"), r = i && i.lineStyle,
            l = i && i.hoverLineStyle;
        (!i || t.hasItemOption) && (r = o.getModel("lineStyle").getLineStyle(), l = o.getModel("emphasis.lineStyle").getLineStyle()), n.useStyle(s({
            strokeNoScale: !0,
            fill: "none",
            stroke: a
        }, r)), n.hoverStyle = l, Wa(this)
    }, _N.updateLayout = function (t, e) {
        var i = this.childAt(0);
        i.setShape("points", t.getItemLayout(e))
    }, h(rm, iI);
    var wN = sm.prototype;
    wN.createLine = function (t, e, i) {
        return new rm(t, e, i)
    }, wN.updateAnimationPoints = function (t, e) {
        this._points = e;
        for (var i = [0], n = 0, o = 1; o < e.length; o++) {
            var a = e[o - 1], r = e[o];
            n += rM(a, r), i.push(n)
        }
        if (0 !== n) {
            for (var o = 0; o < i.length; o++) i[o] /= n;
            this._offsets = i, this._length = n
        }
    }, wN.getLineLength = function () {
        return this._length
    }, wN.updateSymbolPosition = function (t) {
        var e = t.__t, i = this._points, n = this._offsets, o = i.length;
        if (n) {
            var a, r = this._lastFrame;
            if (e < this._lastFramePercent) {
                var s = Math.min(r + 1, o - 1);
                for (a = s; a >= 0 && !(n[a] <= e); a--) ;
                a = Math.min(a, o - 2)
            } else {
                for (var a = r; o > a && !(n[a] > e); a++) ;
                a = Math.min(a - 1, o - 2)
            }
            oe(t.position, i[a], i[a + 1], (e - n[a]) / (n[a + 1] - n[a]));
            var l = i[a + 1][0] - i[a][0], u = i[a + 1][1] - i[a][1];
            t.rotation = -Math.atan2(u, l) - Math.PI / 2, this._lastFrame = a, this._lastFramePercent = e, t.ignore = !1
        }
    }, h(sm, am);
    var bN = xa({
        shape: {polyline: !1, curveness: 0, segs: []}, buildPath: function (t, e) {
            var i = e.segs, n = e.curveness;
            if (e.polyline) for (var o = 0; o < i.length;) {
                var a = i[o++];
                if (a > 0) {
                    t.moveTo(i[o++], i[o++]);
                    for (var r = 1; a > r; r++) t.lineTo(i[o++], i[o++])
                }
            } else for (var o = 0; o < i.length;) {
                var s = i[o++], l = i[o++], u = i[o++], h = i[o++];
                if (t.moveTo(s, l), n > 0) {
                    var c = (s + u) / 2 - (l - h) * n, d = (l + h) / 2 - (u - s) * n;
                    t.quadraticCurveTo(c, d, u, h)
                } else t.lineTo(u, h)
            }
        }, findDataIndex: function () {
            var t = this.shape, e = t.segs, i = t.curveness;
            if (t.polyline) for (var n = 0, o = 0; o < e.length;) {
                var a = e[o++];
                if (a > 0) for (var r = e[o++], s = e[o++], l = 1; a > l; l++) {
                    var u = e[o++], h = e[o++];
                    if (Uo(r, s, u, h)) return n
                }
                n++
            } else for (var n = 0, o = 0; o < e.length;) {
                var r = e[o++], s = e[o++], u = e[o++], h = e[o++];
                if (i > 0) {
                    var c = (r + u) / 2 - (s - h) * i, d = (s + h) / 2 - (u - r) * i;
                    if (Yo(r, s, c, d, u, h)) return n
                } else if (Uo(r, s, u, h)) return n;
                n++
            }
            return -1
        }
    }), SN = lm.prototype;
    SN.isPersistent = function () {
        return !this._incremental
    }, SN.updateData = function (t) {
        this.group.removeAll();
        var e = new bN({rectHover: !0, cursor: "default"});
        e.setShape({segs: t.getLayout("linesPoints")}), this._setCommon(e, t), this.group.add(e), this._incremental = null
    }, SN.incrementalPrepareUpdate = function (t) {
        this.group.removeAll(), this._clearIncremental(), t.count() > 5e5 ? (this._incremental || (this._incremental = new ya({silent: !0})), this.group.add(this._incremental)) : this._incremental = null
    }, SN.incrementalUpdate = function (t, e) {
        var i = new bN;
        i.setShape({segs: e.getLayout("linesPoints")}), this._setCommon(i, e, !!this._incremental), this._incremental ? this._incremental.addDisplayable(i, !0) : (i.rectHover = !0, i.cursor = "default", i.__startIndex = t.start, this.group.add(i))
    }, SN.remove = function () {
        this._clearIncremental(), this._incremental = null, this.group.removeAll()
    }, SN._setCommon = function (t, e, i) {
        var n = e.hostModel;
        t.setShape({
            polyline: n.get("polyline"),
            curveness: n.get("lineStyle.curveness")
        }), t.useStyle(n.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = !0;
        var o = e.getVisual("color");
        o && t.setStyle("stroke", o), t.setStyle("fill"), i || (t.seriesIndex = n.seriesIndex, t.on("mousemove", function (e) {
            t.dataIndex = null;
            var i = t.findDataIndex(e.offsetX, e.offsetY);
            i > 0 && (t.dataIndex = i + t.__startIndex)
        }))
    }, SN._clearIncremental = function () {
        var t = this._incremental;
        t && t.clearDisplaybles()
    };
    var MN = {
        seriesType: "lines", plan: gC(), reset: function (t) {
            function e(e, a) {
                var r = [];
                if (o) {
                    var s, l = e.end - e.start;
                    if (n) {
                        for (var u = 0, h = e.start; h < e.end; h++) u += t.getLineCoordsCount(h);
                        s = new Float32Array(l + 2 * u)
                    } else s = new Float32Array(4 * l);
                    for (var c = 0, d = [], h = e.start; h < e.end; h++) {
                        var f = t.getLineCoords(h, r);
                        n && (s[c++] = f);
                        for (var p = 0; f > p; p++) d = i.dataToPoint(r[p], !1, d), s[c++] = d[0], s[c++] = d[1]
                    }
                    a.setLayout("linesPoints", s)
                } else for (var h = e.start; h < e.end; h++) {
                    var g = a.getItemModel(h), f = t.getLineCoords(h, r), m = [];
                    if (n) for (var v = 0; f > v; v++) m.push(i.dataToPoint(r[v])); else {
                        m[0] = i.dataToPoint(r[0]), m[1] = i.dataToPoint(r[1]);
                        var y = g.get("lineStyle.curveness");
                        +y && (m[2] = [(m[0][0] + m[1][0]) / 2 - (m[0][1] - m[1][1]) * y, (m[0][1] + m[1][1]) / 2 - (m[1][0] - m[0][0]) * y])
                    }
                    a.setItemLayout(h, m)
                }
            }

            var i = t.coordinateSystem, n = t.get("polyline"), o = t.pipelineContext.large;
            return {progress: e}
        }
    };
    Wu({
        type: "lines", init: function () {
        }, render: function (t, e, i) {
            var n = t.getData(), o = this._updateLineDraw(n, t), a = t.get("zlevel"), r = t.get("effect.trailLength"),
                s = i.getZr(), l = "svg" === s.painter.getType();
            if (l || s.painter.getLayer(a).clear(!0), null == this._lastZlevel || l || s.configLayer(this._lastZlevel, {motionBlur: !1}), this._showEffect(t) && r) {
                if (BS) {
                    var u = !1;
                    e.eachSeries(function (e) {
                        e !== t && e.get("zlevel") === a && (u = !0)
                    }), u && console.warn("Lines with trail effect should have an individual zlevel")
                }
                l || s.configLayer(a, {motionBlur: !0, lastFrameAlpha: Math.max(Math.min(r / 10 + .9, 1), 0)})
            }
            o.updateData(n);
            var h = t.get("clip", !0) && Uc(t.coordinateSystem, !1, t);
            h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = a, this._finished = !0
        }, incrementalPrepareRender: function (t, e, i) {
            var n = t.getData(), o = this._updateLineDraw(n, t);
            o.incrementalPrepareUpdate(n), this._clearLayer(i), this._finished = !1
        }, incrementalRender: function (t, e) {
            this._lineDraw.incrementalUpdate(t, e.getData()), this._finished = t.end === e.getData().count()
        }, updateTransform: function (t, e, i) {
            var n = t.getData(), o = t.pipelineContext;
            if (!this._finished || o.large || o.progressiveRender) return {update: !0};
            var a = MN.reset(t);
            a.progress && a.progress({start: 0, end: n.count()}, n), this._lineDraw.updateLayout(), this._clearLayer(i)
        }, _updateLineDraw: function (t, e) {
            var i = this._lineDraw, n = this._showEffect(e), o = !!e.get("polyline"), a = e.pipelineContext,
                r = a.large;
            return BS && n && r && console.warn("Large lines not support effect"), i && n === this._hasEffet && o === this._isPolyline && r === this._isLargeDraw || (i && i.remove(), i = this._lineDraw = r ? new lm : new Jg(o ? n ? sm : rm : n ? am : $g), this._hasEffet = n, this._isPolyline = o, this._isLargeDraw = r, this.group.removeAll()), this.group.add(i.group), i
        }, _showEffect: function (t) {
            return !!t.get("effect.show")
        }, _clearLayer: function (t) {
            var e = t.getZr(), i = "svg" === e.painter.getType();
            i || null == this._lastZlevel || e.painter.getLayer(this._lastZlevel).clear(!0)
        }, remove: function (t, e) {
            this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(e)
        }, dispose: function () {
        }
    });
    var IN = "lineStyle.opacity".split("."), TN = {
        seriesType: "lines", reset: function (t) {
            function e(t, e) {
                var i = t.getItemModel(e), n = um(i.getShallow("symbol", !0)), o = um(i.getShallow("symbolSize", !0)),
                    a = i.get(IN);
                n[0] && t.setItemVisual(e, "fromSymbol", n[0]), n[1] && t.setItemVisual(e, "toSymbol", n[1]), o[0] && t.setItemVisual(e, "fromSymbolSize", o[0]), o[1] && t.setItemVisual(e, "toSymbolSize", o[1]), t.setItemVisual(e, "opacity", a)
            }

            var i = um(t.get("symbol")), n = um(t.get("symbolSize")), o = t.getData();
            return o.setVisual("fromSymbol", i && i[0]), o.setVisual("toSymbol", i && i[1]), o.setVisual("fromSymbolSize", n && n[0]), o.setVisual("toSymbolSize", n && n[1]), o.setVisual("opacity", t.get(IN)), {dataEach: o.hasItemOption ? e : null}
        }
    };
    Nu(MN), Ru(TN);
    var AN = function (t) {
        this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData
    }, DN = AN.prototype;
    DN.type = "graph", DN.isDirected = function () {
        return this._directed
    }, DN.addNode = function (t, e) {
        t = null == t ? "" + e : "" + t;
        var i = this._nodesMap;
        if (i[hm(t)]) return void (BS && console.error("Graph nodes have duplicate name or id"));
        var n = new cm(t, e);
        return n.hostGraph = this, this.nodes.push(n), i[hm(t)] = n, n
    }, DN.getNodeByIndex = function (t) {
        var e = this.data.getRawIndex(t);
        return this.nodes[e]
    }, DN.getNodeById = function (t) {
        return this._nodesMap[hm(t)]
    }, DN.addEdge = function (t, e, i) {
        var n = this._nodesMap, o = this._edgesMap;
        if ("number" == typeof t && (t = this.nodes[t]), "number" == typeof e && (e = this.nodes[e]), cm.isInstance(t) || (t = n[hm(t)]), cm.isInstance(e) || (e = n[hm(e)]), t && e) {
            var a = t.id + "-" + e.id, r = new dm(t, e, i);
            return r.hostGraph = this, this._directed && (t.outEdges.push(r), e.inEdges.push(r)), t.edges.push(r), t !== e && e.edges.push(r), this.edges.push(r), o[a] = r, r
        }
    }, DN.getEdgeByIndex = function (t) {
        var e = this.edgeData.getRawIndex(t);
        return this.edges[e]
    }, DN.getEdge = function (t, e) {
        cm.isInstance(t) && (t = t.id), cm.isInstance(e) && (e = e.id);
        var i = this._edgesMap;
        return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t]
    }, DN.eachNode = function (t, e) {
        for (var i = this.nodes, n = i.length, o = 0; n > o; o++) i[o].dataIndex >= 0 && t.call(e, i[o], o)
    }, DN.eachEdge = function (t, e) {
        for (var i = this.edges, n = i.length, o = 0; n > o; o++) i[o].dataIndex >= 0 && i[o].node1.dataIndex >= 0 && i[o].node2.dataIndex >= 0 && t.call(e, i[o], o)
    }, DN.breadthFirstTraverse = function (t, e, i, n) {
        if (cm.isInstance(e) || (e = this._nodesMap[hm(e)]), e) {
            for (var o = "out" === i ? "outEdges" : "in" === i ? "inEdges" : "edges", a = 0; a < this.nodes.length; a++) this.nodes[a].__visited = !1;
            if (!t.call(n, e, null)) for (var r = [e]; r.length;) for (var s = r.shift(), l = s[o], a = 0; a < l.length; a++) {
                var u = l[a], h = u.node1 === s ? u.node2 : u.node1;
                if (!h.__visited) {
                    if (t.call(n, h, s)) return;
                    r.push(h), h.__visited = !0
                }
            }
        }
    }, DN.update = function () {
        for (var t = this.data, e = this.edgeData, i = this.nodes, n = this.edges, o = 0, a = i.length; a > o; o++) i[o].dataIndex = -1;
        for (var o = 0, a = t.count(); a > o; o++) i[t.getRawIndex(o)].dataIndex = o;
        e.filterSelf(function (t) {
            var i = n[e.getRawIndex(t)];
            return i.node1.dataIndex >= 0 && i.node2.dataIndex >= 0
        });
        for (var o = 0, a = n.length; a > o; o++) n[o].dataIndex = -1;
        for (var o = 0, a = e.count(); a > o; o++) n[e.getRawIndex(o)].dataIndex = o
    }, DN.clone = function () {
        for (var t = new AN(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++) t.addNode(e[n].id, e[n].dataIndex);
        for (var n = 0; n < i.length; n++) {
            var o = i[n];
            t.addEdge(o.node1.id, o.node2.id, o.dataIndex)
        }
        return t
    }, cm.prototype = {
        constructor: cm, degree: function () {
            return this.edges.length
        }, inDegree: function () {
            return this.inEdges.length
        }, outDegree: function () {
            return this.outEdges.length
        }, getModel: function (t) {
            if (!(this.dataIndex < 0)) {
                var e = this.hostGraph, i = e.data.getItemModel(this.dataIndex);
                return i.getModel(t)
            }
        }
    }, dm.prototype.getModel = function (t) {
        if (!(this.dataIndex < 0)) {
            var e = this.hostGraph, i = e.edgeData.getItemModel(this.dataIndex);
            return i.getModel(t)
        }
    };
    var CN = function (t, e) {
        return {
            getValue: function (i) {
                var n = this[t][e];
                return n.get(n.getDimension(i || "value"), this.dataIndex)
            }, setVisual: function (i, n) {
                this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, i, n)
            }, getVisual: function (i, n) {
                return this[t][e].getItemVisual(this.dataIndex, i, n)
            }, setLayout: function (i, n) {
                this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, i, n)
            }, getLayout: function () {
                return this[t][e].getItemLayout(this.dataIndex)
            }, getGraphicEl: function () {
                return this[t][e].getItemGraphicEl(this.dataIndex)
            }, getRawIndex: function () {
                return this[t][e].getRawIndex(this.dataIndex)
            }
        }
    };
    c(cm, CN("hostGraph", "data")), c(dm, CN("hostGraph", "edgeData")), AN.Node = cm, AN.Edge = dm, bo(cm), bo(dm);
    var LN = function (t, e, i, n, o) {
            for (var a = new AN(n), r = 0; r < t.length; r++) a.addNode(D(t[r].id, t[r].name, r), r);
            for (var s = [], l = [], h = 0, r = 0; r < e.length; r++) {
                var c = e[r], d = c.source, f = c.target;
                a.addEdge(d, f, h) && (l.push(c), s.push(D(c.id, d + " > " + f)), h++)
            }
            var p, g = i.get("coordinateSystem");
            if ("cartesian2d" === g || "polar" === g) p = Sh(t, i); else {
                var m = Ps.get(g), v = m && "view" !== m.type ? m.dimensions || [] : [];
                u(v, "value") < 0 && v.concat(["value"]);
                var y = JL(t, {coordDimensions: v});
                p = new qL(y, i), p.initData(t)
            }
            var x = new qL(["value"], i);
            return x.initData(l, s), o && o(p, x), Pf({
                mainData: p,
                struct: a,
                structAttr: "graph",
                datas: {node: p, edge: x},
                datasAttr: {node: "data", edge: "edgeData"}
            }), a.update(), a
        }, kN = "-->", PN = function (t) {
            return t.get("autoCurveness") || null
        }, ON = function (t, e) {
            var i = PN(t), n = 20, o = [];
            if ("number" == typeof i) n = i; else if (_(i)) return void (t.__curvenessList = i);
            e > n && (n = e);
            var a = n % 2 ? n + 2 : n + 3;
            o = [];
            for (var r = 0; a > r; r++) o.push((r % 2 ? r + 1 : r) / 10 * (r % 2 ? -1 : 1));
            t.__curvenessList = o
        }, EN = function (t, e, i) {
            var n = [t.id, t.dataIndex].join("."), o = [e.id, e.dataIndex].join(".");
            return [i.uid, n, o].join(kN)
        }, NN = function (t) {
            var e = t.split(kN);
            return [e[0], e[2], e[1]].join(kN)
        }, RN = function (t, e) {
            var i = EN(t.node1, t.node2, e);
            return e.__edgeMap[i]
        }, zN = function (t, e) {
            var i = BN(EN(t.node1, t.node2, e), e), n = BN(EN(t.node2, t.node1, e), e);
            return i + n
        }, BN = function (t, e) {
            var i = e.__edgeMap;
            return i[t] ? i[t].length : 0
        }, VN = Fu({
            type: "series.graph",
            init: function (t) {
                function e() {
                    return i._categoriesData
                }

                VN.superApply(this, "init", arguments);
                var i = this;
                this.legendVisualProvider = new ef(e, e), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
            },
            mergeOption: function (t) {
                VN.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
            },
            mergeDefaultAndTheme: function (t) {
                VN.superApply(this, "mergeDefaultAndTheme", arguments), io(t, ["edgeLabel"], ["show"])
            },
            getInitialData: function (t, e) {
                function i(t, i) {
                    function n(t) {
                        return t = this.parsePath(t), t && "label" === t[0] ? r : t && "emphasis" === t[0] && "label" === t[1] ? l : this.parentModel
                    }

                    t.wrapMethod("getItemModel", function (t) {
                        var e = a._categoriesModels, i = t.getShallow("category"), n = e[i];
                        return n && (n.parentModel = t.parentModel, t.parentModel = n), t
                    });
                    var o = a.getModel("edgeLabel"), r = new vr({label: o.option}, o.parentModel, e),
                        s = a.getModel("emphasis.edgeLabel"), l = new vr({emphasis: {label: s.option}}, s.parentModel, e);
                    i.wrapMethod("getItemModel", function (t) {
                        return t.customizeGetParent(n), t
                    })
                }

                var n = t.edges || t.links || [], o = t.data || t.nodes || [], a = this;
                if (o && n) {
                    fm(this);
                    var r = LN(o, n, this, !0, i);
                    return f(r.edges, function (t) {
                        pm(t.node1, t.node2, this, t.dataIndex)
                    }, this), r.data
                }
            },
            getGraph: function () {
                return this.getData().graph
            },
            getEdgeData: function () {
                return this.getGraph().edgeData
            },
            getCategoriesData: function () {
                return this._categoriesData
            },
            formatTooltip: function (t, e, i) {
                if ("edge" === i) {
                    var n = this.getData(), o = this.getDataParams(t, i), a = n.graph.getEdgeByIndex(t),
                        r = n.getName(a.node1.dataIndex), s = n.getName(a.node2.dataIndex), l = [];
                    return null != r && l.push(r), null != s && l.push(s), l = Hr(l.join(" > ")), o.value && (l += " : " + Hr(o.value)), l
                }
                return VN.superApply(this, "formatTooltip", arguments)
            },
            _updateCategoriesData: function () {
                var t = p(this.option.categories || [], function (t) {
                    return null != t.value ? t : r({value: 0}, t)
                }), e = new qL(["value"], this);
                e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function (t) {
                    return e.getItemModel(t, !0)
                })
            },
            setZoom: function (t) {
                this.option.zoom = t
            },
            setCenter: function (t) {
                this.option.center = t
            },
            isAnimationEnabled: function () {
                return VN.superCall(this, "isAnimationEnabled") && !("force" === this.get("layout") && this.get("force.layoutAnimation"))
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                focusNodeAdjacency: !1,
                circular: {rotateLabel: !1},
                force: {
                    initLayout: null,
                    repulsion: [0, 50],
                    gravity: .1,
                    friction: .6,
                    edgeLength: 30,
                    layoutAnimation: !0
                },
                left: "center",
                top: "center",
                symbol: "circle",
                symbolSize: 10,
                edgeSymbol: ["none", "none"],
                edgeSymbolSize: 10,
                edgeLabel: {position: "middle", distance: 5},
                draggable: !1,
                roam: !1,
                center: null,
                zoom: 1,
                nodeScaleRatio: .6,
                label: {show: !1, formatter: "{b}"},
                itemStyle: {},
                lineStyle: {color: "#aaa", width: 1, opacity: .5},
                emphasis: {label: {show: !0}}
            }
        }), GN = [], FN = [], WN = [], HN = Eo, ZN = sM, UN = Math.abs, XN = function (t, e) {
            var i = [], n = Bo, o = [[], [], []], a = [[], []], r = [];
            e /= 2, t.eachEdge(function (t) {
                var s = t.getLayout(), l = t.getVisual("fromSymbol"), u = t.getVisual("toSymbol");
                s.__original || (s.__original = [H(s[0]), H(s[1])], s[2] && s.__original.push(H(s[2])));
                var h = s.__original;
                if (null != s[2]) {
                    if (W(o[0], h[0]), W(o[1], h[2]), W(o[2], h[1]), l && "none" !== l) {
                        var c = vm(t.node1), d = ym(o, h[0], c * e);
                        n(o[0][0], o[1][0], o[2][0], d, i), o[0][0] = i[3], o[1][0] = i[4], n(o[0][1], o[1][1], o[2][1], d, i), o[0][1] = i[3], o[1][1] = i[4]
                    }
                    if (u && "none" !== u) {
                        var c = vm(t.node2), d = ym(o, h[1], c * e);
                        n(o[0][0], o[1][0], o[2][0], d, i), o[1][0] = i[1], o[2][0] = i[2], n(o[0][1], o[1][1], o[2][1], d, i), o[1][1] = i[1], o[2][1] = i[2]
                    }
                    W(s[0], o[0]), W(s[1], o[2]), W(s[2], o[1])
                } else {
                    if (W(a[0], h[0]), W(a[1], h[1]), Y(r, a[1], a[0]), te(r, r), l && "none" !== l) {
                        var c = vm(t.node1);
                        X(a[0], a[0], r, c * e)
                    }
                    if (u && "none" !== u) {
                        var c = vm(t.node2);
                        X(a[1], a[1], r, -c * e)
                    }
                    W(s[0], a[0]), W(s[1], a[1])
                }
            })
        }, YN = "__focusNodeAdjacency", jN = "__unfocusNodeAdjacency", qN = ["itemStyle", "opacity"],
        KN = ["lineStyle", "opacity"];
    Wu({
        type: "graph", init: function (t, e) {
            var i = new Od, n = new Jg, o = this.group;
            this._controller = new hp(e.getZr()), this._controllerHost = {target: o}, o.add(i.group), o.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0
        }, render: function (t, e, i) {
            var n = this, o = t.coordinateSystem;
            this._model = t;
            var a = this._symbolDraw, r = this._lineDraw, s = this.group;
            if ("view" === o.type) {
                var l = {position: o.position, scale: o.scale};
                this._firstRender ? s.attr(l) : or(s, l, t)
            }
            XN(t.getGraph(), mm(t));
            var u = t.getData();
            a.updateData(u);
            var h = t.getEdgeData();
            r.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, e, i), clearTimeout(this._layoutTimeout);
            var c = t.forceLayout, d = t.get("force.layoutAnimation");
            c && this._startForceLayoutIteration(c, d), u.eachItemGraphicEl(function (e, o) {
                var a = u.getItemModel(o);
                e.off("drag").off("dragend");
                var r = a.get("draggable");
                r && e.on("drag", function () {
                    c && (c.warmUp(), !this._layouting && this._startForceLayoutIteration(c, d), c.setFixed(o), u.setItemLayout(o, e.position))
                }, this).on("dragend", function () {
                    c && c.setUnfixed(o)
                }, this), e.setDraggable(r && c), e[YN] && e.off("mouseover", e[YN]), e[jN] && e.off("mouseout", e[jN]), a.get("focusNodeAdjacency") && (e.on("mouseover", e[YN] = function () {
                    n._clearTimer(), i.dispatchAction({
                        type: "focusNodeAdjacency",
                        seriesId: t.id,
                        dataIndex: e.dataIndex
                    })
                }), e.on("mouseout", e[jN] = function () {
                    n._dispatchUnfocus(i)
                }))
            }, this), u.graph.eachEdge(function (e) {
                var o = e.getGraphicEl();
                o[YN] && o.off("mouseover", o[YN]), o[jN] && o.off("mouseout", o[jN]), e.getModel().get("focusNodeAdjacency") && (o.on("mouseover", o[YN] = function () {
                    n._clearTimer(), i.dispatchAction({
                        type: "focusNodeAdjacency",
                        seriesId: t.id,
                        edgeDataIndex: e.dataIndex
                    })
                }), o.on("mouseout", o[jN] = function () {
                    n._dispatchUnfocus(i)
                }))
            });
            var f = "circular" === t.get("layout") && t.get("circular.rotateLabel"), p = u.getLayout("cx"),
                g = u.getLayout("cy");
            u.eachItemGraphicEl(function (t, e) {
                var i = u.getItemModel(e), n = i.get("label.rotate") || 0, o = t.getSymbolPath();
                if (f) {
                    var a = u.getItemLayout(e), r = Math.atan2(a[1] - g, a[0] - p);
                    0 > r && (r = 2 * Math.PI + r);
                    var s = a[0] < p;
                    s && (r -= Math.PI);
                    var l = s ? "left" : "right";
                    Ya(o, {textRotation: -r, textPosition: l, textOrigin: "center"}, {textPosition: l})
                } else Ya(o, {textRotation: n *= Math.PI / 180})
            }), this._firstRender = !1
        }, dispose: function () {
            this._controller && this._controller.dispose(), this._controllerHost = {}, this._clearTimer()
        }, _dispatchUnfocus: function (t) {
            var e = this;
            this._clearTimer(), this._unfocusDelayTimer = setTimeout(function () {
                e._unfocusDelayTimer = null, t.dispatchAction({type: "unfocusNodeAdjacency", seriesId: e._model.id})
            }, 500)
        }, _clearTimer: function () {
            this._unfocusDelayTimer && (clearTimeout(this._unfocusDelayTimer), this._unfocusDelayTimer = null)
        }, focusNodeAdjacency: function (t, e, i, n) {
            var o = t.getData(), a = o.graph, r = n.dataIndex, s = n.edgeDataIndex, l = a.getNodeByIndex(r),
                u = a.getEdgeByIndex(s);
            (l || u) && (a.eachNode(function (t) {
                _m(t, qN, .1)
            }), a.eachEdge(function (t) {
                _m(t, KN, .1)
            }), l && (wm(l, qN), f(l.edges, function (t) {
                t.dataIndex < 0 || (wm(t, KN), wm(t.node1, qN), wm(t.node2, qN))
            })), u && (wm(u, KN), wm(u.node1, qN), wm(u.node2, qN)))
        }, unfocusNodeAdjacency: function (t) {
            var e = t.getData().graph;
            e.eachNode(function (t) {
                _m(t, qN)
            }), e.eachEdge(function (t) {
                _m(t, KN)
            })
        }, _startForceLayoutIteration: function (t, e) {
            var i = this;
            !function n() {
                t.step(function (t) {
                    i.updateLayout(i._model), (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n())
                })
            }()
        }, _updateController: function (t, e, i) {
            var n = this._controller, o = this._controllerHost, a = this.group;
            return n.setPointerChecker(function (e, n, o) {
                var r = a.getBoundingRect();
                return r.applyTransform(a.transform), r.contain(n, o) && !xp(e, i, t)
            }), "view" !== t.coordinateSystem.type ? void n.disable() : (n.enable(t.get("roam")), o.zoomLimit = t.get("scaleLimit"), o.zoom = t.coordinateSystem.getZoom(), void n.off("pan").off("zoom").on("pan", function (e) {
                op(o, e.dx, e.dy), i.dispatchAction({seriesId: t.id, type: "graphRoam", dx: e.dx, dy: e.dy})
            }).on("zoom", function (e) {
                ap(o, e.scale, e.originX, e.originY), i.dispatchAction({
                    seriesId: t.id,
                    type: "graphRoam",
                    zoom: e.scale,
                    originX: e.originX,
                    originY: e.originY
                }), this._updateNodeAndLinkScale(), XN(t.getGraph(), mm(t)), this._lineDraw.updateLayout()
            }, this))
        }, _updateNodeAndLinkScale: function () {
            var t = this._model, e = t.getData(), i = mm(t), n = [i, i];
            e.eachItemGraphicEl(function (t) {
                t.attr("scale", n)
            })
        }, updateLayout: function (t) {
            XN(t.getGraph(), mm(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout()
        }, remove: function () {
            this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove()
        }
    }), Pu({type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series:focusNodeAdjacency"}, function () {
    }), Pu({
        type: "unfocusNodeAdjacency",
        event: "unfocusNodeAdjacency",
        update: "series:unfocusNodeAdjacency"
    }, function () {
    });
    var $N = {type: "graphRoam", event: "graphRoam", update: "none"};
    Pu($N, function (t, e) {
        e.eachComponent({mainType: "series", query: t}, function (e) {
            var i = e.coordinateSystem, n = Tp(i, t);
            e.setCenter && e.setCenter(n.center), e.setZoom && e.setZoom(n.zoom)
        })
    });
    var JN = function (t) {
        var e = t.findComponents({mainType: "legend"});
        e && e.length && t.eachSeriesByType("graph", function (t) {
            var i = t.getCategoriesData(), n = t.getGraph(), o = n.data, a = i.mapArray(i.getName);
            o.filterSelf(function (t) {
                var i = o.getItemModel(t), n = i.getShallow("category");
                if (null != n) {
                    "number" == typeof n && (n = a[n]);
                    for (var r = 0; r < e.length; r++) if (!e[r].isSelected(n)) return !1
                }
                return !0
            })
        }, this)
    }, QN = function (t) {
        var e = {};
        t.eachSeriesByType("graph", function (t) {
            var i = t.getCategoriesData(), n = t.getData(), o = {};
            i.each(function (n) {
                var a = i.getName(n);
                o["ec-" + a] = n;
                var r = i.getItemModel(n), s = r.get("itemStyle.color") || t.getColorFromPalette(a, e);
                i.setItemVisual(n, "color", s);
                for (var l = ["opacity", "symbol", "symbolSize", "symbolKeepAspect"], u = 0; u < l.length; u++) {
                    var h = r.getShallow(l[u], !0);
                    null != h && i.setItemVisual(n, l[u], h)
                }
            }), i.count() && n.each(function (t) {
                var e = n.getItemModel(t), a = e.getShallow("category");
                if (null != a) {
                    "string" == typeof a && (a = o["ec-" + a]);
                    for (var r = ["color", "opacity", "symbol", "symbolSize", "symbolKeepAspect"], s = 0; s < r.length; s++) null == n.getItemVisual(t, r[s], !0) && n.setItemVisual(t, r[s], i.getItemVisual(a, r[s]))
                }
            })
        })
    }, tR = function (t) {
        t.eachSeriesByType("graph", function (t) {
            var e = t.getGraph(), i = t.getEdgeData(), n = bm(t.get("edgeSymbol")), o = bm(t.get("edgeSymbolSize")),
                a = "lineStyle.color".split("."), r = "lineStyle.opacity".split(".");
            i.setVisual("fromSymbol", n && n[0]), i.setVisual("toSymbol", n && n[1]), i.setVisual("fromSymbolSize", o && o[0]), i.setVisual("toSymbolSize", o && o[1]), i.setVisual("color", t.get(a)), i.setVisual("opacity", t.get(r)), i.each(function (t) {
                var n = i.getItemModel(t), o = e.getEdgeByIndex(t), s = bm(n.getShallow("symbol", !0)),
                    l = bm(n.getShallow("symbolSize", !0)), u = n.get(a), h = n.get(r);
                switch (u) {
                    case"source":
                        u = o.node1.getVisual("color");
                        break;
                    case"target":
                        u = o.node2.getVisual("color")
                }
                s[0] && o.setVisual("fromSymbol", s[0]), s[1] && o.setVisual("toSymbol", s[1]), l[0] && o.setVisual("fromSymbolSize", l[0]), l[1] && o.setVisual("toSymbolSize", l[1]), o.setVisual("color", u), o.setVisual("opacity", h)
            })
        })
    }, eR = function (t) {
        t.eachSeriesByType("graph", function (t) {
            var e = t.get("layout"), i = t.coordinateSystem;
            if (i && "view" !== i.type) {
                var n = t.getData(), o = [];
                f(i.dimensions, function (t) {
                    o = o.concat(n.mapDimension(t, !0))
                });
                for (var a = 0; a < n.count(); a++) {
                    for (var r = [], s = !1, l = 0; l < o.length; l++) {
                        var u = n.get(o[l], a);
                        isNaN(u) || (s = !0), r.push(u)
                    }
                    s ? n.setItemLayout(a, i.dataToPoint(r)) : n.setItemLayout(a, [0 / 0, 0 / 0])
                }
                Mm(n.graph, t)
            } else e && "none" !== e || Sm(t)
        })
    }, iR = Math.PI, nR = [], oR = {
        value: function (t, e, i, n, o, a, r, s) {
            var l = 0, u = n.getSum("value"), h = 2 * Math.PI / (u || s);
            i.eachNode(function (t) {
                var e = t.getValue("value"), i = h * (u ? e : 1) / 2;
                l += i, t.setLayout([o * Math.cos(l) + a, o * Math.sin(l) + r]), l += i
            })
        }, symbolSize: function (t, e, i, n, o, a, r, s) {
            var l = 0;
            nR.length = s;
            var u = mm(t);
            i.eachNode(function (t) {
                var e = vm(t);
                isNaN(e) && (e = 2), 0 > e && (e = 0), e *= u;
                var i = Math.asin(e / 2 / o);
                isNaN(i) && (i = iR / 2), nR[t.dataIndex] = i, l += 2 * i
            });
            var h = (2 * iR - l) / s / 2, c = 0;
            i.eachNode(function (t) {
                var e = h + nR[t.dataIndex];
                c += e, t.setLayout([o * Math.cos(c) + a, o * Math.sin(c) + r]), c += e
            })
        }
    }, aR = function (t) {
        t.eachSeriesByType("graph", function (t) {
            "circular" === t.get("layout") && Im(t, "symbolSize")
        })
    }, rR = X, sR = function (t) {
        t.eachSeriesByType("graph", function (t) {
            var e = t.coordinateSystem;
            if (!e || "view" === e.type) if ("force" === t.get("layout")) {
                var i = t.preservedPoints || {}, n = t.getGraph(), o = n.data, a = n.edgeData, r = t.getModel("force"),
                    s = r.get("initLayout");
                t.preservedPoints ? o.each(function (t) {
                    var e = o.getId(t);
                    o.setItemLayout(t, i[e] || [0 / 0, 0 / 0])
                }) : s && "none" !== s ? "circular" === s && Im(t, "value") : Sm(t);
                var l = o.getDataExtent("value"), u = a.getDataExtent("value"), h = r.get("repulsion"),
                    c = r.get("edgeLength");
                _(h) || (h = [h, h]), _(c) || (c = [c, c]), c = [c[1], c[0]];
                var d = o.mapArray("value", function (t, e) {
                        var i = o.getItemLayout(e), n = Mr(t, l, h);
                        return isNaN(n) && (n = (h[0] + h[1]) / 2), {
                            w: n,
                            rep: n,
                            fixed: o.getItemModel(e).get("fixed"),
                            p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i
                        }
                    }), f = a.mapArray("value", function (e, i) {
                        var o = n.getEdgeByIndex(i), a = Mr(e, u, c);
                        isNaN(a) && (a = (c[0] + c[1]) / 2);
                        var r = o.getModel(), s = L(r.get("lineStyle.curveness"), -gm(o, t, i, !0), 0);
                        return {
                            n1: d[o.node1.dataIndex],
                            n2: d[o.node2.dataIndex],
                            d: a,
                            curveness: s,
                            ignoreForceLayout: r.get("ignoreForceLayout")
                        }
                    }), e = t.coordinateSystem, p = e.getBoundingRect(),
                    g = Tm(d, f, {rect: p, gravity: r.get("gravity"), friction: r.get("friction")}), m = g.step;
                g.step = function (t) {
                    for (var e = 0, a = d.length; a > e; e++) d[e].fixed && W(d[e].p, n.getNodeByIndex(e).getLayout());
                    m(function (e, a, r) {
                        for (var s = 0, l = e.length; l > s; s++) e[s].fixed || n.getNodeByIndex(s).setLayout(e[s].p), i[o.getId(s)] = e[s].p;
                        for (var s = 0, l = a.length; l > s; s++) {
                            var u = a[s], h = n.getEdgeByIndex(s), c = u.n1.p, d = u.n2.p, f = h.getLayout();
                            f = f ? f.slice() : [], f[0] = f[0] || [], f[1] = f[1] || [], W(f[0], c), W(f[1], d), +u.curveness && (f[2] = [(c[0] + d[0]) / 2 - (c[1] - d[1]) * u.curveness, (c[1] + d[1]) / 2 - (d[0] - c[0]) * u.curveness]), h.setLayout(f)
                        }
                        t && t(r)
                    })
                }, t.forceLayout = g, t.preservedPoints = i, g.step()
            } else t.forceLayout = null
        })
    }, lR = function (t, e) {
        var i = [];
        return t.eachSeriesByType("graph", function (t) {
            var n = t.get("coordinateSystem");
            if (!n || "view" === n) {
                var o = t.getData(), a = o.mapArray(function (t) {
                    var e = o.getItemModel(t);
                    return [+e.get("x"), +e.get("y")]
                }), r = [], s = [];
                Go(a, r, s), s[0] - r[0] === 0 && (s[0] += 1, r[0] -= 1), s[1] - r[1] === 0 && (s[1] += 1, r[1] -= 1);
                var l = (s[0] - r[0]) / (s[1] - r[1]), u = Am(t, e, l);
                isNaN(l) && (r = [u.x, u.y], s = [u.x + u.width, u.y + u.height]);
                var h = s[0] - r[0], c = s[1] - r[1], d = u.width, f = u.height, p = t.coordinateSystem = new ip;
                p.zoomLimit = t.get("scaleLimit"), p.setBoundingRect(r[0], r[1], h, c), p.setViewRect(u.x, u.y, d, f), p.setCenter(t.get("center")), p.setZoom(t.get("zoom")), i.push(p)
            }
        }), i
    };
    Lu(JN), Ru(YP("graph", "circle", null)), Ru(QN), Ru(tR), Nu(eR), Nu(mL.VISUAL.POST_CHART_LAYOUT, aR), Nu(sR), Ou("graphView", {create: lR});
    var uR = dC.extend({
        type: "series.boxplot",
        dependencies: ["xAxis", "yAxis", "grid"],
        defaultValueDimensions: [{name: "min", defaultTooltip: !0}, {name: "Q1", defaultTooltip: !0}, {
            name: "median",
            defaultTooltip: !0
        }, {name: "Q3", defaultTooltip: !0}, {name: "max", defaultTooltip: !0}],
        dimensions: null,
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            hoverAnimation: !0,
            layout: null,
            boxWidth: [7, 50],
            itemStyle: {color: "#fff", borderWidth: 1},
            emphasis: {
                itemStyle: {
                    borderWidth: 2,
                    shadowBlur: 5,
                    shadowOffsetX: 2,
                    shadowOffsetY: 2,
                    shadowColor: "rgba(0,0,0,0.4)"
                }
            },
            animationEasing: "elasticOut",
            animationDuration: 800
        }
    });
    c(uR, gO, !0);
    var hR = ["itemStyle"], cR = ["emphasis", "itemStyle"], dR = (yl.extend({
        type: "boxplot", render: function (t) {
            var e = t.getData(), i = this.group, n = this._data;
            this._data || i.removeAll();
            var o = "horizontal" === t.get("layout") ? 1 : 0;
            e.diff(n).add(function (t) {
                if (e.hasValue(t)) {
                    var n = e.getItemLayout(t), a = Dm(n, e, t, o, !0);
                    e.setItemGraphicEl(t, a), i.add(a)
                }
            }).update(function (t, a) {
                var r = n.getItemGraphicEl(a);
                if (!e.hasValue(t)) return void i.remove(r);
                var s = e.getItemLayout(t);
                r ? Cm(s, r, e, t) : r = Dm(s, e, t, o), i.add(r), e.setItemGraphicEl(t, r)
            }).remove(function (t) {
                var e = n.getItemGraphicEl(t);
                e && i.remove(e)
            }).execute(), this._data = e
        }, remove: function () {
            var t = this.group, e = this._data;
            this._data = null, e && e.eachItemGraphicEl(function (e) {
                e && t.remove(e)
            })
        }, dispose: G
    }), aa.extend({
        type: "boxplotBoxPath", shape: {}, buildPath: function (t, e) {
            var i = e.points, n = 0;
            for (t.moveTo(i[n][0], i[n][1]), n++; 4 > n; n++) t.lineTo(i[n][0], i[n][1]);
            for (t.closePath(); n < i.length; n++) t.moveTo(i[n][0], i[n][1]), n++, t.lineTo(i[n][0], i[n][1])
        }
    })), fR = ["itemStyle", "borderColor"], pR = function (t) {
        var e = t.get("color");
        t.eachRawSeriesByType("boxplot", function (i) {
            var n = e[i.seriesIndex % e.length], o = i.getData();
            o.setVisual({
                legendSymbol: "roundRect",
                color: i.get(fR) || n
            }), t.isSeriesFiltered(i) || o.each(function (t) {
                var e = o.getItemModel(t);
                o.setItemVisual(t, {color: e.get(fR, !0)})
            })
        })
    }, gR = f, mR = function (t) {
        var e = km(t);
        gR(e, function (t) {
            var e = t.seriesModels;
            e.length && (Pm(t), gR(e, function (e, i) {
                Om(e, t.boxOffsetList[i], t.boxWidthList[i])
            }))
        })
    };
    Ru(pR), Nu(mR);
    var vR = function (t) {
        Em(t), Nm(t)
    }, yR = function (t, e, i, n, o) {
        Zk.call(this, t, e, i), this.type = n || "value", this.axisIndex = o
    };
    yR.prototype = {
        constructor: yR, model: null, isHorizontal: function () {
            return "horizontal" !== this.coordinateSystem.getModel().get("layout")
        }
    }, h(yR, Zk);
    var xR = function (t, e, i, n, o, a) {
        t = t || 0;
        var r = i[1] - i[0];
        if (null != o && (o = zm(o, [0, r])), null != a && (a = Math.max(a, null != o ? o : 0)), "all" === n) {
            var s = Math.abs(e[1] - e[0]);
            s = zm(s, [0, r]), o = a = zm(s, [o, a]), n = 0
        }
        e[0] = zm(e[0], i), e[1] = zm(e[1], i);
        var l = Rm(e, n);
        e[n] += t;
        var u = o || 0, h = i.slice();
        l.sign < 0 ? h[0] += u : h[1] -= u, e[n] = zm(e[n], h);
        var c = Rm(e, n);
        null != o && (c.sign !== l.sign || c.span < o) && (e[1 - n] = e[n] + l.sign * o);
        var c = Rm(e, n);
        return null != a && c.span > a && (e[1 - n] = e[n] + c.sign * a), e
    }, _R = f, wR = Math.min, bR = Math.max, SR = Math.floor, MR = Math.ceil, IR = Tr, TR = Math.PI;
    Bm.prototype = {
        type: "parallel", constructor: Bm, _init: function (t, e) {
            var i = t.dimensions, n = t.parallelAxisIndex;
            _R(i, function (t, i) {
                var o = n[i], a = e.getComponent("parallelAxis", o),
                    r = this._axesMap.set(t, new yR(t, Kh(a), [0, 0], a.get("type"), o)), s = "category" === r.type;
                r.onBand = s && a.get("boundaryGap"), r.inverse = a.get("inverse"), a.axis = r, r.model = a, r.coordinateSystem = a.coordinateSystem = this
            }, this)
        }, update: function (t) {
            this._updateAxesFromSeries(this._model, t)
        }, containPoint: function (t) {
            var e = this._makeLayoutInfo(), i = e.axisBase, n = e.layoutBase, o = e.pixelDimIndex, a = t[1 - o],
                r = t[o];
            return a >= i && a <= i + e.axisLength && r >= n && r <= n + e.layoutLength
        }, getModel: function () {
            return this._model
        }, _updateAxesFromSeries: function (t, e) {
            e.eachSeries(function (i) {
                if (t.contains(i, e)) {
                    var n = i.getData();
                    _R(this.dimensions, function (t) {
                        var e = this._axesMap.get(t);
                        e.scale.unionExtentFromData(n, n.mapDimension(t)), qh(e.scale, e.model)
                    }, this)
                }
            }, this)
        }, resize: function (t, e) {
            this._rect = es(t.getBoxLayoutParams(), {width: e.getWidth(), height: e.getHeight()}), this._layoutAxes()
        }, getRect: function () {
            return this._rect
        }, _makeLayoutInfo: function () {
            var t, e = this._model, i = this._rect, n = ["x", "y"], o = ["width", "height"], a = e.get("layout"),
                r = "horizontal" === a ? 0 : 1, s = i[o[r]], l = [0, s], u = this.dimensions.length,
                h = Vm(e.get("axisExpandWidth"), l), c = Vm(e.get("axisExpandCount") || 0, [0, u]),
                d = e.get("axisExpandable") && u > 3 && u > c && c > 1 && h > 0 && s > 0, f = e.get("axisExpandWindow");
            if (f) t = Vm(f[1] - f[0], l), f[1] = f[0] + t; else {
                t = Vm(h * (c - 1), l);
                var p = e.get("axisExpandCenter") || SR(u / 2);
                f = [h * p - t / 2], f[1] = f[0] + t
            }
            var g = (s - t) / (u - c);
            3 > g && (g = 0);
            var m = [SR(IR(f[0] / h, 1)) + 1, MR(IR(f[1] / h, 1)) - 1], v = g / h * f[0];
            return {
                layout: a,
                pixelDimIndex: r,
                layoutBase: i[n[r]],
                layoutLength: s,
                axisBase: i[n[1 - r]],
                axisLength: i[o[1 - r]],
                axisExpandable: d,
                axisExpandWidth: h,
                axisCollapseWidth: g,
                axisExpandWindow: f,
                axisCount: u,
                winInnerIndices: m,
                axisExpandWindow0Pos: v
            }
        }, _layoutAxes: function () {
            var t = this._rect, e = this._axesMap, i = this.dimensions, n = this._makeLayoutInfo(), o = n.layout;
            e.each(function (t) {
                var e = [0, n.axisLength], i = t.inverse ? 1 : 0;
                t.setExtent(e[i], e[1 - i])
            }), _R(i, function (e, i) {
                var a = (n.axisExpandable ? Fm : Gm)(i, n),
                    r = {horizontal: {x: a.position, y: n.axisLength}, vertical: {x: 0, y: a.position}},
                    s = {horizontal: TR / 2, vertical: 0}, l = [r[o].x + t.x, r[o].y + t.y], u = s[o], h = Oe();
                Be(h, h, u), ze(h, h, l), this._axesLayout[e] = {
                    position: l,
                    rotation: u,
                    transform: h,
                    axisNameAvailableWidth: a.axisNameAvailableWidth,
                    axisLabelShow: a.axisLabelShow,
                    nameTruncateMaxWidth: a.nameTruncateMaxWidth,
                    tickDirection: 1,
                    labelDirection: 1
                }
            }, this)
        }, getAxis: function (t) {
            return this._axesMap.get(t)
        }, dataToPoint: function (t, e) {
            return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e)
        }, eachActiveState: function (t, e, i, n) {
            null == i && (i = 0), null == n && (n = t.count());
            var o = this._axesMap, a = this.dimensions, r = [], s = [];
            f(a, function (e) {
                r.push(t.mapDimension(e)), s.push(o.get(e).model)
            });
            for (var l = this.hasAxisBrushed(), u = i; n > u; u++) {
                var h;
                if (l) {
                    h = "active";
                    for (var c = t.getValues(r, u), d = 0, p = a.length; p > d; d++) {
                        var g = s[d].getActiveState(c[d]);
                        if ("inactive" === g) {
                            h = "inactive";
                            break
                        }
                    }
                } else h = "normal";
                e(h, u)
            }
        }, hasAxisBrushed: function () {
            for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, o = t.length; o > n; n++) "normal" !== e.get(t[n]).model.getActiveState() && (i = !0);
            return i
        }, axisCoordToPoint: function (t, e) {
            var i = this._axesLayout[e];
            return sr([t, 0], i.transform)
        }, getAxisLayout: function (t) {
            return n(this._axesLayout[t])
        }, getSlidedAxisExpandWindow: function (t) {
            var e = this._makeLayoutInfo(), i = e.pixelDimIndex, n = e.axisExpandWindow.slice(), o = n[1] - n[0],
                a = [0, e.axisExpandWidth * (e.axisCount - 1)];
            if (!this.containPoint(t)) return {behavior: "none", axisExpandWindow: n};
            var r, s = t[i] - e.layoutBase - e.axisExpandWindow0Pos, l = "slide", u = e.axisCollapseWidth,
                h = this._model.get("axisExpandSlideTriggerArea"), c = null != h[0];
            if (u) c && u && s < o * h[0] ? (l = "jump", r = s - o * h[2]) : c && u && s > o * (1 - h[0]) ? (l = "jump", r = s - o * (1 - h[2])) : (r = s - o * h[1]) >= 0 && (r = s - o * (1 - h[1])) <= 0 && (r = 0), r *= e.axisExpandWidth / u, r ? xR(r, n, a, "all") : l = "none"; else {
                var o = n[1] - n[0], d = a[1] * s / o;
                n = [bR(0, d - o / 2)], n[1] = wR(a[1], n[0] + o), n[0] = n[1] - o
            }
            return {axisExpandWindow: n, behavior: l}
        }
    }, Ps.register("parallel", {create: Wm});
    var AR = ID.extend({
        type: "baseParallelAxis", axis: null, activeIntervals: [], getAreaSelectStyle: function () {
            return hT([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle"))
        }, setActiveIntervals: function (t) {
            var e = this.activeIntervals = n(t);
            if (e) for (var i = e.length - 1; i >= 0; i--) Ar(e[i])
        }, getActiveState: function (t) {
            var e = this.activeIntervals;
            if (!e.length) return "normal";
            if (null == t || isNaN(t)) return "inactive";
            if (1 === e.length) {
                var i = e[0];
                if (i[0] <= t && t <= i[1]) return "active"
            } else for (var n = 0, o = e.length; o > n; n++) if (e[n][0] <= t && t <= e[n][1]) return "active";
            return "inactive"
        }
    }), DR = {
        type: "value",
        dim: null,
        areaSelectStyle: {
            width: 20,
            borderWidth: 1,
            borderColor: "rgba(160,197,232)",
            color: "rgba(160,197,232)",
            opacity: .3
        },
        realtime: !0,
        z: 10
    };
    o(AR.prototype, Ck), Qk("parallel", AR, Hm, DR), ID.extend({
        type: "parallel",
        dependencies: ["parallelAxis"],
        coordinateSystem: null,
        dimensions: null,
        parallelAxisIndex: null,
        layoutMode: "box",
        defaultOption: {
            zlevel: 0,
            z: 0,
            left: 80,
            top: 60,
            right: 80,
            bottom: 60,
            layout: "horizontal",
            axisExpandable: !1,
            axisExpandCenter: null,
            axisExpandCount: 0,
            axisExpandWidth: 50,
            axisExpandRate: 17,
            axisExpandDebounce: 50,
            axisExpandSlideTriggerArea: [-.15, .05, .4],
            axisExpandTriggerOn: "click",
            parallelAxisDefault: null
        },
        init: function () {
            ID.prototype.init.apply(this, arguments), this.mergeOption({})
        },
        mergeOption: function (t) {
            var e = this.option;
            t && o(e, t, !0), this._initDimensions()
        },
        contains: function (t, e) {
            var i = t.get("parallelIndex");
            return null != i && e.getComponent("parallel", i) === this
        },
        setAxisExpand: function (t) {
            f(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function (e) {
                t.hasOwnProperty(e) && (this.option[e] = t[e])
            }, this)
        },
        _initDimensions: function () {
            var t = this.dimensions = [], e = this.parallelAxisIndex = [],
                i = m(this.dependentModels.parallelAxis, function (t) {
                    return (t.get("parallelIndex") || 0) === this.componentIndex
                }, this);
            f(i, function (i) {
                t.push("dim" + i.get("dim")), e.push(i.componentIndex)
            })
        }
    });
    var CR = {type: "axisAreaSelect", event: "axisAreaSelected"};
    Pu(CR, function (t, e) {
        e.eachComponent({mainType: "parallelAxis", query: t}, function (e) {
            e.axis.model.setActiveIntervals(t.intervals)
        })
    }), Pu("parallelAxisExpand", function (t, e) {
        e.eachComponent({mainType: "parallel", query: t}, function (e) {
            e.setAxisExpand(t)
        })
    });
    var LR = x, kR = f, PR = p, OR = Math.min, ER = Math.max, NR = Math.pow, RR = 1e4, zR = 6, BR = 6, VR = "globalPan",
        GR = {w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1]},
        FR = {w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse"}, WR = {
            brushStyle: {lineWidth: 2, stroke: "rgba(0,0,0,0.3)", fill: "rgba(0,0,0,0.1)"},
            transformable: !0,
            brushMode: "single",
            removeOnClick: !1
        }, HR = 0;
    Zm.prototype = {
        constructor: Zm, enableBrush: function (t) {
            return BS && O(this._mounted), this._brushType && Xm(this), t.brushType && Um(this, t), this
        }, setPanels: function (t) {
            if (t && t.length) {
                var e = this._panels = {};
                f(t, function (t) {
                    e[t.panelId] = n(t)
                })
            } else this._panels = null;
            return this
        }, mount: function (t) {
            t = t || {}, BS && (this._mounted = !0), this._enableGlobalPan = t.enableGlobalPan;
            var e = this.group;
            return this._zr.add(e), e.attr({
                position: t.position || [0, 0],
                rotation: t.rotation || 0,
                scale: t.scale || [1, 1]
            }), this._transform = e.getLocalTransform(), this
        }, eachCover: function (t, e) {
            kR(this._covers, t, e)
        }, updateCovers: function (t) {
            function e(t, e) {
                return (null != t.id ? t.id : s + e) + "-" + t.brushType
            }

            function i(t, i) {
                return e(t.__brushOption, i)
            }

            function a(e, i) {
                var n = t[e];
                if (null != i && l[i] === c) u[e] = l[i]; else {
                    var o = u[e] = null != i ? (l[i].__brushOption = n, l[i]) : Km(h, qm(h, n));
                    Qm(h, o)
                }
            }

            function r(t) {
                l[t] !== c && h.group.remove(l[t])
            }

            BS && O(this._mounted), t = p(t, function (t) {
                return o(n(WR), t, !0)
            });
            var s = "\x00-brush-index-", l = this._covers, u = this._covers = [], h = this, c = this._creatingCover;
            return new Yu(l, t, i, e).add(a).update(a).remove(r).execute(), this
        }, unmount: function () {
            return !BS || this._mounted ? (this.enableBrush(!1), nv(this), this._zr.remove(this.group), BS && (this._mounted = !1), this) : void 0
        }, dispose: function () {
            this.unmount(), this.off()
        }
    }, c(Zm, hM);
    var ZR = {
        mousedown: function (t) {
            if (this._dragging) Iv(this, t); else if (!t.target || !t.target.draggable) {
                wv(t);
                var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
                this._creatingCover = null;
                var i = this._creatingPanel = ev(this, t, e);
                i && (this._dragging = !0, this._track = [e.slice()])
            }
        }, mousemove: function (t) {
            var e = t.offsetX, i = t.offsetY, n = this.group.transformCoordToLocal(e, i);
            if (_v(this, t, n), this._dragging) {
                wv(t);
                var o = Sv(this, t, n, !1);
                o && ov(this, o)
            }
        }, mouseup: function (t) {
            Iv(this, t)
        }
    }, UR = {
        lineX: Av(0), lineY: Av(1), rect: {
            createCover: function (t, e) {
                return sv(LR(gv, function (t) {
                    return t
                }, function (t) {
                    return t
                }), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"])
            }, getCreatingRange: function (t) {
                var e = rv(t);
                return dv(e[1][0], e[1][1], e[0][0], e[0][1])
            }, updateCoverShape: function (t, e, i, n) {
                lv(t, e, i, n)
            }, updateCommon: uv, contain: bv
        }, polygon: {
            createCover: function (t, e) {
                var i = new iI;
                return i.add(new TA({name: "main", style: cv(e), silent: !0})), i
            }, getCreatingRange: function (t) {
                return t
            }, endCreating: function (t, e) {
                e.remove(e.childAt(0)), e.add(new IA({
                    name: "main",
                    draggable: !0,
                    drift: LR(mv, t, e),
                    ondragend: LR(ov, t, {isEnd: !0})
                }))
            }, updateCoverShape: function (t, e, i) {
                e.childAt(0).setShape({points: yv(t, e, i)})
            }, updateCommon: uv, contain: bv
        }
    }, XR = ["axisLine", "axisTickLabel", "axisName"], YR = Gu({
        type: "parallelAxis", init: function (t, e) {
            YR.superApply(this, "init", arguments), (this._brushController = new Zm(e.getZr())).on("brush", y(this._onBrush, this))
        }, render: function (t, e, i, n) {
            if (!Pv(t, e, n)) {
                this.axisModel = t, this.api = i, this.group.removeAll();
                var o = this._axisGroup;
                if (this._axisGroup = new iI, this.group.add(this._axisGroup), t.get("show")) {
                    var a = Ev(t, e), s = a.coordinateSystem, l = t.getAreaSelectStyle(), u = l.width, h = t.axis.dim,
                        c = s.getAxisLayout(h), d = r({strokeContainThreshold: u}, c), p = new yP(t, d);
                    f(XR, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(d, l, t, a, u, i);
                    var g = n && n.animation === !1 ? null : t;
                    ur(o, this._axisGroup, g)
                }
            }
        }, _refreshBrushController: function (t, e, i, n, o, a) {
            var r = i.axis.getExtent(), s = r[1] - r[0], l = Math.min(30, .1 * Math.abs(s)),
                u = Ti.create({x: r[0], y: -o / 2, width: s, height: o});
            u.x -= l, u.width += 2 * l, this._brushController.mount({
                enableGlobalPan: !0,
                rotation: t.rotation,
                position: t.position
            }).setPanels([{
                panelId: "pl",
                clipPath: Dv(u),
                isTargetByCursor: Lv(u, a, n),
                getLinearBrushOtherExtent: Cv(u, 0)
            }]).enableBrush({brushType: "lineX", brushStyle: e, removeOnClick: !0}).updateCovers(Ov(i))
        }, _onBrush: function (t, e) {
            var i = this.axisModel, n = i.axis, o = p(t, function (t) {
                return [n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0)]
            });
            (!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({
                type: "axisAreaSelect",
                parallelAxisId: i.id,
                intervals: o
            })
        }, dispose: function () {
            this._brushController.dispose()
        }
    }), jR = 5;
    Gu({
        type: "parallel", render: function (t, e, i) {
            this._model = t, this._api = i, this._handlers || (this._handlers = {}, f(qR, function (t, e) {
                i.getZr().on(e, this._handlers[e] = y(t, this))
            }, this)), Ml(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate")
        }, dispose: function (t, e) {
            f(this._handlers, function (t, i) {
                e.getZr().off(i, t)
            }), this._handlers = null
        }, _throttledDispatchExpand: function (t) {
            this._dispatchExpand(t)
        }, _dispatchExpand: function (t) {
            t && this._api.dispatchAction(r({type: "parallelAxisExpand"}, t))
        }
    });
    var qR = {
        mousedown: function (t) {
            Nv(this, "click") && (this._mouseDownPoint = [t.offsetX, t.offsetY])
        }, mouseup: function (t) {
            var e = this._mouseDownPoint;
            if (Nv(this, "click") && e) {
                var i = [t.offsetX, t.offsetY], n = Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2);
                if (n > jR) return;
                var o = this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]);
                "none" !== o.behavior && this._dispatchExpand({axisExpandWindow: o.axisExpandWindow})
            }
            this._mouseDownPoint = null
        }, mousemove: function (t) {
            if (!this._mouseDownPoint && Nv(this, "mousemove")) {
                var e = this._model, i = e.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]),
                    n = i.behavior;
                "jump" === n && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand("none" === n ? null : {
                    axisExpandWindow: i.axisExpandWindow,
                    animation: "jump" === n ? null : !1
                })
            }
        }
    };
    Cu(vR), dC.extend({
        type: "series.parallel",
        dependencies: ["parallel"],
        visualColorAccessPath: "lineStyle.color",
        getInitialData: function () {
            var t = this.getSource();
            return Rv(t, this), Sh(t, this)
        },
        getRawIndicesByActiveState: function (t) {
            var e = this.coordinateSystem, i = this.getData(), n = [];
            return e.eachActiveState(i, function (e, o) {
                t === e && n.push(i.getRawIndex(o))
            }), n
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "parallel",
            parallelIndex: 0,
            label: {show: !1},
            inactiveOpacity: .05,
            activeOpacity: 1,
            lineStyle: {width: 1, opacity: .45, type: "solid"},
            emphasis: {label: {show: !1}},
            progressive: 500,
            smooth: !1,
            animationEasing: "linear"
        }
    });
    var KR = .3, $R = (yl.extend({
        type: "parallel", init: function () {
            this._dataGroup = new iI, this.group.add(this._dataGroup), this._data, this._initialized
        }, render: function (t, e, i, n) {
            function o(t) {
                var e = Gv(l, s, t, c, h);
                Wv(e, l, t, d)
            }

            function a(e, i) {
                var o = u.getItemGraphicEl(i), a = Vv(l, e, c, h);
                l.setItemGraphicEl(e, o);
                var r = n && n.animation === !1 ? null : t;
                or(o, {shape: {points: a}}, r, e), Wv(o, l, e, d)
            }

            function r(t) {
                var e = u.getItemGraphicEl(t);
                s.remove(e)
            }

            var s = this._dataGroup, l = t.getData(), u = this._data, h = t.coordinateSystem, c = h.dimensions,
                d = Fv(t);
            if (l.diff(u).add(o).update(a).remove(r).execute(), !this._initialized) {
                this._initialized = !0;
                var f = Bv(h, t, function () {
                    setTimeout(function () {
                        s.removeClipPath()
                    })
                });
                s.setClipPath(f)
            }
            this._data = l
        }, incrementalPrepareRender: function () {
            this._initialized = !0, this._data = null, this._dataGroup.removeAll()
        }, incrementalRender: function (t, e) {
            for (var i = e.getData(), n = e.coordinateSystem, o = n.dimensions, a = Fv(e), r = t.start; r < t.end; r++) {
                var s = Gv(i, this._dataGroup, r, o, n);
                s.incremental = !0, Wv(s, i, r, a)
            }
        }, dispose: function () {
        }, remove: function () {
            this._dataGroup && this._dataGroup.removeAll(), this._data = null
        }
    }), ["lineStyle", "normal", "opacity"]), JR = {
        seriesType: "parallel", reset: function (t, e) {
            function i(t, e) {
                h.eachActiveState(e, function (t, i) {
                    var n = d[t];
                    if ("normal" === t && e.hasItemOption) {
                        var o = e.getItemModel(i).get($R, !0);
                        null != o && (n = o)
                    }
                    e.setItemVisual(i, "opacity", n)
                }, t.start, t.end)
            }

            var n = t.getModel("itemStyle"), o = t.getModel("lineStyle"), a = e.get("color"),
                r = o.get("color") || n.get("color") || a[t.seriesIndex % a.length], s = t.get("inactiveOpacity"),
                l = t.get("activeOpacity"), u = t.getModel("lineStyle").getLineStyle(), h = t.coordinateSystem,
                c = t.getData(), d = {normal: u.opacity, active: l, inactive: s};
            return c.setVisual("color", r), {progress: i}
        }
    };
    Ru(JR);
    var QR = (dC.extend({
        type: "series.gauge",
        getInitialData: function () {
            return JP(this, ["value"])
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            center: ["50%", "50%"],
            legendHoverLink: !0,
            radius: "75%",
            startAngle: 225,
            endAngle: -45,
            clockwise: !0,
            min: 0,
            max: 100,
            splitNumber: 10,
            axisLine: {show: !0, lineStyle: {color: [[.2, "#91c7ae"], [.8, "#63869e"], [1, "#c23531"]], width: 30}},
            splitLine: {show: !0, length: 30, lineStyle: {color: "#eee", width: 2, type: "solid"}},
            axisTick: {show: !0, splitNumber: 5, length: 8, lineStyle: {color: "#eee", width: 1, type: "solid"}},
            axisLabel: {show: !0, distance: 5, color: "auto"},
            pointer: {show: !0, length: "80%", width: 8},
            itemStyle: {color: "auto"},
            title: {show: !0, offsetCenter: [0, "-40%"], color: "#333", fontSize: 15},
            detail: {
                show: !0,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                borderColor: "#ccc",
                width: 100,
                height: null,
                padding: [5, 10],
                offsetCenter: [0, "40%"],
                color: "auto",
                fontSize: 30
            }
        }
    }), aa.extend({
        type: "echartsGaugePointer",
        shape: {angle: 0, width: 10, r: 10, x: 0, y: 0},
        buildPath: function (t, e) {
            var i = Math.cos, n = Math.sin, o = e.r, a = e.width, r = e.angle,
                s = e.x - i(r) * a * (a >= o / 3 ? 1 : 2), l = e.y - n(r) * a * (a >= o / 3 ? 1 : 2);
            r = e.angle - Math.PI / 2, t.moveTo(s, l), t.lineTo(e.x + i(r) * a, e.y + n(r) * a), t.lineTo(e.x + i(e.angle) * o, e.y + n(e.angle) * o), t.lineTo(e.x - i(r) * a, e.y - n(r) * a), t.lineTo(s, l)
        }
    })), tz = 2 * Math.PI, ez = (yl.extend({
        type: "gauge", render: function (t, e, i) {
            this.group.removeAll();
            var n = t.get("axisLine.lineStyle.color"), o = Zv(t, i);
            this._renderMain(t, e, i, n, o)
        }, dispose: function () {
        }, _renderMain: function (t, e, i, n, o) {
            for (var a = this.group, r = t.getModel("axisLine"), s = r.getModel("lineStyle"), l = t.get("clockwise"), u = -t.get("startAngle") / 180 * Math.PI, h = -t.get("endAngle") / 180 * Math.PI, c = (h - u) % tz, d = u, f = s.get("width"), p = r.get("show"), g = 0; p && g < n.length; g++) {
                var m = Math.min(Math.max(n[g][0], 0), 1), h = u + c * m, v = new wA({
                    shape: {
                        startAngle: d,
                        endAngle: h,
                        cx: o.cx,
                        cy: o.cy,
                        clockwise: l,
                        r0: o.r - f,
                        r: o.r
                    }, silent: !0
                });
                v.setStyle({fill: n[g][1]}), v.setStyle(s.getLineStyle(["color", "borderWidth", "borderColor"])), a.add(v), d = h
            }
            var y = function (t) {
                if (0 >= t) return n[0][1];
                for (var e = 0; e < n.length; e++) if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t) return n[e][1];
                return n[e - 1][1]
            };
            if (!l) {
                var x = u;
                u = h, h = x
            }
            this._renderTicks(t, e, i, y, o, u, h, l), this._renderPointer(t, e, i, y, o, u, h, l), this._renderTitle(t, e, i, y, o), this._renderDetail(t, e, i, y, o)
        }, _renderTicks: function (t, e, i, n, o, a, r) {
            for (var s = this.group, l = o.cx, u = o.cy, h = o.r, c = +t.get("min"), d = +t.get("max"), f = t.getModel("splitLine"), p = t.getModel("axisTick"), g = t.getModel("axisLabel"), m = t.get("splitNumber"), v = p.get("splitNumber"), y = Ir(f.get("length"), h), x = Ir(p.get("length"), h), _ = a, w = (r - a) / m, b = w / v, S = f.getModel("lineStyle").getLineStyle(), M = p.getModel("lineStyle").getLineStyle(), I = 0; m >= I; I++) {
                var T = Math.cos(_), A = Math.sin(_);
                if (f.get("show")) {
                    var D = new kA({
                        shape: {x1: T * h + l, y1: A * h + u, x2: T * (h - y) + l, y2: A * (h - y) + u},
                        style: S,
                        silent: !0
                    });
                    "auto" === S.stroke && D.setStyle({stroke: n(I / m)}), s.add(D)
                }
                if (g.get("show")) {
                    var C = Uv(Tr(I / m * (d - c) + c), g.get("formatter")), L = g.get("distance"), k = n(I / m);
                    s.add(new vA({
                        style: ja({}, g, {
                            text: C,
                            x: T * (h - y - L) + l,
                            y: A * (h - y - L) + u,
                            textVerticalAlign: -.4 > A ? "top" : A > .4 ? "bottom" : "middle",
                            textAlign: -.4 > T ? "left" : T > .4 ? "right" : "center"
                        }, {autoColor: k}), silent: !0
                    }))
                }
                if (p.get("show") && I !== m) {
                    for (var P = 0; v >= P; P++) {
                        var T = Math.cos(_), A = Math.sin(_), O = new kA({
                            shape: {x1: T * h + l, y1: A * h + u, x2: T * (h - x) + l, y2: A * (h - x) + u},
                            silent: !0,
                            style: M
                        });
                        "auto" === M.stroke && O.setStyle({stroke: n((I + P / v) / m)}), s.add(O), _ += b
                    }
                    _ -= b
                } else _ += w
            }
        }, _renderPointer: function (t, e, i, n, o, a, r) {
            var s = this.group, l = this._data;
            if (!t.get("pointer.show")) return void (l && l.eachItemGraphicEl(function (t) {
                s.remove(t)
            }));
            var u = [+t.get("min"), +t.get("max")], h = [a, r], c = t.getData(), d = c.mapDimension("value");
            c.diff(l).add(function (e) {
                var i = new QR({shape: {angle: a}});
                ar(i, {shape: {angle: Mr(c.get(d, e), u, h, !0)}}, t), s.add(i), c.setItemGraphicEl(e, i)
            }).update(function (e, i) {
                var n = l.getItemGraphicEl(i);
                or(n, {shape: {angle: Mr(c.get(d, e), u, h, !0)}}, t), s.add(n), c.setItemGraphicEl(e, n)
            }).remove(function (t) {
                var e = l.getItemGraphicEl(t);
                s.remove(e)
            }).execute(), c.eachItemGraphicEl(function (t, e) {
                var i = c.getItemModel(e), a = i.getModel("pointer");
                t.setShape({
                    x: o.cx,
                    y: o.cy,
                    width: Ir(a.get("width"), o.r),
                    r: Ir(a.get("length"), o.r)
                }), t.useStyle(i.getModel("itemStyle").getItemStyle()), "auto" === t.style.fill && t.setStyle("fill", n(Mr(c.get(d, e), u, [0, 1], !0))), Wa(t, i.getModel("emphasis.itemStyle").getItemStyle())
            }), this._data = c
        }, _renderTitle: function (t, e, i, n, o) {
            var a = t.getData(), r = a.mapDimension("value"), s = t.getModel("title");
            if (s.get("show")) {
                var l = s.get("offsetCenter"), u = o.cx + Ir(l[0], o.r), h = o.cy + Ir(l[1], o.r), c = +t.get("min"),
                    d = +t.get("max"), f = t.getData().get(r, 0), p = n(Mr(f, [c, d], [0, 1], !0));
                this.group.add(new vA({
                    silent: !0,
                    style: ja({}, s, {
                        x: u,
                        y: h,
                        text: a.getName(0),
                        textAlign: "center",
                        textVerticalAlign: "middle"
                    }, {autoColor: p, forceRich: !0})
                }))
            }
        }, _renderDetail: function (t, e, i, n, o) {
            var a = t.getModel("detail"), r = +t.get("min"), s = +t.get("max");
            if (a.get("show")) {
                var l = a.get("offsetCenter"), u = o.cx + Ir(l[0], o.r), h = o.cy + Ir(l[1], o.r),
                    c = Ir(a.get("width"), o.r), d = Ir(a.get("height"), o.r), f = t.getData(),
                    p = f.get(f.mapDimension("value"), 0), g = n(Mr(p, [r, s], [0, 1], !0));
                this.group.add(new vA({
                    silent: !0,
                    style: ja({}, a, {
                        x: u,
                        y: h,
                        text: Uv(p, a.get("formatter")),
                        textWidth: isNaN(c) ? null : c,
                        textHeight: isNaN(d) ? null : d,
                        textAlign: "center",
                        textVerticalAlign: "middle"
                    }, {autoColor: g, forceRich: !0})
                }))
            }
        }
    }), Fu({
        type: "series.funnel",
        init: function (t) {
            ez.superApply(this, "init", arguments), this.legendVisualProvider = new ef(y(this.getData, this), y(this.getRawData, this)), this._defaultLabelLine(t)
        },
        getInitialData: function () {
            return JP(this, {coordDimensions: ["value"], encodeDefaulter: x(xs, this)})
        },
        _defaultLabelLine: function (t) {
            io(t, "labelLine", ["show"]);
            var e = t.labelLine, i = t.emphasis.labelLine;
            e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show
        },
        getDataParams: function (t) {
            var e = this.getData(), i = ez.superCall(this, "getDataParams", t), n = e.mapDimension("value"),
                o = e.getSum(n);
            return i.percent = o ? +(e.get(n, t) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            left: 80,
            top: 60,
            right: 80,
            bottom: 60,
            minSize: "0%",
            maxSize: "100%",
            sort: "descending",
            orient: "vertical",
            gap: 0,
            funnelAlign: "center",
            label: {show: !0, position: "outer"},
            labelLine: {show: !0, length: 20, lineStyle: {width: 1, type: "solid"}},
            itemStyle: {borderColor: "#fff", borderWidth: 1},
            emphasis: {label: {show: !0}}
        }
    })), iz = Xv.prototype, nz = ["itemStyle", "opacity"];
    iz.updateData = function (t, e, i) {
        var n = this.childAt(0), o = t.hostModel, a = t.getItemModel(e), r = t.getItemLayout(e),
            l = t.getItemModel(e).get(nz);
        l = null == l ? 1 : l, n.useStyle({}), i ? (n.setShape({points: r.points}), n.setStyle({opacity: 0}), ar(n, {style: {opacity: l}}, o, e)) : or(n, {
            style: {opacity: l},
            shape: {points: r.points}
        }, o, e);
        var u = a.getModel("itemStyle"), h = t.getItemVisual(e, "color");
        n.setStyle(s({
            lineJoin: "round",
            fill: h
        }, u.getItemStyle(["opacity"]))), n.hoverStyle = u.getModel("emphasis").getItemStyle(), this._updateLabel(t, e), Wa(this)
    }, iz._updateLabel = function (t, e) {
        var i = this.childAt(1), n = this.childAt(2), o = t.hostModel, a = t.getItemModel(e), r = t.getItemLayout(e),
            s = r.label, l = t.getItemVisual(e, "color");
        or(i, {shape: {points: s.linePoints || s.linePoints}}, o, e), or(n, {
            style: {
                x: s.x,
                y: s.y
            }
        }, o, e), n.attr({rotation: s.rotation, origin: [s.x, s.y], z2: 10});
        var u = a.getModel("label"), h = a.getModel("emphasis.label"), c = a.getModel("labelLine"),
            d = a.getModel("emphasis.labelLine"), l = t.getItemVisual(e, "color");
        Xa(n.style, n.hoverStyle = {}, u, h, {
            labelFetcher: t.hostModel,
            labelDataIndex: e,
            defaultText: t.getName(e),
            autoColor: l,
            useInsideStyle: !!s.inside
        }, {
            textAlign: s.textAlign,
            textVerticalAlign: s.verticalAlign
        }), n.ignore = n.normalIgnore = !u.get("show"), n.hoverIgnore = !h.get("show"), i.ignore = i.normalIgnore = !c.get("show"), i.hoverIgnore = !d.get("show"), i.setStyle({stroke: l}), i.setStyle(c.getModel("lineStyle").getLineStyle()), i.hoverStyle = d.getModel("lineStyle").getLineStyle()
    }, h(Xv, iI);
    var oz = (yl.extend({
        type: "funnel", render: function (t) {
            var e = t.getData(), i = this._data, n = this.group;
            e.diff(i).add(function (t) {
                var i = new Xv(e, t);
                e.setItemGraphicEl(t, i), n.add(i)
            }).update(function (t, o) {
                var a = i.getItemGraphicEl(o);
                a.updateData(e, t), n.add(a), e.setItemGraphicEl(t, a)
            }).remove(function (t) {
                var e = i.getItemGraphicEl(t);
                n.remove(e)
            }).execute(), this._data = e
        }, remove: function () {
            this.group.removeAll(), this._data = null
        }, dispose: function () {
        }
    }), function (t, e) {
        t.eachSeriesByType("funnel", function (t) {
            var i = t.getData(), n = i.mapDimension("value"), o = t.get("sort"), a = Yv(t, e), r = jv(i, o),
                s = t.get("orient"), l = a.width, u = a.height, h = a.x, c = a.y,
                d = "horizontal" === s ? [Ir(t.get("minSize"), u), Ir(t.get("maxSize"), u)] : [Ir(t.get("minSize"), l), Ir(t.get("maxSize"), l)],
                f = i.getDataExtent(n), p = t.get("min"), g = t.get("max");
            null == p && (p = Math.min(f[0], 0)), null == g && (g = f[1]);
            var m = t.get("funnelAlign"), v = t.get("gap"), y = "horizontal" === s ? l : u,
                x = (y - v * (i.count() - 1)) / i.count(), _ = function (t, e) {
                    if ("horizontal" === s) {
                        var o, a = i.get(n, t) || 0, r = Mr(a, [p, g], d, !0);
                        switch (m) {
                            case"top":
                                o = c;
                                break;
                            case"center":
                                o = c + (u - r) / 2;
                                break;
                            case"bottom":
                                o = c + (u - r)
                        }
                        return [[e, o], [e, o + r]]
                    }
                    var f, a = i.get(n, t) || 0, v = Mr(a, [p, g], d, !0);
                    switch (m) {
                        case"left":
                            f = h;
                            break;
                        case"center":
                            f = h + (l - v) / 2;
                            break;
                        case"right":
                            f = h + l - v
                    }
                    return [[f, e], [f + v, e]]
                };
            "ascending" === o && (x = -x, v = -v, "horizontal" === s ? h += l : c += u, r = r.reverse());
            for (var w = 0; w < r.length; w++) {
                var b = r[w], S = r[w + 1], M = i.getItemModel(b);
                if ("horizontal" === s) {
                    var I = M.get("itemStyle.width");
                    null == I ? I = x : (I = Ir(I, l), "ascending" === o && (I = -I));
                    var T = _(b, h), A = _(S, h + I);
                    h += I + v, i.setItemLayout(b, {points: T.concat(A.slice().reverse())})
                } else {
                    var D = M.get("itemStyle.height");
                    null == D ? D = x : (D = Ir(D, u), "ascending" === o && (D = -D));
                    var T = "horizontal" === s ? _(b, h) : _(b, c), A = "horizontal" === s ? _(S, h + I) : _(S, c + D);
                    c += D + v, i.setItemLayout(b, {points: T.concat(A.slice().reverse())})
                }
            }
            qv(i)
        })
    });
    Ru(nO("funnel")), Nu(oz), Lu(uO("funnel"));
    var az = dC.extend({
            type: "series.sankey",
            layoutInfo: null,
            levelModels: null,
            getInitialData: function (t, e) {
                function i(t, e) {
                    t.wrapMethod("getItemModel", function (t, e) {
                        return t.customizeGetParent(function () {
                            var t = this.parentModel, i = t.getData().getItemLayout(e).depth, n = t.levelModels[i];
                            return n || this.parentModel
                        }), t
                    }), e.wrapMethod("getItemModel", function (t, e) {
                        return t.customizeGetParent(function () {
                            var t = this.parentModel, i = t.getGraph().getEdgeByIndex(e), n = i.node1.getLayout().depth,
                                o = t.levelModels[n];
                            return o || this.parentModel
                        }), t
                    })
                }

                for (var n = t.edges || t.links, o = t.data || t.nodes, a = t.levels, r = this.levelModels = {}, s = 0; s < a.length; s++) if (null != a[s].depth && a[s].depth >= 0) r[a[s].depth] = new vr(a[s], this, e); else if (BS) throw new Error("levels[i].depth is mandatory and should be natural number");
                if (o && n) {
                    var l = LN(o, n, this, !0, i);
                    return l.data
                }
            },
            setNodePosition: function (t, e) {
                var i = this.option.data[t];
                i.localX = e[0], i.localY = e[1]
            },
            getGraph: function () {
                return this.getData().graph
            },
            getEdgeData: function () {
                return this.getGraph().edgeData
            },
            formatTooltip: function (t, e, i) {
                if ("edge" === i) {
                    var n = this.getDataParams(t, i), o = n.data, a = o.source + " -- " + o.target;
                    return n.value && (a += " : " + n.value), Hr(a)
                }
                if ("node" === i) {
                    var r = this.getGraph().getNodeByIndex(t), s = r.getLayout().value,
                        l = this.getDataParams(t, i).data.name;
                    if (s) var a = l + " : " + s;
                    return Hr(a)
                }
                return az.superCall(this, "formatTooltip", t, e)
            },
            optionUpdated: function () {
                var t = this.option;
                t.focusNodeAdjacency === !0 && (t.focusNodeAdjacency = "allEdges")
            },
            getDataParams: function (t, e) {
                var i = az.superCall(this, "getDataParams", t, e);
                if (null == i.value && "node" === e) {
                    var n = this.getGraph().getNodeByIndex(t), o = n.getLayout().value;
                    i.value = o
                }
                return i
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                layout: null,
                left: "5%",
                top: "5%",
                right: "20%",
                bottom: "5%",
                orient: "horizontal",
                nodeWidth: 20,
                nodeGap: 8,
                draggable: !0,
                focusNodeAdjacency: !1,
                layoutIterations: 32,
                label: {show: !0, position: "right", color: "#000", fontSize: 12},
                levels: [],
                nodeAlign: "justify",
                itemStyle: {borderWidth: 1, borderColor: "#333"},
                lineStyle: {color: "#314656", opacity: .2, curveness: .5},
                emphasis: {label: {show: !0}, lineStyle: {opacity: .5}},
                animationEasing: "linear",
                animationDuration: 1e3
            }
        }), rz = ["itemStyle", "opacity"], sz = ["emphasis", "itemStyle", "opacity"], lz = ["lineStyle", "opacity"],
        uz = ["emphasis", "lineStyle", "opacity"], hz = xa({
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, cpx2: 0, cpy2: 0, extent: 0, orient: ""},
            buildPath: function (t, e) {
                var i = e.extent;
                t.moveTo(e.x1, e.y1), t.bezierCurveTo(e.cpx1, e.cpy1, e.cpx2, e.cpy2, e.x2, e.y2), "vertical" === e.orient ? (t.lineTo(e.x2 + i, e.y2), t.bezierCurveTo(e.cpx2 + i, e.cpy2, e.cpx1 + i, e.cpy1, e.x1 + i, e.y1)) : (t.lineTo(e.x2, e.y2 + i), t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i)), t.closePath()
            },
            highlight: function () {
                this.trigger("emphasis")
            },
            downplay: function () {
                this.trigger("normal")
            }
        });
    Wu({
        type: "sankey", _model: null, _focusAdjacencyDisabled: !1, render: function (t, e, i) {
            var n = this, o = t.getGraph(), a = this.group, r = t.layoutInfo, s = r.width, l = r.height,
                u = t.getData(), h = t.getData("edge"), c = t.get("orient");
            this._model = t, a.removeAll(), a.attr("position", [r.x, r.y]), o.eachEdge(function (e) {
                var i = new hz;
                i.dataIndex = e.dataIndex, i.seriesIndex = t.seriesIndex, i.dataType = "edge";
                var n, o, r, u, d, f, p, g, m = e.getModel("lineStyle"), v = m.get("curveness"),
                    y = e.node1.getLayout(), x = e.node1.getModel(), _ = x.get("localX"), w = x.get("localY"),
                    b = e.node2.getLayout(), S = e.node2.getModel(), M = S.get("localX"), I = S.get("localY"),
                    T = e.getLayout();
                switch (i.shape.extent = Math.max(1, T.dy), i.shape.orient = c, "vertical" === c ? (n = (null != _ ? _ * s : y.x) + T.sy, o = (null != w ? w * l : y.y) + y.dy, r = (null != M ? M * s : b.x) + T.ty, u = null != I ? I * l : b.y, d = n, f = o * (1 - v) + u * v, p = r, g = o * v + u * (1 - v)) : (n = (null != _ ? _ * s : y.x) + y.dx, o = (null != w ? w * l : y.y) + T.sy, r = null != M ? M * s : b.x, u = (null != I ? I * l : b.y) + T.ty, d = n * (1 - v) + r * v, f = o, p = n * v + r * (1 - v), g = u), i.setShape({
                    x1: n,
                    y1: o,
                    x2: r,
                    y2: u,
                    cpx1: d,
                    cpy1: f,
                    cpx2: p,
                    cpy2: g
                }), i.setStyle(m.getItemStyle()), i.style.fill) {
                    case"source":
                        i.style.fill = e.node1.getVisual("color");
                        break;
                    case"target":
                        i.style.fill = e.node2.getVisual("color")
                }
                Wa(i, e.getModel("emphasis.lineStyle").getItemStyle()), a.add(i), h.setItemGraphicEl(e.dataIndex, i)
            }), o.eachNode(function (e) {
                var i = e.getLayout(), n = e.getModel(), o = n.get("localX"), r = n.get("localY"),
                    h = n.getModel("label"), c = n.getModel("emphasis.label"), d = new CA({
                        shape: {
                            x: null != o ? o * s : i.x,
                            y: null != r ? r * l : i.y,
                            width: i.dx,
                            height: i.dy
                        }, style: n.getModel("itemStyle").getItemStyle()
                    }), f = e.getModel("emphasis.itemStyle").getItemStyle();
                Xa(d.style, f, h, c, {
                    labelFetcher: t,
                    labelDataIndex: e.dataIndex,
                    defaultText: e.id,
                    isRectText: !0
                }), d.setStyle("fill", e.getVisual("color")), Wa(d, f), a.add(d), u.setItemGraphicEl(e.dataIndex, d), d.dataType = "node"
            }), u.eachItemGraphicEl(function (e, o) {
                var a = u.getItemModel(o);
                a.get("draggable") && (e.drift = function (e, a) {
                    n._focusAdjacencyDisabled = !0, this.shape.x += e, this.shape.y += a, this.dirty(), i.dispatchAction({
                        type: "dragNode",
                        seriesId: t.id,
                        dataIndex: u.getRawIndex(o),
                        localX: this.shape.x / s,
                        localY: this.shape.y / l
                    })
                }, e.ondragend = function () {
                    n._focusAdjacencyDisabled = !1
                }, e.draggable = !0, e.cursor = "move"), e.highlight = function () {
                    this.trigger("emphasis")
                }, e.downplay = function () {
                    this.trigger("normal")
                }, e.focusNodeAdjHandler && e.off("mouseover", e.focusNodeAdjHandler), e.unfocusNodeAdjHandler && e.off("mouseout", e.unfocusNodeAdjHandler), a.get("focusNodeAdjacency") && (e.on("mouseover", e.focusNodeAdjHandler = function () {
                    n._focusAdjacencyDisabled || (n._clearTimer(), i.dispatchAction({
                        type: "focusNodeAdjacency",
                        seriesId: t.id,
                        dataIndex: e.dataIndex
                    }))
                }), e.on("mouseout", e.unfocusNodeAdjHandler = function () {
                    n._focusAdjacencyDisabled || n._dispatchUnfocus(i)
                }))
            }), h.eachItemGraphicEl(function (e, o) {
                var a = h.getItemModel(o);
                e.focusNodeAdjHandler && e.off("mouseover", e.focusNodeAdjHandler), e.unfocusNodeAdjHandler && e.off("mouseout", e.unfocusNodeAdjHandler), a.get("focusNodeAdjacency") && (e.on("mouseover", e.focusNodeAdjHandler = function () {
                    n._focusAdjacencyDisabled || (n._clearTimer(), i.dispatchAction({
                        type: "focusNodeAdjacency",
                        seriesId: t.id,
                        edgeDataIndex: e.dataIndex
                    }))
                }), e.on("mouseout", e.unfocusNodeAdjHandler = function () {
                    n._focusAdjacencyDisabled || n._dispatchUnfocus(i)
                }))
            }), !this._data && t.get("animation") && a.setClipPath(Qv(a.getBoundingRect(), t, function () {
                a.removeClipPath()
            })), this._data = t.getData()
        }, dispose: function () {
            this._clearTimer()
        }, _dispatchUnfocus: function (t) {
            var e = this;
            this._clearTimer(), this._unfocusDelayTimer = setTimeout(function () {
                e._unfocusDelayTimer = null, t.dispatchAction({type: "unfocusNodeAdjacency", seriesId: e._model.id})
            }, 500)
        }, _clearTimer: function () {
            this._unfocusDelayTimer && (clearTimeout(this._unfocusDelayTimer), this._unfocusDelayTimer = null)
        }, focusNodeAdjacency: function (t, e, i, n) {
            var o = t.getData(), a = o.graph, r = n.dataIndex, s = o.getItemModel(r), l = n.edgeDataIndex;
            if (null != r || null != l) {
                var u = a.getNodeByIndex(r), h = a.getEdgeByIndex(l);
                if (a.eachNode(function (t) {
                    $v(t, rz, .1)
                }), a.eachEdge(function (t) {
                    $v(t, lz, .1)
                }), u) {
                    Jv(u, sz);
                    var c = s.get("focusNodeAdjacency");
                    "outEdges" === c ? f(u.outEdges, function (t) {
                        t.dataIndex < 0 || (Jv(t, uz), Jv(t.node2, sz))
                    }) : "inEdges" === c ? f(u.inEdges, function (t) {
                        t.dataIndex < 0 || (Jv(t, uz), Jv(t.node1, sz))
                    }) : "allEdges" === c && f(u.edges, function (t) {
                        t.dataIndex < 0 || (Jv(t, uz), t.node1 !== u && Jv(t.node1, sz), t.node2 !== u && Jv(t.node2, sz))
                    })
                }
                h && (Jv(h, uz), Jv(h.node1, sz), Jv(h.node2, sz))
            }
        }, unfocusNodeAdjacency: function (t) {
            var e = t.getGraph();
            e.eachNode(function (t) {
                $v(t, rz)
            }), e.eachEdge(function (t) {
                $v(t, lz)
            })
        }
    }), Pu({type: "dragNode", event: "dragnode", update: "update"}, function (t, e) {
        e.eachComponent({mainType: "series", subType: "sankey", query: t}, function (e) {
            e.setNodePosition(t.dataIndex, [t.localX, t.localY])
        })
    });
    var cz = function (t, e) {
        t.eachSeriesByType("sankey", function (t) {
            var i = t.get("nodeWidth"), n = t.get("nodeGap"), o = ty(t, e);
            t.layoutInfo = o;
            var a = o.width, r = o.height, s = t.getGraph(), l = s.nodes, u = s.edges;
            iy(l);
            var h = m(l, function (t) {
                return 0 === t.getLayout().value
            }), c = 0 !== h.length ? 0 : t.get("layoutIterations"), d = t.get("orient"), f = t.get("nodeAlign");
            ey(l, u, i, n, a, r, c, d, f)
        })
    }, dz = function (t) {
        t.eachSeriesByType("sankey", function (t) {
            var e = t.getGraph(), i = e.nodes;
            if (i.length) {
                var n = 1 / 0, o = -1 / 0;
                f(i, function (t) {
                    var e = t.getLayout().value;
                    n > e && (n = e), e > o && (o = e)
                }), f(i, function (e) {
                    var i = new pE({
                        type: "color",
                        mappingMethod: "linear",
                        dataExtent: [n, o],
                        visual: t.get("color")
                    }), a = i.mapValueToVisual(e.getLayout().value), r = e.getModel().get("itemStyle.color");
                    null != r ? e.setVisual("color", r) : e.setVisual("color", a)
                })
            }
        })
    };
    Nu(cz), Ru(dz);
    var fz = function (t, e, i, n, o) {
        Zk.call(this, t, e, i), this.type = n || "value", this.position = o || "bottom", this.orient = null
    };
    fz.prototype = {
        constructor: fz, model: null, isHorizontal: function () {
            var t = this.position;
            return "top" === t || "bottom" === t
        }, pointToData: function (t, e) {
            return this.coordinateSystem.pointToData(t, e)[0]
        }, toGlobalCoord: null, toLocalCoord: null
    }, h(fz, Zk), by.prototype = {
        type: "singleAxis", axisPointerEnabled: !0, constructor: by, _init: function (t) {
            var e = this.dimension, i = new fz(e, Kh(t), [0, 0], t.get("type"), t.get("position")),
                n = "category" === i.type;
            i.onBand = n && t.get("boundaryGap"), i.inverse = t.get("inverse"), i.orient = t.get("orient"), t.axis = i, i.model = t, i.coordinateSystem = this, this._axis = i
        }, update: function (t) {
            t.eachSeries(function (t) {
                if (t.coordinateSystem === this) {
                    var e = t.getData();
                    f(e.mapDimension(this.dimension, !0), function (t) {
                        this._axis.scale.unionExtentFromData(e, t)
                    }, this), qh(this._axis.scale, this._axis.model)
                }
            }, this)
        }, resize: function (t, e) {
            this._rect = es({
                left: t.get("left"),
                top: t.get("top"),
                right: t.get("right"),
                bottom: t.get("bottom"),
                width: t.get("width"),
                height: t.get("height")
            }, {width: e.getWidth(), height: e.getHeight()}), this._adjustAxis()
        }, getRect: function () {
            return this._rect
        }, _adjustAxis: function () {
            var t = this._rect, e = this._axis, i = e.isHorizontal(), n = i ? [0, t.width] : [0, t.height],
                o = e.reverse ? 1 : 0;
            e.setExtent(n[o], n[1 - o]), this._updateAxisTransform(e, i ? t.x : t.y)
        }, _updateAxisTransform: function (t, e) {
            var i = t.getExtent(), n = i[0] + i[1], o = t.isHorizontal();
            t.toGlobalCoord = o ? function (t) {
                return t + e
            } : function (t) {
                return n - t + e
            }, t.toLocalCoord = o ? function (t) {
                return t - e
            } : function (t) {
                return n - t + e
            }
        }, getAxis: function () {
            return this._axis
        }, getBaseAxis: function () {
            return this._axis
        }, getAxes: function () {
            return [this._axis]
        }, getTooltipAxes: function () {
            return {baseAxes: [this.getAxis()]}
        }, containPoint: function (t) {
            var e = this.getRect(), i = this.getAxis(), n = i.orient;
            return "horizontal" === n ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height
        }, pointToData: function (t) {
            var e = this.getAxis();
            return [e.coordToData(e.toLocalCoord(t["horizontal" === e.orient ? 0 : 1]))]
        }, dataToPoint: function (t) {
            var e = this.getAxis(), i = this.getRect(), n = [], o = "horizontal" === e.orient ? 0 : 1;
            return t instanceof Array && (t = t[0]), n[o] = e.toGlobalCoord(e.dataToCoord(+t)), n[1 - o] = 0 === o ? i.y + i.height / 2 : i.x + i.width / 2, n
        }
    }, Ps.register("single", {create: Sy, dimensions: by.prototype.dimensions});
    var pz = ["axisLine", "axisTickLabel", "axisName"], gz = ["splitArea", "splitLine"], mz = IP.extend({
        type: "singleAxis", axisPointerClass: "SingleAxisPointer", render: function (t, e, i, n) {
            var o = this.group;
            o.removeAll();
            var a = this._axisGroup;
            this._axisGroup = new iI;
            var r = My(t), s = new yP(t, r);
            f(pz, s.add, s), o.add(this._axisGroup), o.add(s.getGroup()), f(gz, function (e) {
                t.get(e + ".show") && this["_" + e](t)
            }, this), ur(a, this._axisGroup, t), mz.superCall(this, "render", t, e, i, n)
        }, remove: function () {
            Dd(this)
        }, _splitLine: function (t) {
            var e = t.axis;
            if (!e.scale.isBlank()) {
                var i = t.getModel("splitLine"), n = i.getModel("lineStyle"), o = n.get("width"), a = n.get("color");
                a = a instanceof Array ? a : [a];
                for (var r = t.coordinateSystem.getRect(), s = e.isHorizontal(), l = [], u = 0, h = e.getTicksCoords({tickModel: i}), c = [], d = [], f = 0; f < h.length; ++f) {
                    var p = e.toGlobalCoord(h[f].coord);
                    s ? (c[0] = p, c[1] = r.y, d[0] = p, d[1] = r.y + r.height) : (c[0] = r.x, c[1] = p, d[0] = r.x + r.width, d[1] = p);
                    var g = u++ % a.length;
                    l[g] = l[g] || [], l[g].push(new kA({
                        subPixelOptimize: !0,
                        shape: {x1: c[0], y1: c[1], x2: d[0], y2: d[1]},
                        style: {lineWidth: o},
                        silent: !0
                    }))
                }
                for (var f = 0; f < l.length; ++f) this.group.add(KA(l[f], {
                    style: {
                        stroke: a[f % a.length],
                        lineDash: n.getLineDash(o),
                        lineWidth: o
                    }, silent: !0
                }))
            }
        }, _splitArea: function (t) {
            Ad(this, this._axisGroup, t, t)
        }
    }), vz = ID.extend({
        type: "singleAxis",
        layoutMode: "box",
        axis: null,
        coordinateSystem: null,
        getCoordSysModel: function () {
            return this
        }
    }), yz = {
        left: "5%",
        top: "5%",
        right: "5%",
        bottom: "5%",
        type: "value",
        position: "bottom",
        orient: "horizontal",
        axisLine: {show: !0, lineStyle: {width: 1, type: "solid"}},
        tooltip: {show: !0},
        axisTick: {show: !0, length: 6, lineStyle: {width: 1}},
        axisLabel: {show: !0, interval: "auto"},
        splitLine: {show: !0, lineStyle: {type: "dashed", opacity: .2}}
    };
    o(vz.prototype, Ck), Qk("single", vz, Iy, yz);
    var xz = function (t, e) {
        var i, n = [], o = t.seriesIndex;
        if (null == o || !(i = e.getSeriesByIndex(o))) return {point: []};
        var a = i.getData(), r = ho(a, t);
        if (null == r || 0 > r || _(r)) return {point: []};
        var s = a.getItemGraphicEl(r), l = i.coordinateSystem;
        if (i.getTooltipPosition) n = i.getTooltipPosition(r) || []; else if (l && l.dataToPoint) n = l.dataToPoint(a.getValues(p(l.dimensions, function (t) {
            return a.mapDimension(t)
        }), r, !0)) || []; else if (s) {
            var u = s.getBoundingRect().clone();
            u.applyTransform(s.transform), n = [u.x + u.width / 2, u.y + u.height / 2]
        }
        return {point: n, el: s}
    }, _z = f, wz = x, bz = co(), Sz = function (t, e, i) {
        var n = t.currTrigger, o = [t.x, t.y], a = t, r = t.dispatchAction || y(i.dispatchAction, i),
            s = e.getComponent("axisPointer").coordSysAxesInfo;
        if (s) {
            Ny(o) && (o = xz({seriesIndex: a.seriesIndex, dataIndex: a.dataIndex}, e).point);
            var l = Ny(o), u = a.axesInfo, h = s.axesInfo, c = "leave" === n || Ny(o), d = {}, f = {},
                p = {list: [], map: {}}, g = {showPointer: wz(Dy, f), showTooltip: wz(Cy, p)};
            _z(s.coordSysMap, function (t, e) {
                var i = l || t.containPoint(o);
                _z(s.coordSysAxesInfo[e], function (t) {
                    var e = t.axis, n = Oy(u, t);
                    if (!c && i && (!u || n)) {
                        var a = n && n.value;
                        null != a || l || (a = e.pointToData(o)), null != a && Ty(t, a, g, !1, d)
                    }
                })
            });
            var m = {};
            return _z(h, function (t, e) {
                var i = t.linkGroup;
                i && !f[e] && _z(i.axesInfo, function (e, n) {
                    var o = f[n];
                    if (e !== t && o) {
                        var a = o.value;
                        i.mapper && (a = t.axis.scale.parse(i.mapper(a, Ey(e), Ey(t)))), m[t.key] = a
                    }
                })
            }), _z(m, function (t, e) {
                Ty(h[e], t, g, !0, d)
            }), Ly(f, h, d), ky(p, o, t, r), Py(h, r, i), d
        }
    }, Mz = (Vu({
        type: "axisPointer",
        coordSysAxesInfo: null,
        defaultOption: {
            show: "auto",
            triggerOn: null,
            zlevel: 0,
            z: 50,
            type: "line",
            snap: !1,
            triggerTooltip: !0,
            value: null,
            status: null,
            link: [],
            animation: null,
            animationDurationUpdate: 200,
            lineStyle: {color: "#aaa", width: 1, type: "solid"},
            shadowStyle: {color: "rgba(150,150,150,0.3)"},
            label: {
                show: !0,
                formatter: null,
                precision: "auto",
                margin: 3,
                color: "#fff",
                padding: [5, 7, 5, 7],
                backgroundColor: "auto",
                borderColor: null,
                borderWidth: 0,
                shadowBlur: 3,
                shadowColor: "#aaa"
            },
            handle: {
                show: !1,
                icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
                size: 45,
                margin: 50,
                color: "#333",
                shadowBlur: 3,
                shadowColor: "#aaa",
                shadowOffsetX: 0,
                shadowOffsetY: 2,
                throttle: 40
            }
        }
    }), co()), Iz = f, Tz = Gu({
        type: "axisPointer", render: function (t, e, i) {
            var n = e.getComponent("tooltip"), o = t.get("triggerOn") || n && n.get("triggerOn") || "mousemove|click";
            Ry("axisPointer", i, function (t, e, i) {
                "none" !== o && ("leave" === t || o.indexOf(t) >= 0) && i({
                    type: "updateAxisPointer",
                    currTrigger: t,
                    x: e && e.offsetX,
                    y: e && e.offsetY
                })
            })
        }, remove: function (t, e) {
            Wy(e.getZr(), "axisPointer"), Tz.superApply(this._model, "remove", arguments)
        }, dispose: function (t, e) {
            Wy("axisPointer", e), Tz.superApply(this._model, "dispose", arguments)
        }
    }), Az = co(), Dz = n, Cz = y;
    Hy.prototype = {
        _group: null,
        _lastGraphicKey: null,
        _handle: null,
        _dragging: !1,
        _lastValue: null,
        _lastStatus: null,
        _payloadInfo: null,
        animationThreshold: 15,
        render: function (t, e, i, n) {
            var o = e.get("value"), a = e.get("status");
            if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== o || this._lastStatus !== a) {
                this._lastValue = o, this._lastStatus = a;
                var r = this._group, s = this._handle;
                if (!a || "hide" === a) return r && r.hide(), void (s && s.hide());
                r && r.show(), s && s.show();
                var l = {};
                this.makeElOption(l, o, t, e, i);
                var u = l.graphicKey;
                u !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = u;
                var h = this._moveAnimation = this.determineAnimation(t, e);
                if (r) {
                    var c = x(Zy, e, h);
                    this.updatePointerEl(r, l, c, e), this.updateLabelEl(r, l, c, e)
                } else r = this._group = new iI, this.createPointerEl(r, l, t, e), this.createLabelEl(r, l, t, e), i.getZr().add(r);
                jy(r, e, !0), this._renderHandle(o)
            }
        },
        remove: function (t) {
            this.clear(t)
        },
        dispose: function (t) {
            this.clear(t)
        },
        determineAnimation: function (t, e) {
            var i = e.get("animation"), n = t.axis, o = "category" === n.type, a = e.get("snap");
            if (!a && !o) return !1;
            if ("auto" === i || null == i) {
                var r = this.animationThreshold;
                if (o && n.getBandWidth() > r) return !0;
                if (a) {
                    var s = _d(t).seriesDataCount, l = n.getExtent();
                    return Math.abs(l[0] - l[1]) / s > r
                }
                return !1
            }
            return i === !0
        },
        makeElOption: function () {
        },
        createPointerEl: function (t, e) {
            var i = e.pointer;
            if (i) {
                var n = Az(t).pointerEl = new tD[i.type](Dz(e.pointer));
                t.add(n)
            }
        },
        createLabelEl: function (t, e, i, n) {
            if (e.label) {
                var o = Az(t).labelEl = new CA(Dz(e.label));
                t.add(o), Xy(o, n)
            }
        },
        updatePointerEl: function (t, e, i) {
            var n = Az(t).pointerEl;
            n && e.pointer && (n.setStyle(e.pointer.style), i(n, {shape: e.pointer.shape}))
        },
        updateLabelEl: function (t, e, i, n) {
            var o = Az(t).labelEl;
            o && (o.setStyle(e.label.style), i(o, {shape: e.label.shape, position: e.label.position}), Xy(o, n))
        },
        _renderHandle: function (t) {
            if (!this._dragging && this.updateHandleTransform) {
                var e = this._axisPointerModel, i = this._api.getZr(), n = this._handle, o = e.getModel("handle"),
                    a = e.get("status");
                if (!o.get("show") || !a || "hide" === a) return n && i.remove(n), void (this._handle = null);
                var r;
                this._handle || (r = !0, n = this._handle = dr(o.get("icon"), {
                    cursor: "move",
                    draggable: !0,
                    onmousemove: function (t) {
                        vM(t.event)
                    },
                    onmousedown: Cz(this._onHandleDragMove, this, 0, 0),
                    drift: Cz(this._onHandleDragMove, this),
                    ondragend: Cz(this._onHandleDragEnd, this)
                }), i.add(n)), jy(n, e, !1);
                var s = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
                n.setStyle(o.getItemStyle(null, s));
                var l = o.get("size");
                _(l) || (l = [l, l]), n.attr("scale", [l[0] / 2, l[1] / 2]), Ml(this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, r)
            }
        },
        _moveHandleToValue: function (t, e) {
            Zy(this._axisPointerModel, !e && this._moveAnimation, this._handle, Yy(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)))
        },
        _onHandleDragMove: function (t, e) {
            var i = this._handle;
            if (i) {
                this._dragging = !0;
                var n = this.updateHandleTransform(Yy(i), [t, e], this._axisModel, this._axisPointerModel);
                this._payloadInfo = n, i.stopAnimation(), i.attr(Yy(n)), Az(i).lastProp = null, this._doDispatchAxisPointer()
            }
        },
        _doDispatchAxisPointer: function () {
            var t = this._handle;
            if (t) {
                var e = this._payloadInfo, i = this._axisModel;
                this._api.dispatchAction({
                    type: "updateAxisPointer",
                    x: e.cursorPoint[0],
                    y: e.cursorPoint[1],
                    tooltipOption: e.tooltipOption,
                    axesInfo: [{axisDim: i.axis.dim, axisIndex: i.componentIndex}]
                })
            }
        },
        _onHandleDragEnd: function () {
            this._dragging = !1;
            var t = this._handle;
            if (t) {
                var e = this._axisPointerModel.get("value");
                this._moveHandleToValue(e), this._api.dispatchAction({type: "hideTip"})
            }
        },
        getHandleTransform: null,
        updateHandleTransform: null,
        clear: function (t) {
            this._lastValue = null, this._lastStatus = null;
            var e = t.getZr(), i = this._group, n = this._handle;
            e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, this._handle = null, this._payloadInfo = null)
        },
        doClear: function () {
        },
        buildLabel: function (t, e, i) {
            return i = i || 0, {x: t[i], y: t[1 - i], width: e[i], height: e[1 - i]}
        }
    }, Hy.prototype.constructor = Hy, wo(Hy);
    var Lz = Hy.extend({
        makeElOption: function (t, e, i, n, o) {
            var a = i.axis, r = a.grid, s = n.get("type"), l = ox(r, a).getOtherAxis(a).getGlobalExtent(),
                u = a.toGlobalCoord(a.dataToCoord(e, !0));
            if (s && "none" !== s) {
                var h = qy(n), c = kz[s](a, u, l);
                c.style = h, t.graphicKey = c.type, t.pointer = c
            }
            var d = Td(r.model, i);
            tx(e, t, d, i, n, o)
        }, getHandleTransform: function (t, e, i) {
            var n = Td(e.axis.grid.model, e, {labelInside: !1});
            return n.labelMargin = i.get("handle.margin"), {
                position: Qy(e.axis, t, n),
                rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
            }
        }, updateHandleTransform: function (t, e, i) {
            var n = i.axis, o = n.grid, a = n.getGlobalExtent(!0), r = ox(o, n).getOtherAxis(n).getGlobalExtent(),
                s = "x" === n.dim ? 0 : 1, l = t.position;
            l[s] += e[s], l[s] = Math.min(a[1], l[s]), l[s] = Math.max(a[0], l[s]);
            var u = (r[1] + r[0]) / 2, h = [u, u];
            h[s] = l[s];
            var c = [{verticalAlign: "middle"}, {align: "center"}];
            return {position: l, rotation: t.rotation, cursorPoint: h, tooltipOption: c[s]}
        }
    }), kz = {
        line: function (t, e, i) {
            var n = ex([e, i[0]], [e, i[1]], ax(t));
            return {type: "Line", subPixelOptimize: !0, shape: n}
        }, shadow: function (t, e, i) {
            var n = Math.max(1, t.getBandWidth()), o = i[1] - i[0];
            return {type: "Rect", shape: ix([e - n / 2, i[0]], [n, o], ax(t))}
        }
    };
    IP.registerAxisPointerClass("CartesianAxisPointer", Lz), Cu(function (t) {
        if (t) {
            (!t.axisPointer || 0 === t.axisPointer.length) && (t.axisPointer = {});
            var e = t.axisPointer.link;
            e && !_(e) && (t.axisPointer.link = [e])
        }
    }), Lu(mL.PROCESSOR.STATISTIC, function (t, e) {
        t.getComponent("axisPointer").coordSysAxesInfo = fd(t, e)
    }), Pu({type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer"}, Sz);
    var Pz = ["x", "y"], Oz = ["width", "height"], Ez = Hy.extend({
        makeElOption: function (t, e, i, n, o) {
            var a = i.axis, r = a.coordinateSystem, s = sx(r, 1 - rx(a)), l = r.dataToPoint(e)[0], u = n.get("type");
            if (u && "none" !== u) {
                var h = qy(n), c = Nz[u](a, l, s);
                c.style = h, t.graphicKey = c.type, t.pointer = c
            }
            var d = My(i);
            tx(e, t, d, i, n, o)
        }, getHandleTransform: function (t, e, i) {
            var n = My(e, {labelInside: !1});
            return n.labelMargin = i.get("handle.margin"), {
                position: Qy(e.axis, t, n),
                rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
            }
        }, updateHandleTransform: function (t, e, i) {
            var n = i.axis, o = n.coordinateSystem, a = rx(n), r = sx(o, a), s = t.position;
            s[a] += e[a], s[a] = Math.min(r[1], s[a]), s[a] = Math.max(r[0], s[a]);
            var l = sx(o, 1 - a), u = (l[1] + l[0]) / 2, h = [u, u];
            return h[a] = s[a], {
                position: s,
                rotation: t.rotation,
                cursorPoint: h,
                tooltipOption: {verticalAlign: "middle"}
            }
        }
    }), Nz = {
        line: function (t, e, i) {
            var n = ex([e, i[0]], [e, i[1]], rx(t));
            return {type: "Line", subPixelOptimize: !0, shape: n}
        }, shadow: function (t, e, i) {
            var n = t.getBandWidth(), o = i[1] - i[0];
            return {type: "Rect", shape: ix([e - n / 2, i[0]], [n, o], rx(t))}
        }
    };
    IP.registerAxisPointerClass("SingleAxisPointer", Ez), Gu({type: "single"});
    var Rz = 2, zz = dC.extend({
        type: "series.themeRiver",
        dependencies: ["singleAxis"],
        nameMap: null,
        init: function () {
            zz.superApply(this, "init", arguments), this.legendVisualProvider = new ef(y(this.getData, this), y(this.getRawData, this))
        },
        fixData: function (t) {
            var e = t.length, i = {}, n = yo(t, function (t) {
                return i.hasOwnProperty(t[0]) || (i[t[0]] = -1), t[2]
            }), o = [];
            n.buckets.each(function (t, e) {
                o.push({name: e, dataList: t})
            });
            for (var a = o.length, r = 0; a > r; ++r) {
                for (var s = o[r].name, l = 0; l < o[r].dataList.length; ++l) {
                    var u = o[r].dataList[l][0];
                    i[u] = r
                }
                for (var u in i) i.hasOwnProperty(u) && i[u] !== r && (i[u] = r, t[e] = [], t[e][0] = u, t[e][1] = 0, t[e][2] = s, e++)
            }
            return t
        },
        getInitialData: function (t, e) {
            for (var i = e.queryComponents({
                mainType: "singleAxis",
                index: this.get("singleAxisIndex"),
                id: this.get("singleAxisId")
            })[0], n = i.get("type"), o = m(t.data, function (t) {
                return void 0 !== t[2]
            }), a = this.fixData(o || []), r = [], s = this.nameMap = B(), l = 0, u = 0; u < a.length; ++u) r.push(a[u][Rz]), s.get(a[u][Rz]) || (s.set(a[u][Rz], l), l++);
            var h = JL(a, {
                coordDimensions: ["single"],
                dimensionsDefine: [{name: "time", type: $u(n)}, {name: "value", type: "float"}, {
                    name: "name",
                    type: "ordinal"
                }],
                encodeDefine: {single: 0, value: 1, itemName: 2}
            }), c = new qL(h, this);
            return c.initData(a), c
        },
        getLayerSeries: function () {
            for (var t = this.getData(), e = t.count(), i = [], n = 0; e > n; ++n) i[n] = n;
            var o = t.mapDimension("single"), a = yo(i, function (e) {
                return t.get("name", e)
            }), r = [];
            return a.buckets.each(function (e, i) {
                e.sort(function (e, i) {
                    return t.get(o, e) - t.get(o, i)
                }), r.push({name: i, indices: e})
            }), r
        },
        getAxisTooltipData: function (t, e) {
            _(t) || (t = t ? [t] : []);
            for (var i, n = this.getData(), o = this.getLayerSeries(), a = [], r = o.length, s = 0; r > s; ++s) {
                for (var l = Number.MAX_VALUE, u = -1, h = o[s].indices.length, c = 0; h > c; ++c) {
                    var d = n.get(t[0], o[s].indices[c]), f = Math.abs(d - e);
                    l >= f && (i = d, l = f, u = o[s].indices[c])
                }
                a.push(u)
            }
            return {dataIndices: a, nestestValue: i}
        },
        formatTooltip: function (t) {
            var e = this.getData(), i = e.getName(t), n = e.get(e.mapDimension("value"), t);
            return (isNaN(n) || null == n) && (n = "-"), Hr(i + " : " + n)
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "singleAxis",
            boundaryGap: ["10%", "10%"],
            singleAxisIndex: 0,
            animationEasing: "linear",
            label: {margin: 4, show: !0, position: "left", color: "#000", fontSize: 11},
            emphasis: {label: {show: !0}}
        }
    });
    Wu({
        type: "themeRiver", init: function () {
            this._layers = []
        }, render: function (t) {
            function e(t) {
                return t.name
            }

            function i(e, i, s) {
                var l = this._layers;
                if ("remove" === e) return void o.remove(l[i]);
                for (var u, h = [], d = [], f = a[i].indices, p = 0; p < f.length; p++) {
                    var g = n.getItemLayout(f[p]), m = g.x, v = g.y0, y = g.y;
                    h.push([m, v]), d.push([m, v + y]), u = n.getItemVisual(f[p], "color")
                }
                var x, _, w = n.getItemLayout(f[0]), b = n.getItemModel(f[p - 1]), S = b.getModel("label"),
                    M = S.get("margin");
                if ("add" === e) {
                    var I = c[i] = new iI;
                    x = new XP({
                        shape: {
                            points: h,
                            stackedOnPoints: d,
                            smooth: .4,
                            stackedOnSmooth: .4,
                            smoothConstraint: !1
                        }, z2: 0
                    }), _ = new vA({
                        style: {
                            x: w.x - M,
                            y: w.y0 + w.y / 2
                        }
                    }), I.add(x), I.add(_), o.add(I), x.setClipPath(lx(x.getBoundingRect(), t, function () {
                        x.removeClipPath()
                    }))
                } else {
                    var I = l[s];
                    x = I.childAt(0), _ = I.childAt(1), o.add(I), c[i] = I, or(x, {
                        shape: {
                            points: h,
                            stackedOnPoints: d
                        }
                    }, t), or(_, {style: {x: w.x - M, y: w.y0 + w.y / 2}}, t)
                }
                var T = b.getModel("emphasis.itemStyle"), A = b.getModel("itemStyle");
                ja(_.style, S, {
                    text: S.get("show") ? t.getFormattedLabel(f[p - 1], "normal") || n.getName(f[p - 1]) : null,
                    textVerticalAlign: "middle"
                }), x.setStyle(r({fill: u}, A.getItemStyle(["color"]))), Wa(x, T.getItemStyle())
            }

            var n = t.getData(), o = this.group, a = t.getLayerSeries(), s = n.getLayout("layoutInfo"), l = s.rect,
                u = s.boundaryGap;
            o.attr("position", [0, l.y + u[0]]);
            var h = new Yu(this._layersSeries || [], a, e, e), c = {};
            h.add(y(i, this, "add")).update(y(i, this, "update")).remove(y(i, this, "remove")).execute(), this._layersSeries = a, this._layers = c
        }, dispose: function () {
        }
    });
    var Bz = function (t) {
        t.eachSeriesByType("themeRiver", function (t) {
            var e = t.getData(), i = t.coordinateSystem, n = {}, o = i.getRect();
            n.rect = o;
            var a = t.get("boundaryGap"), r = i.getAxis();
            if (n.boundaryGap = a, "horizontal" === r.orient) {
                a[0] = Ir(a[0], o.height), a[1] = Ir(a[1], o.height);
                var s = o.height - a[0] - a[1];
                ux(e, t, s)
            } else {
                a[0] = Ir(a[0], o.width), a[1] = Ir(a[1], o.width);
                var l = o.width - a[0] - a[1];
                ux(e, t, l)
            }
            e.setLayout("layoutInfo", n)
        })
    }, Vz = function (t) {
        t.eachSeriesByType("themeRiver", function (t) {
            var e = t.getData(), i = t.getRawData(), n = t.get("color"), o = B();
            e.each(function (t) {
                o.set(e.getRawIndex(t), t)
            }), i.each(function (a) {
                var r = i.getName(a), s = n[(t.nameMap.get(r) - 1) % n.length];
                i.setItemVisual(a, "color", s);
                var l = o.get(a);
                null != l && e.setItemVisual(l, "color", s)
            })
        })
    };
    Nu(Bz), Ru(Vz), Lu(uO("themeRiver"));
    {
        var Gz = oP.extend({
            type: "series.pictorialBar",
            dependencies: ["grid"],
            defaultOption: {
                symbol: "circle",
                symbolSize: null,
                symbolRotate: null,
                symbolPosition: null,
                symbolOffset: null,
                symbolMargin: null,
                symbolRepeat: !1,
                symbolRepeatDirection: "end",
                symbolClip: !1,
                symbolBoundingData: null,
                symbolPatternSize: 400,
                barGap: "-100%",
                progressive: 0,
                hoverAnimation: !1
            },
            getInitialData: function (t) {
                return t.stack = null, Gz.superApply(this, "getInitialData", arguments)
            }
        }), Fz = ["itemStyle", "borderWidth"], Wz = [{xy: "x", wh: "width", index: 0, posDesc: ["left", "right"]}, {
            xy: "y",
            wh: "height",
            index: 1,
            posDesc: ["top", "bottom"]
        }], Hz = new yA;
        Wu({
            type: "pictorialBar", render: function (t, e, i) {
                var n = this.group, o = t.getData(), a = this._data, r = t.coordinateSystem, s = r.getBaseAxis(),
                    l = !!s.isHorizontal(), u = r.grid.getRect(), h = {
                        ecSize: {width: i.getWidth(), height: i.getHeight()},
                        seriesModel: t,
                        coordSys: r,
                        coordSysExtent: [[u.x, u.x + u.width], [u.y, u.y + u.height]],
                        isHorizontal: l,
                        valueDim: Wz[+l],
                        categoryDim: Wz[1 - l]
                    };
                return o.diff(a).add(function (t) {
                    if (o.hasValue(t)) {
                        var e = Sx(o, t), i = cx(o, t, e, h), a = Ax(o, h, i);
                        o.setItemGraphicEl(t, a), n.add(a), Ox(a, h, i)
                    }
                }).update(function (t, e) {
                    var i = a.getItemGraphicEl(e);
                    if (!o.hasValue(t)) return void n.remove(i);
                    var r = Sx(o, t), s = cx(o, t, r, h), l = Lx(o, s);
                    i && l !== i.__pictorialShapeStr && (n.remove(i), o.setItemGraphicEl(t, null), i = null), i ? Dx(i, h, s) : i = Ax(o, h, s, !0), o.setItemGraphicEl(t, i), i.__pictorialSymbolMeta = s, n.add(i), Ox(i, h, s)
                }).remove(function (t) {
                    var e = a.getItemGraphicEl(t);
                    e && Cx(a, t, e.__pictorialSymbolMeta.animationModel, e)
                }).execute(), this._data = o, this.group
            }, dispose: G, remove: function (t) {
                var e = this.group, i = this._data;
                t.get("animation") ? i && i.eachItemGraphicEl(function (e) {
                    Cx(i, e.dataIndex, t, e)
                }) : e.removeAll()
            }
        })
    }
    Nu(x(Wh, "pictorialBar")), Ru(YP("pictorialBar", "roundRect"));
    var Zz = function (t) {
            var e = t.grid.getRect();
            return {
                coordSys: {type: "cartesian2d", x: e.x, y: e.y, width: e.width, height: e.height},
                api: {
                    coord: function (e) {
                        return t.dataToPoint(e)
                    }, size: y(Nx, t)
                }
            }
        }, Uz = function (t) {
            var e = t.getBoundingRect();
            return {
                coordSys: {type: "geo", x: e.x, y: e.y, width: e.width, height: e.height, zoom: t.getZoom()},
                api: {
                    coord: function (e) {
                        return t.dataToPoint(e)
                    }, size: y(Rx, t)
                }
            }
        }, Xz = function (t) {
            var e = t.getRect();
            return {
                coordSys: {type: "singleAxis", x: e.x, y: e.y, width: e.width, height: e.height},
                api: {
                    coord: function (e) {
                        return t.dataToPoint(e)
                    }, size: y(zx, t)
                }
            }
        }, Yz = function (t) {
            var e = t.getRadiusAxis(), i = t.getAngleAxis(), n = e.getExtent();
            return n[0] > n[1] && n.reverse(), {
                coordSys: {type: "polar", cx: t.cx, cy: t.cy, r: n[1], r0: n[0]},
                api: {
                    coord: y(function (n) {
                        var o = e.dataToRadius(n[0]), a = i.dataToAngle(n[1]), r = t.coordToPoint([o, a]);
                        return r.push(o, a * Math.PI / 180), r
                    }), size: y(Bx, t)
                }
            }
        }, jz = function (t) {
            var e = t.getRect(), i = t.getRangeInfo();
            return {
                coordSys: {
                    type: "calendar",
                    x: e.x,
                    y: e.y,
                    width: e.width,
                    height: e.height,
                    cellWidth: t.getCellWidth(),
                    cellHeight: t.getCellHeight(),
                    rangeInfo: {start: i.start, end: i.end, weeks: i.weeks, dayCount: i.allDay}
                }, api: {
                    coord: function (e, i) {
                        return t.dataToPoint(e, i)
                    }
                }
            }
        }, qz = ZA, Kz = ["itemStyle"], $z = ["emphasis", "itemStyle"], Jz = ["label"], Qz = ["emphasis", "label"],
        tB = "e\x00\x00", eB = {cartesian2d: Zz, geo: Uz, singleAxis: Xz, polar: Yz, calendar: jz};
    dC.extend({
        type: "series.custom",
        dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            useTransform: !0,
            clip: !1
        },
        getInitialData: function () {
            return Sh(this.getSource(), this)
        },
        getDataParams: function (t, e, i) {
            var n = dC.prototype.getDataParams.apply(this, arguments);
            return i && (n.info = i.info), n
        }
    }), yl.extend({
        type: "custom", _data: null, render: function (t, e, i, n) {
            var o = this._data, a = t.getData(), r = this.group, s = Wx(t, a, e, i);
            a.diff(o).add(function (e) {
                Zx(null, e, s(e, n), t, r, a)
            }).update(function (e, i) {
                var l = o.getItemGraphicEl(i);
                Zx(l, e, s(e, n), t, r, a)
            }).remove(function (t) {
                var e = o.getItemGraphicEl(t);
                e && r.remove(e)
            }).execute();
            var l = t.get("clip", !0) ? Uc(t.coordinateSystem, !1, t) : null;
            l ? r.setClipPath(l) : r.removeClipPath(), this._data = a
        }, incrementalPrepareRender: function () {
            this.group.removeAll(), this._data = null
        }, incrementalRender: function (t, e, i, n, o) {
            function a(t) {
                t.isGroup || (t.incremental = !0, t.useHoverLayer = !0)
            }

            for (var r = e.getData(), s = Wx(e, r, i, n), l = t.start; l < t.end; l++) {
                var u = Zx(null, l, s(l, o), e, this.group, r);
                u.traverse(a)
            }
        }, dispose: G, filterForExposedEvent: function (t, e, i) {
            var n = e.element;
            if (null == n || i.name === n) return !0;
            for (; (i = i.parent) && i !== this.group;) if (i.name === n) return !0;
            return !1
        }
    }), r_.prototype = {
        constructor: r_, pointToData: function (t, e) {
            return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1]
        }, dataToRadius: Zk.prototype.dataToCoord, radiusToData: Zk.prototype.coordToData
    }, h(r_, Zk);
    var iB = co();
    s_.prototype = {
        constructor: s_,
        pointToData: function (t, e) {
            return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1]
        },
        dataToAngle: Zk.prototype.dataToCoord,
        angleToData: Zk.prototype.coordToData,
        calculateCategoryInterval: function () {
            var t = this, e = t.getLabelModel(), i = t.scale, n = i.getExtent(), o = i.count();
            if (n[1] - n[0] < 1) return 0;
            var a = n[0], r = t.dataToCoord(a + 1) - t.dataToCoord(a), s = Math.abs(r),
                l = Xi(a, e.getFont(), "center", "top"), u = Math.max(l.height, 7), h = u / s;
            isNaN(h) && (h = 1 / 0);
            var c = Math.max(0, Math.floor(h)), d = iB(t.model), f = d.lastAutoInterval, p = d.lastTickCount;
            return null != f && null != p && Math.abs(f - c) <= 1 && Math.abs(p - o) <= 1 && f > c ? c = f : (d.lastTickCount = o, d.lastAutoInterval = c), c
        }
    }, h(s_, Zk);
    var nB = function (t) {
        this.name = t || "", this.cx = 0, this.cy = 0, this._radiusAxis = new r_, this._angleAxis = new s_, this._radiusAxis.polar = this._angleAxis.polar = this
    };
    nB.prototype = {
        type: "polar",
        axisPointerEnabled: !0,
        constructor: nB,
        dimensions: ["radius", "angle"],
        model: null,
        containPoint: function (t) {
            var e = this.pointToCoord(t);
            return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1])
        },
        containData: function (t) {
            return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1])
        },
        getAxis: function (t) {
            return this["_" + t + "Axis"]
        },
        getAxes: function () {
            return [this._radiusAxis, this._angleAxis]
        },
        getAxesByScale: function (t) {
            var e = [], i = this._angleAxis, n = this._radiusAxis;
            return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e
        },
        getAngleAxis: function () {
            return this._angleAxis
        },
        getRadiusAxis: function () {
            return this._radiusAxis
        },
        getOtherAxis: function (t) {
            var e = this._angleAxis;
            return t === e ? this._radiusAxis : e
        },
        getBaseAxis: function () {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis()
        },
        getTooltipAxes: function (t) {
            var e = null != t && "auto" !== t ? this.getAxis(t) : this.getBaseAxis();
            return {baseAxes: [e], otherAxes: [this.getOtherAxis(e)]}
        },
        dataToPoint: function (t, e) {
            return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)])
        },
        pointToData: function (t, e) {
            var i = this.pointToCoord(t);
            return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)]
        },
        pointToCoord: function (t) {
            var e = t[0] - this.cx, i = t[1] - this.cy, n = this.getAngleAxis(), o = n.getExtent(),
                a = Math.min(o[0], o[1]), r = Math.max(o[0], o[1]);
            n.inverse ? a = r - 360 : r = a + 360;
            var s = Math.sqrt(e * e + i * i);
            e /= s, i /= s;
            for (var l = Math.atan2(-i, e) / Math.PI * 180, u = a > l ? 1 : -1; a > l || l > r;) l += 360 * u;
            return [s, l]
        },
        coordToPoint: function (t) {
            var e = t[0], i = t[1] / 180 * Math.PI, n = Math.cos(i) * e + this.cx, o = -Math.sin(i) * e + this.cy;
            return [n, o]
        },
        getArea: function () {
            var t = this.getAngleAxis(), e = this.getRadiusAxis(), i = e.getExtent().slice();
            i[0] > i[1] && i.reverse();
            var n = t.getExtent(), o = Math.PI / 180;
            return {
                cx: this.cx,
                cy: this.cy,
                r0: i[0],
                r: i[1],
                startAngle: -n[0] * o,
                endAngle: -n[1] * o,
                clockwise: t.inverse,
                contain: function (t, e) {
                    var i = t - this.cx, n = e - this.cy, o = i * i + n * n, a = this.r, r = this.r0;
                    return a * a >= o && o >= r * r
                }
            }
        }
    };
    var oB = ID.extend({
        type: "polarAxis", axis: null, getCoordSysModel: function () {
            return this.ecModel.queryComponents({
                mainType: "polar",
                index: this.option.polarIndex,
                id: this.option.polarId
            })[0]
        }
    });
    o(oB.prototype, Ck);
    var aB = {
        angle: {startAngle: 90, clockwise: !0, splitNumber: 12, axisLabel: {rotate: !1}},
        radius: {splitNumber: 5}
    };
    Qk("angle", oB, l_, aB.angle), Qk("radius", oB, l_, aB.radius), Vu({
        type: "polar",
        dependencies: ["polarAxis", "angleAxis"],
        coordinateSystem: null,
        findAxisModel: function (t) {
            var e, i = this.ecModel;
            return i.eachComponent(t, function (t) {
                t.getCoordSysModel() === this && (e = t)
            }, this), e
        },
        defaultOption: {zlevel: 0, z: 0, center: ["50%", "50%"], radius: "80%"}
    });
    var rB = {
        dimensions: nB.prototype.dimensions, create: function (t, e) {
            var i = [];
            return t.eachComponent("polar", function (t, n) {
                var o = new nB(n);
                o.update = h_;
                var a = o.getRadiusAxis(), r = o.getAngleAxis(), s = t.findAxisModel("radiusAxis"),
                    l = t.findAxisModel("angleAxis");
                c_(a, s), c_(r, l), u_(o, t, e), i.push(o), t.coordinateSystem = o, o.model = t
            }), t.eachSeries(function (e) {
                if ("polar" === e.get("coordinateSystem")) {
                    var i = t.queryComponents({mainType: "polar", index: e.get("polarIndex"), id: e.get("polarId")})[0];
                    if (BS && !i) throw new Error('Polar "' + D(e.get("polarIndex"), e.get("polarId"), 0) + '" not found');
                    e.coordinateSystem = i.coordinateSystem
                }
            }), i
        }
    };
    Ps.register("polar", rB);
    var sB = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
    IP.extend({
        type: "angleAxis", axisPointerClass: "PolarAxisPointer", render: function (t) {
            if (this.group.removeAll(), t.get("show")) {
                var e = t.axis, i = e.polar, o = i.getRadiusAxis().getExtent(), a = e.getTicksCoords(),
                    r = e.getMinorTicksCoords(), s = p(e.getViewLabels(), function (t) {
                        var t = n(t);
                        return t.coord = e.dataToCoord(t.tickValue), t
                    });
                p_(s), p_(a), f(sB, function (n) {
                    !t.get(n + ".show") || e.scale.isBlank() && "axisLine" !== n || this["_" + n](t, i, a, r, o, s)
                }, this)
            }
        }, _axisLine: function (t, e, i, n, o) {
            var a, r = t.getModel("axisLine.lineStyle"), s = f_(e), l = s ? 0 : 1;
            a = 0 === o[l] ? new yA({
                shape: {cx: e.cx, cy: e.cy, r: o[s]},
                style: r.getLineStyle(),
                z2: 1,
                silent: !0
            }) : new bA({
                shape: {cx: e.cx, cy: e.cy, r: o[s], r0: o[l]},
                style: r.getLineStyle(),
                z2: 1,
                silent: !0
            }), a.style.fill = null, this.group.add(a)
        }, _axisTick: function (t, e, i, n, o) {
            var a = t.getModel("axisTick"), r = (a.get("inside") ? -1 : 1) * a.get("length"), l = o[f_(e)],
                u = p(i, function (t) {
                    return new kA({shape: d_(e, [l, l + r], t.coord)})
                });
            this.group.add(KA(u, {style: s(a.getModel("lineStyle").getLineStyle(), {stroke: t.get("axisLine.lineStyle.color")})}))
        }, _minorTick: function (t, e, i, n, o) {
            if (n.length) {
                for (var a = t.getModel("axisTick"), r = t.getModel("minorTick"), l = (a.get("inside") ? -1 : 1) * r.get("length"), u = o[f_(e)], h = [], c = 0; c < n.length; c++) for (var d = 0; d < n[c].length; d++) h.push(new kA({shape: d_(e, [u, u + l], n[c][d].coord)}));
                this.group.add(KA(h, {style: s(r.getModel("lineStyle").getLineStyle(), s(a.getLineStyle(), {stroke: t.get("axisLine.lineStyle.color")}))}))
            }
        }, _axisLabel: function (t, e, i, n, o, a) {
            var r = t.getCategories(!0), s = t.getModel("axisLabel"), l = s.get("margin"), u = t.get("triggerEvent");
            f(a, function (i) {
                var n = s, a = i.tickValue, h = o[f_(e)], c = e.coordToPoint([h + l, i.coord]), d = e.cx, f = e.cy,
                    p = Math.abs(c[0] - d) / h < .3 ? "center" : c[0] > d ? "left" : "right",
                    g = Math.abs(c[1] - f) / h < .3 ? "middle" : c[1] > f ? "top" : "bottom";
                r && r[a] && r[a].textStyle && (n = new vr(r[a].textStyle, s, s.ecModel));
                var m = new vA({silent: yP.isLabelSilent(t)});
                this.group.add(m), ja(m.style, n, {
                    x: c[0],
                    y: c[1],
                    textFill: n.getTextColor() || t.get("axisLine.lineStyle.color"),
                    text: i.formattedLabel,
                    textAlign: p,
                    textVerticalAlign: g
                }), u && (m.eventData = yP.makeAxisEventDataBase(t), m.eventData.targetType = "axisLabel", m.eventData.value = i.rawLabel)
            }, this)
        }, _splitLine: function (t, e, i, n, o) {
            var a = t.getModel("splitLine"), r = a.getModel("lineStyle"), l = r.get("color"), u = 0;
            l = l instanceof Array ? l : [l];
            for (var h = [], c = 0; c < i.length; c++) {
                var d = u++ % l.length;
                h[d] = h[d] || [], h[d].push(new kA({shape: d_(e, o, i[c].coord)}))
            }
            for (var c = 0; c < h.length; c++) this.group.add(KA(h[c], {
                style: s({stroke: l[c % l.length]}, r.getLineStyle()),
                silent: !0,
                z: t.get("z")
            }))
        }, _minorSplitLine: function (t, e, i, n, o) {
            if (n.length) {
                for (var a = t.getModel("minorSplitLine"), r = a.getModel("lineStyle"), s = [], l = 0; l < n.length; l++) for (var u = 0; u < n[l].length; u++) s.push(new kA({shape: d_(e, o, n[l][u].coord)}));
                this.group.add(KA(s, {style: r.getLineStyle(), silent: !0, z: t.get("z")}))
            }
        }, _splitArea: function (t, e, i, n, o) {
            if (i.length) {
                var a = t.getModel("splitArea"), r = a.getModel("areaStyle"), l = r.get("color"), u = 0;
                l = l instanceof Array ? l : [l];
                for (var h = [], c = Math.PI / 180, d = -i[0].coord * c, f = Math.min(o[0], o[1]), p = Math.max(o[0], o[1]), g = t.get("clockwise"), m = 1; m < i.length; m++) {
                    var v = u++ % l.length;
                    h[v] = h[v] || [], h[v].push(new wA({
                        shape: {
                            cx: e.cx,
                            cy: e.cy,
                            r0: f,
                            r: p,
                            startAngle: d,
                            endAngle: -i[m].coord * c,
                            clockwise: g
                        }, silent: !0
                    })), d = -i[m].coord * c
                }
                for (var m = 0; m < h.length; m++) this.group.add(KA(h[m], {
                    style: s({fill: l[m % l.length]}, r.getAreaStyle()),
                    silent: !0
                }))
            }
        }
    });
    var lB = ["axisLine", "axisTickLabel", "axisName"], uB = ["splitLine", "splitArea", "minorSplitLine"];
    IP.extend({
        type: "radiusAxis", axisPointerClass: "PolarAxisPointer", render: function (t) {
            if (this.group.removeAll(), t.get("show")) {
                var e = t.axis, i = e.polar, n = i.getAngleAxis(), o = e.getTicksCoords(), a = e.getMinorTicksCoords(),
                    r = n.getExtent()[0], s = e.getExtent(), l = g_(i, t, r), u = new yP(t, l);
                f(lB, u.add, u), this.group.add(u.getGroup()), f(uB, function (n) {
                    t.get(n + ".show") && !e.scale.isBlank() && this["_" + n](t, i, r, s, o, a)
                }, this)
            }
        }, _splitLine: function (t, e, i, n, o) {
            var a = t.getModel("splitLine"), r = a.getModel("lineStyle"), l = r.get("color"), u = 0;
            l = l instanceof Array ? l : [l];
            for (var h = [], c = 0; c < o.length; c++) {
                var d = u++ % l.length;
                h[d] = h[d] || [], h[d].push(new yA({shape: {cx: e.cx, cy: e.cy, r: o[c].coord}}))
            }
            for (var c = 0; c < h.length; c++) this.group.add(KA(h[c], {
                style: s({
                    stroke: l[c % l.length],
                    fill: null
                }, r.getLineStyle()), silent: !0
            }))
        }, _minorSplitLine: function (t, e, i, n, o, a) {
            if (a.length) {
                for (var r = t.getModel("minorSplitLine"), l = r.getModel("lineStyle"), u = [], h = 0; h < a.length; h++) for (var c = 0; c < a[h].length; c++) u.push(new yA({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r: a[h][c].coord
                    }
                }));
                this.group.add(KA(u, {style: s({fill: null}, l.getLineStyle()), silent: !0}))
            }
        }, _splitArea: function (t, e, i, n, o) {
            if (o.length) {
                var a = t.getModel("splitArea"), r = a.getModel("areaStyle"), l = r.get("color"), u = 0;
                l = l instanceof Array ? l : [l];
                for (var h = [], c = o[0].coord, d = 1; d < o.length; d++) {
                    var f = u++ % l.length;
                    h[f] = h[f] || [], h[f].push(new wA({
                        shape: {
                            cx: e.cx,
                            cy: e.cy,
                            r0: c,
                            r: o[d].coord,
                            startAngle: 0,
                            endAngle: 2 * Math.PI
                        }, silent: !0
                    })), c = o[d].coord
                }
                for (var d = 0; d < h.length; d++) this.group.add(KA(h[d], {
                    style: s({fill: l[d % l.length]}, r.getAreaStyle()),
                    silent: !0
                }))
            }
        }
    });
    var hB = Hy.extend({
        makeElOption: function (t, e, i, n, o) {
            var a = i.axis;
            "angle" === a.dim && (this.animationThreshold = Math.PI / 18);
            var r, s = a.polar, l = s.getOtherAxis(a), u = l.getExtent();
            r = a["dataTo" + qr(a.dim)](e);
            var h = n.get("type");
            if (h && "none" !== h) {
                var c = qy(n), d = cB[h](a, s, r, u, c);
                d.style = c, t.graphicKey = d.type, t.pointer = d
            }
            var f = n.get("label.margin"), p = m_(e, i, n, s, f);
            Ky(t, i, n, o, p)
        }
    }), cB = {
        line: function (t, e, i, n) {
            return "angle" === t.dim ? {
                type: "Line",
                shape: ex(e.coordToPoint([n[0], i]), e.coordToPoint([n[1], i]))
            } : {type: "Circle", shape: {cx: e.cx, cy: e.cy, r: i}}
        }, shadow: function (t, e, i, n) {
            var o = Math.max(1, t.getBandWidth()), a = Math.PI / 180;
            return "angle" === t.dim ? {
                type: "Sector",
                shape: nx(e.cx, e.cy, n[0], n[1], (-i - o / 2) * a, (-i + o / 2) * a)
            } : {type: "Sector", shape: nx(e.cx, e.cy, i - o / 2, i + o / 2, 0, 2 * Math.PI)}
        }
    };
    IP.registerAxisPointerClass("PolarAxisPointer", hB), Nu(x(o_, "bar")), Gu({type: "polar"});
    var dB = ID.extend({
        type: "geo",
        coordinateSystem: null,
        layoutMode: "box",
        init: function (t) {
            ID.prototype.init.apply(this, arguments), io(t, "label", ["show"])
        },
        optionUpdated: function () {
            var t = this.option, e = this;
            t.regions = aN.getFilledRegions(t.regions, t.map, t.nameMap), this._optionModelMap = g(t.regions || [], function (t, i) {
                return i.name && t.set(i.name, new vr(i, e)), t
            }, B()), this.updateSelectedMap(t.regions)
        },
        defaultOption: {
            zlevel: 0,
            z: 0,
            show: !0,
            left: "center",
            top: "center",
            aspectScale: null,
            silent: !1,
            map: "",
            boundingCoords: null,
            center: null,
            zoom: 1,
            scaleLimit: null,
            label: {show: !1, color: "#000"},
            itemStyle: {borderWidth: .5, borderColor: "#444", color: "#eee"},
            emphasis: {label: {show: !0, color: "rgb(100,0,0)"}, itemStyle: {color: "rgba(255,215,0,0.8)"}},
            regions: []
        },
        getRegionModel: function (t) {
            return this._optionModelMap.get(t) || new vr(null, this, this.ecModel)
        },
        getFormattedLabel: function (t, e) {
            e = e || "normal";
            var i = this.getRegionModel(t), n = i.get(("normal" === e ? "" : e + ".") + "label.formatter"),
                o = {name: t};
            return "function" == typeof n ? (o.status = e, n(o)) : "string" == typeof n ? n.replace("{a}", null != t ? t : "") : void 0
        },
        setZoom: function (t) {
            this.option.zoom = t
        },
        setCenter: function (t) {
            this.option.center = t
        }
    });
    c(dB, QP), Gu({
        type: "geo", init: function (t, e) {
            var i = new Rg(e, !0);
            this._mapDraw = i, this.group.add(i.group)
        }, render: function (t, e, i, n) {
            if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
                var o = this._mapDraw;
                t.get("show") ? o.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(), this.group.silent = t.get("silent")
            }
        }, dispose: function () {
            this._mapDraw && this._mapDraw.remove()
        }
    }), v_("toggleSelected", {type: "geoToggleSelect", event: "geoselectchanged"}), v_("select", {
        type: "geoSelect",
        event: "geoselected"
    }), v_("unSelect", {type: "geoUnSelect", event: "geounselected"});
    var fB = 864e5;
    y_.prototype = {
        constructor: y_, type: "calendar", dimensions: ["time", "value"], getDimensionsInfo: function () {
            return [{name: "time", type: "time"}, "value"]
        }, getRangeInfo: function () {
            return this._rangeInfo
        }, getModel: function () {
            return this._model
        }, getRect: function () {
            return this._rect
        }, getCellWidth: function () {
            return this._sw
        }, getCellHeight: function () {
            return this._sh
        }, getOrient: function () {
            return this._orient
        }, getFirstDayOfWeek: function () {
            return this._firstDayOfWeek
        }, getDateInfo: function (t) {
            t = Er(t);
            var e = t.getFullYear(), i = t.getMonth() + 1;
            i = 10 > i ? "0" + i : i;
            var n = t.getDate();
            n = 10 > n ? "0" + n : n;
            var o = t.getDay();
            return o = Math.abs((o + 7 - this.getFirstDayOfWeek()) % 7), {
                y: e,
                m: i,
                d: n,
                day: o,
                time: t.getTime(),
                formatedDate: e + "-" + i + "-" + n,
                date: t
            }
        }, getNextNDay: function (t, e) {
            return e = e || 0, 0 === e ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + e), this.getDateInfo(t))
        }, update: function (t, e) {
            function i(t, e) {
                return null != t[e] && "auto" !== t[e]
            }

            this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
            var n = this._rangeInfo.weeks || 1, o = ["width", "height"], a = this._model.get("cellSize").slice(),
                r = this._model.getBoxLayoutParams(), s = "horizontal" === this._orient ? [n, 7] : [7, n];
            f([0, 1], function (t) {
                i(a, t) && (r[o[t]] = a[t] * s[t])
            });
            var l = {width: e.getWidth(), height: e.getHeight()}, u = this._rect = es(r, l);
            f([0, 1], function (t) {
                i(a, t) || (a[t] = u[o[t]] / s[t])
            }), this._sw = a[0], this._sh = a[1]
        }, dataToPoint: function (t, e) {
            _(t) && (t = t[0]), null == e && (e = !0);
            var i = this.getDateInfo(t), n = this._rangeInfo, o = i.formatedDate;
            if (e && !(i.time >= n.start.time && i.time < n.end.time + fB)) return [0 / 0, 0 / 0];
            var a = i.day, r = this._getRangeInfo([n.start.time, o]).nthWeek;
            return "vertical" === this._orient ? [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + r * this._sh + this._sh / 2] : [this._rect.x + r * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2]
        }, pointToData: function (t) {
            var e = this.pointToDate(t);
            return e && e.time
        }, dataToRect: function (t, e) {
            var i = this.dataToPoint(t, e);
            return {
                contentShape: {
                    x: i[0] - (this._sw - this._lineWidth) / 2,
                    y: i[1] - (this._sh - this._lineWidth) / 2,
                    width: this._sw - this._lineWidth,
                    height: this._sh - this._lineWidth
                },
                center: i,
                tl: [i[0] - this._sw / 2, i[1] - this._sh / 2],
                tr: [i[0] + this._sw / 2, i[1] - this._sh / 2],
                br: [i[0] + this._sw / 2, i[1] + this._sh / 2],
                bl: [i[0] - this._sw / 2, i[1] + this._sh / 2]
            }
        }, pointToDate: function (t) {
            var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1,
                i = Math.floor((t[1] - this._rect.y) / this._sh) + 1, n = this._rangeInfo.range;
            return "vertical" === this._orient ? this._getDateByWeeksAndDay(i, e - 1, n) : this._getDateByWeeksAndDay(e, i - 1, n)
        }, convertToPixel: x(x_, "dataToPoint"), convertFromPixel: x(x_, "pointToData"), _initRangeOption: function () {
            var t = this._model.get("range"), e = t;
            if (_(e) && 1 === e.length && (e = e[0]), /^\d{4}$/.test(e) && (t = [e + "-01-01", e + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(e)) {
                var i = this.getDateInfo(e), n = i.date;
                n.setMonth(n.getMonth() + 1);
                var o = this.getNextNDay(n, -1);
                t = [i.formatedDate, o.formatedDate]
            }
            /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(e) && (t = [e, e]);
            var a = this._getRangeInfo(t);
            return a.start.time > a.end.time && t.reverse(), t
        }, _getRangeInfo: function (t) {
            t = [this.getDateInfo(t[0]), this.getDateInfo(t[1])];
            var e;
            t[0].time > t[1].time && (e = !0, t.reverse());
            var i = Math.floor(t[1].time / fB) - Math.floor(t[0].time / fB) + 1, n = new Date(t[0].time),
                o = n.getDate(), a = t[1].date.getDate();
            n.setDate(o + i - 1);
            var r = n.getDate();
            if (r !== a) for (var s = n.getTime() - t[1].time > 0 ? 1 : -1; (r = n.getDate()) !== a && (n.getTime() - t[1].time) * s > 0;) i -= s, n.setDate(r - s);
            var l = Math.floor((i + t[0].day + 6) / 7), u = e ? -l + 1 : l - 1;
            return e && t.reverse(), {
                range: [t[0].formatedDate, t[1].formatedDate],
                start: t[0],
                end: t[1],
                allDay: i,
                weeks: l,
                nthWeek: u,
                fweek: t[0].day,
                lweek: t[1].day
            }
        }, _getDateByWeeksAndDay: function (t, e, i) {
            var n = this._getRangeInfo(i);
            if (t > n.weeks || 0 === t && e < n.fweek || t === n.weeks && e > n.lweek) return !1;
            var o = 7 * (t - 1) - n.fweek + e, a = new Date(n.start.time);
            return a.setDate(n.start.d + o), this.getDateInfo(a)
        }
    }, y_.dimensions = y_.prototype.dimensions, y_.getDimensionsInfo = y_.prototype.getDimensionsInfo, y_.create = function (t, e) {
        var i = [];
        return t.eachComponent("calendar", function (n) {
            var o = new y_(n, t, e);
            i.push(o), n.coordinateSystem = o
        }), t.eachSeries(function (t) {
            "calendar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("calendarIndex") || 0])
        }), i
    }, Ps.register("calendar", y_);
    var pB = ID.extend({
        type: "calendar",
        coordinateSystem: null,
        defaultOption: {
            zlevel: 0,
            z: 2,
            left: 80,
            top: 60,
            cellSize: 20,
            orient: "horizontal",
            splitLine: {show: !0, lineStyle: {color: "#000", width: 1, type: "solid"}},
            itemStyle: {color: "#fff", borderWidth: 1, borderColor: "#ccc"},
            dayLabel: {show: !0, firstDay: 0, position: "start", margin: "50%", nameMap: "en", color: "#000"},
            monthLabel: {
                show: !0,
                position: "start",
                margin: 5,
                align: "center",
                nameMap: "en",
                formatter: null,
                color: "#000"
            },
            yearLabel: {
                show: !0,
                position: null,
                margin: 30,
                formatter: null,
                color: "#ccc",
                fontFamily: "sans-serif",
                fontWeight: "bolder",
                fontSize: 20
            }
        },
        init: function (t) {
            var e = as(t);
            pB.superApply(this, "init", arguments), __(t, e)
        },
        mergeOption: function (t) {
            pB.superApply(this, "mergeOption", arguments), __(this.option, t)
        }
    }), gB = {
        EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        CN: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
    }, mB = {EN: ["S", "M", "T", "W", "T", "F", "S"], CN: ["日", "一", "二", "三", "四", "五", "六"]};
    Gu({
        type: "calendar",
        _tlpoints: null,
        _blpoints: null,
        _firstDayOfMonth: null,
        _firstDayPoints: null,
        render: function (t) {
            var e = this.group;
            e.removeAll();
            var i = t.coordinateSystem, n = i.getRangeInfo(), o = i.getOrient();
            this._renderDayRect(t, n, e), this._renderLines(t, n, o, e), this._renderYearText(t, n, o, e), this._renderMonthText(t, o, e), this._renderWeekText(t, n, o, e)
        },
        _renderDayRect: function (t, e, i) {
            for (var n = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), a = n.getCellWidth(), r = n.getCellHeight(), s = e.start.time; s <= e.end.time; s = n.getNextNDay(s, 1).time) {
                var l = n.dataToRect([s], !1).tl,
                    u = new CA({shape: {x: l[0], y: l[1], width: a, height: r}, cursor: "default", style: o});
                i.add(u)
            }
        },
        _renderLines: function (t, e, i, n) {
            function o(e) {
                a._firstDayOfMonth.push(r.getDateInfo(e)), a._firstDayPoints.push(r.dataToRect([e], !1).tl);
                var o = a._getLinePointsOfOneWeek(t, e, i);
                a._tlpoints.push(o[0]), a._blpoints.push(o[o.length - 1]), l && a._drawSplitline(o, s, n)
            }

            var a = this, r = t.coordinateSystem, s = t.getModel("splitLine.lineStyle").getLineStyle(),
                l = t.get("splitLine.show"), u = s.lineWidth;
            this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
            for (var h = e.start, c = 0; h.time <= e.end.time; c++) {
                o(h.formatedDate), 0 === c && (h = r.getDateInfo(e.start.y + "-" + e.start.m));
                var d = h.date;
                d.setMonth(d.getMonth() + 1), h = r.getDateInfo(d)
            }
            o(r.getNextNDay(e.end.time, 1).formatedDate), l && this._drawSplitline(a._getEdgesPoints(a._tlpoints, u, i), s, n), l && this._drawSplitline(a._getEdgesPoints(a._blpoints, u, i), s, n)
        },
        _getEdgesPoints: function (t, e, i) {
            var n = [t[0].slice(), t[t.length - 1].slice()], o = "horizontal" === i ? 0 : 1;
            return n[0][o] = n[0][o] - e / 2, n[1][o] = n[1][o] + e / 2, n
        },
        _drawSplitline: function (t, e, i) {
            var n = new TA({z2: 20, shape: {points: t}, style: e});
            i.add(n)
        },
        _getLinePointsOfOneWeek: function (t, e, i) {
            var n = t.coordinateSystem;
            e = n.getDateInfo(e);
            for (var o = [], a = 0; 7 > a; a++) {
                var r = n.getNextNDay(e.time, a), s = n.dataToRect([r.time], !1);
                o[2 * r.day] = s.tl, o[2 * r.day + 1] = s["horizontal" === i ? "bl" : "tr"]
            }
            return o
        },
        _formatterLabel: function (t, e) {
            return "string" == typeof t && t ? Ur(t, e) : "function" == typeof t ? t(e) : e.nameMap
        },
        _yearTextPositionControl: function (t, e, i, n, o) {
            e = e.slice();
            var a = ["center", "bottom"];
            "bottom" === n ? (e[1] += o, a = ["center", "top"]) : "left" === n ? e[0] -= o : "right" === n ? (e[0] += o, a = ["center", "top"]) : e[1] -= o;
            var r = 0;
            return ("left" === n || "right" === n) && (r = Math.PI / 2), {
                rotation: r,
                position: e,
                style: {textAlign: a[0], textVerticalAlign: a[1]}
            }
        },
        _renderYearText: function (t, e, i, n) {
            var o = t.getModel("yearLabel");
            if (o.get("show")) {
                var a = o.get("margin"), r = o.get("position");
                r || (r = "horizontal" !== i ? "top" : "left");
                var s = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], l = (s[0][0] + s[1][0]) / 2,
                    u = (s[0][1] + s[1][1]) / 2, h = "horizontal" === i ? 0 : 1,
                    c = {top: [l, s[h][1]], bottom: [l, s[1 - h][1]], left: [s[1 - h][0], u], right: [s[h][0], u]},
                    d = e.start.y;
                +e.end.y > +e.start.y && (d = d + "-" + e.end.y);
                var f = o.get("formatter"), p = {start: e.start.y, end: e.end.y, nameMap: d},
                    g = this._formatterLabel(f, p), m = new vA({z2: 30});
                ja(m.style, o, {text: g}), m.attr(this._yearTextPositionControl(m, c[r], i, r, a)), n.add(m)
            }
        },
        _monthTextPositionControl: function (t, e, i, n, o) {
            var a = "left", r = "top", s = t[0], l = t[1];
            return "horizontal" === i ? (l += o, e && (a = "center"), "start" === n && (r = "bottom")) : (s += o, e && (r = "middle"), "start" === n && (a = "right")), {
                x: s,
                y: l,
                textAlign: a,
                textVerticalAlign: r
            }
        },
        _renderMonthText: function (t, e, i) {
            var n = t.getModel("monthLabel");
            if (n.get("show")) {
                var o = n.get("nameMap"), a = n.get("margin"), s = n.get("position"), l = n.get("align"),
                    u = [this._tlpoints, this._blpoints];
                b(o) && (o = gB[o.toUpperCase()] || []);
                var h = "start" === s ? 0 : 1, c = "horizontal" === e ? 0 : 1;
                a = "start" === s ? -a : a;
                for (var d = "center" === l, f = 0; f < u[h].length - 1; f++) {
                    var p = u[h][f].slice(), g = this._firstDayOfMonth[f];
                    if (d) {
                        var m = this._firstDayPoints[f];
                        p[c] = (m[c] + u[0][f + 1][c]) / 2
                    }
                    var v = n.get("formatter"), y = o[+g.m - 1],
                        x = {yyyy: g.y, yy: (g.y + "").slice(2), MM: g.m, M: +g.m, nameMap: y},
                        _ = this._formatterLabel(v, x), w = new vA({z2: 30});
                    r(ja(w.style, n, {text: _}), this._monthTextPositionControl(p, d, e, s, a)), i.add(w)
                }
            }
        },
        _weekTextPositionControl: function (t, e, i, n, o) {
            var a = "center", r = "middle", s = t[0], l = t[1], u = "start" === i;
            return "horizontal" === e ? (s = s + n + (u ? 1 : -1) * o[0] / 2, a = u ? "right" : "left") : (l = l + n + (u ? 1 : -1) * o[1] / 2, r = u ? "bottom" : "top"), {
                x: s,
                y: l,
                textAlign: a,
                textVerticalAlign: r
            }
        },
        _renderWeekText: function (t, e, i, n) {
            var o = t.getModel("dayLabel");
            if (o.get("show")) {
                var a = t.coordinateSystem, s = o.get("position"), l = o.get("nameMap"), u = o.get("margin"),
                    h = a.getFirstDayOfWeek();
                b(l) && (l = mB[l.toUpperCase()] || []);
                var c = a.getNextNDay(e.end.time, 7 - e.lweek).time, d = [a.getCellWidth(), a.getCellHeight()];
                u = Ir(u, d["horizontal" === i ? 0 : 1]), "start" === s && (c = a.getNextNDay(e.start.time, -(7 + e.fweek)).time, u = -u);
                for (var f = 0; 7 > f; f++) {
                    var p = a.getNextNDay(c, f), g = a.dataToRect([p.time], !1).center, m = f;
                    m = Math.abs((f + h) % 7);
                    var v = new vA({z2: 30});
                    r(ja(v.style, o, {text: l[m]}), this._weekTextPositionControl(g, i, s, u, d)), n.add(v)
                }
            }
        }
    }), Vu({
        type: "title",
        layoutMode: {type: "box", ignoreSize: !0},
        defaultOption: {
            zlevel: 0,
            z: 6,
            show: !0,
            text: "",
            target: "blank",
            subtext: "",
            subtarget: "blank",
            left: 0,
            top: 0,
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            textStyle: {fontSize: 18, fontWeight: "bolder", color: "#333"},
            subtextStyle: {color: "#aaa"}
        }
    }), Gu({
        type: "title", render: function (t, e, i) {
            if (this.group.removeAll(), t.get("show")) {
                var n = this.group, o = t.getModel("textStyle"), a = t.getModel("subtextStyle"), r = t.get("textAlign"),
                    s = C(t.get("textBaseline"), t.get("textVerticalAlign")), l = new vA({
                        style: ja({}, o, {text: t.get("text"), textFill: o.getTextColor()}, {disableBox: !0}),
                        z2: 10
                    }), u = l.getBoundingRect(), h = t.get("subtext"), c = new vA({
                        style: ja({}, a, {
                            text: h,
                            textFill: a.getTextColor(),
                            y: u.height + t.get("itemGap"),
                            textVerticalAlign: "top"
                        }, {disableBox: !0}), z2: 10
                    }), d = t.get("link"), f = t.get("sublink"), p = t.get("triggerEvent", !0);
                l.silent = !d && !p, c.silent = !f && !p, d && l.on("click", function () {
                    Jr(d, "_" + t.get("target"))
                }), f && c.on("click", function () {
                    Jr(f, "_" + t.get("subtarget"))
                }), l.eventData = c.eventData = p ? {
                    componentType: "title",
                    componentIndex: t.componentIndex
                } : null, n.add(l), h && n.add(c);
                var g = n.getBoundingRect(), m = t.getBoxLayoutParams();
                m.width = g.width, m.height = g.height;
                var v = es(m, {width: i.getWidth(), height: i.getHeight()}, t.get("padding"));
                r || (r = t.get("left") || t.get("right"), "middle" === r && (r = "center"), "right" === r ? v.x += v.width : "center" === r && (v.x += v.width / 2)), s || (s = t.get("top") || t.get("bottom"), "center" === s && (s = "middle"), "bottom" === s ? v.y += v.height : "middle" === s && (v.y += v.height / 2), s = s || "top"), n.attr("position", [v.x, v.y]);
                var y = {textAlign: r, textVerticalAlign: s};
                l.setStyle(y), c.setStyle(y), g = n.getBoundingRect();
                var x = v.margin, _ = t.getItemStyle(["color", "opacity"]);
                _.fill = t.get("backgroundColor");
                var w = new CA({
                    shape: {
                        x: g.x - x[3],
                        y: g.y - x[0],
                        width: g.width + x[1] + x[3],
                        height: g.height + x[0] + x[2],
                        r: t.get("borderRadius")
                    }, style: _, subPixelOptimize: !0, silent: !0
                });
                n.add(w)
            }
        }
    });
    var vB = MC.legend.selector,
        yB = {all: {type: "all", title: n(vB.all)}, inverse: {type: "inverse", title: n(vB.inverse)}}, xB = Vu({
            type: "legend.plain",
            dependencies: ["series"],
            layoutMode: {type: "box", ignoreSize: !0},
            init: function (t, e, i) {
                this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t)
            },
            mergeOption: function (t) {
                xB.superCall(this, "mergeOption", t), this._updateSelector(t)
            },
            _updateSelector: function (t) {
                var e = t.selector;
                e === !0 && (e = t.selector = ["all", "inverse"]), _(e) && f(e, function (t, i) {
                    b(t) && (t = {type: t}), e[i] = o(t, yB[t.type])
                })
            },
            optionUpdated: function () {
                this._updateData(this.ecModel);
                var t = this._data;
                if (t[0] && "single" === this.get("selectedMode")) {
                    for (var e = !1, i = 0; i < t.length; i++) {
                        var n = t[i].get("name");
                        if (this.isSelected(n)) {
                            this.select(n), e = !0;
                            break
                        }
                    }
                    !e && this.select(t[0].get("name"))
                }
            },
            _updateData: function (t) {
                var e = [], i = [];
                t.eachRawSeries(function (n) {
                    var o = n.name;
                    i.push(o);
                    var a;
                    if (n.legendVisualProvider) {
                        var r = n.legendVisualProvider, s = r.getAllNames();
                        t.isSeriesFiltered(n) || (i = i.concat(s)), s.length ? e = e.concat(s) : a = !0
                    } else a = !0;
                    a && so(n) && e.push(n.name)
                }), this._availableNames = i;
                var n = this.get("data") || e, o = p(n, function (t) {
                    return ("string" == typeof t || "number" == typeof t) && (t = {name: t}), new vr(t, this, this.ecModel)
                }, this);
                this._data = o
            },
            getData: function () {
                return this._data
            },
            select: function (t) {
                var e = this.option.selected, i = this.get("selectedMode");
                if ("single" === i) {
                    var n = this._data;
                    f(n, function (t) {
                        e[t.get("name")] = !1
                    })
                }
                e[t] = !0
            },
            unSelect: function (t) {
                "single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
            },
            toggleSelected: function (t) {
                var e = this.option.selected;
                e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
            },
            allSelect: function () {
                var t = this._data, e = this.option.selected;
                f(t, function (t) {
                    e[t.get("name", !0)] = !0
                })
            },
            inverseSelect: function () {
                var t = this._data, e = this.option.selected;
                f(t, function (t) {
                    var i = t.get("name", !0);
                    e.hasOwnProperty(i) || (e[i] = !0), e[i] = !e[i]
                })
            },
            isSelected: function (t) {
                var e = this.option.selected;
                return !(e.hasOwnProperty(t) && !e[t]) && u(this._availableNames, t) >= 0
            },
            getOrient: function () {
                return "vertical" === this.get("orient") ? {index: 1, name: "vertical"} : {index: 0, name: "horizontal"}
            },
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                orient: "horizontal",
                left: "center",
                top: 0,
                align: "auto",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderRadius: 0,
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                itemWidth: 25,
                itemHeight: 14,
                inactiveColor: "#ccc",
                inactiveBorderColor: "#ccc",
                itemStyle: {borderWidth: 0},
                textStyle: {color: "#333"},
                selectedMode: !0,
                selector: !1,
                selectorLabel: {
                    show: !0,
                    borderRadius: 10,
                    padding: [3, 5, 3, 5],
                    fontSize: 12,
                    fontFamily: " sans-serif",
                    color: "#666",
                    borderWidth: 1,
                    borderColor: "#666"
                },
                emphasis: {selectorLabel: {show: !0, color: "#eee", backgroundColor: "#666"}},
                selectorPosition: "auto",
                selectorItemGap: 7,
                selectorButtonGap: 10,
                tooltip: {show: !1}
            }
        });
    Pu("legendToggleSelect", "legendselectchanged", x(w_, "toggleSelected")), Pu("legendAllSelect", "legendselectall", x(w_, "allSelect")), Pu("legendInverseSelect", "legendinverseselect", x(w_, "inverseSelect")), Pu("legendSelect", "legendselected", x(w_, "select")), Pu("legendUnSelect", "legendunselected", x(w_, "unSelect"));
    var _B = x, wB = f, bB = iI, SB = Gu({
        type: "legend.plain", newlineDisabled: !1, init: function () {
            this.group.add(this._contentGroup = new bB), this._backgroundEl, this.group.add(this._selectorGroup = new bB), this._isFirstRender = !0
        }, getContentGroup: function () {
            return this._contentGroup
        }, getSelectorGroup: function () {
            return this._selectorGroup
        }, render: function (t, e, i) {
            var n = this._isFirstRender;
            if (this._isFirstRender = !1, this.resetInner(), t.get("show", !0)) {
                var o = t.get("align"), a = t.get("orient");
                o && "auto" !== o || (o = "right" === t.get("left") && "vertical" === a ? "right" : "left");
                var r = t.get("selector", !0), l = t.get("selectorPosition", !0);
                !r || l && "auto" !== l || (l = "horizontal" === a ? "end" : "start"), this.renderInner(o, t, e, i, r, a, l);
                var u = t.getBoxLayoutParams(), h = {width: i.getWidth(), height: i.getHeight()}, c = t.get("padding"),
                    d = es(u, h, c), f = this.layoutInner(t, o, d, n, r, l),
                    p = es(s({width: f.width, height: f.height}, u), h, c);
                this.group.attr("position", [p.x - f.x, p.y - f.y]), this.group.add(this._backgroundEl = S_(f, t))
            }
        }, resetInner: function () {
            this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll()
        }, renderInner: function (t, e, i, n, o, a, r) {
            var s = this.getContentGroup(), l = B(), u = e.get("selectedMode"), h = [];
            i.eachRawSeries(function (t) {
                !t.get("legendHoverLink") && h.push(t.id)
            }), wB(e.getData(), function (o, a) {
                var r = o.get("name");
                if (!this.newlineDisabled && ("" === r || "\n" === r)) return void s.add(new bB({newline: !0}));
                var c = i.getSeriesByName(r)[0];
                if (!l.get(r)) {
                    if (c) {
                        var d = c.getData(), f = d.getVisual("color"), p = d.getVisual("borderColor");
                        "function" == typeof f && (f = f(c.getDataParams(0))), "function" == typeof p && (p = p(c.getDataParams(0)));
                        var g = d.getVisual("legendSymbol") || "roundRect", m = d.getVisual("symbol"),
                            v = this._createItem(r, a, o, e, g, m, t, f, p, u);
                        v.on("click", _B(I_, r, null, n, h)).on("mouseover", _B(T_, c.name, null, n, h)).on("mouseout", _B(A_, c.name, null, n, h)), l.set(r, !0)
                    } else i.eachRawSeries(function (i) {
                        if (!l.get(r) && i.legendVisualProvider) {
                            var s = i.legendVisualProvider;
                            if (!s.containName(r)) return;
                            var c = s.indexOfName(r), d = s.getItemVisual(c, "color"),
                                f = s.getItemVisual(c, "borderColor"), p = "roundRect",
                                g = this._createItem(r, a, o, e, p, null, t, d, f, u);
                            g.on("click", _B(I_, null, r, n, h)).on("mouseover", _B(T_, null, r, n, h)).on("mouseout", _B(A_, null, r, n, h)), l.set(r, !0)
                        }
                    }, this);
                    BS && (l.get(r) || console.warn(r + " series not exists. Legend data should be same with series name or data name."))
                }
            }, this), o && this._createSelector(o, e, n, a, r)
        }, _createSelector: function (t, e, i) {
            function n(t) {
                var n = t.type, a = new vA({
                    style: {x: 0, y: 0, align: "center", verticalAlign: "middle"}, onclick: function () {
                        i.dispatchAction({type: "all" === n ? "legendAllSelect" : "legendInverseSelect"})
                    }
                });
                o.add(a);
                var r = e.getModel("selectorLabel"), s = e.getModel("emphasis.selectorLabel");
                Xa(a.style, a.hoverStyle = {}, r, s, {defaultText: t.title, isRectText: !1}), Wa(a)
            }

            var o = this.getSelectorGroup();
            wB(t, function (t) {
                n(t)
            })
        }, _createItem: function (t, e, i, n, o, a, s, l, u, h) {
            var c = n.get("itemWidth"), d = n.get("itemHeight"), f = n.get("inactiveColor"),
                p = n.get("inactiveBorderColor"), g = n.get("symbolKeepAspect"), m = n.getModel("itemStyle"),
                v = n.isSelected(t), y = new bB, x = i.getModel("textStyle"), _ = i.get("icon"),
                w = i.getModel("tooltip"), b = w.parentModel;
            o = _ || o;
            var S = ac(o, 0, 0, c, d, v ? l : f, null == g ? !0 : g);
            if (y.add(M_(S, o, m, u, p, v)), !_ && a && (a !== o || "none" === a)) {
                var M = .8 * d;
                "none" === a && (a = "circle");
                var I = ac(a, (c - M) / 2, (d - M) / 2, M, M, v ? l : f, null == g ? !0 : g);
                y.add(M_(I, a, m, u, p, v))
            }
            var T = "left" === s ? c + 5 : -5, A = s, D = n.get("formatter"), C = t;
            "string" == typeof D && D ? C = D.replace("{name}", null != t ? t : "") : "function" == typeof D && (C = D(t)), y.add(new vA({
                style: ja({}, x, {
                    text: C,
                    x: T,
                    y: d / 2,
                    textFill: v ? x.getTextColor() : f,
                    textAlign: A,
                    textVerticalAlign: "middle"
                })
            }));
            var L = new CA({
                shape: y.getBoundingRect(),
                invisible: !0,
                tooltip: w.get("show") ? r({
                    content: t,
                    formatter: b.get("formatter", !0) || function () {
                        return t
                    },
                    formatterParams: {componentType: "legend", legendIndex: n.componentIndex, name: t, $vars: ["name"]}
                }, w.option) : null
            });
            return y.add(L), y.eachChild(function (t) {
                t.silent = !0
            }), L.silent = !h, this.getContentGroup().add(y), Wa(y), y.__legendDataIndex = e, y
        }, layoutInner: function (t, e, i, n, o, a) {
            var r = this.getContentGroup(), s = this.getSelectorGroup();
            bD(t.get("orient"), r, t.get("itemGap"), i.width, i.height);
            var l = r.getBoundingRect(), u = [-l.x, -l.y];
            if (o) {
                bD("horizontal", s, t.get("selectorItemGap", !0));
                var h = s.getBoundingRect(), c = [-h.x, -h.y], d = t.get("selectorButtonGap", !0),
                    f = t.getOrient().index, p = 0 === f ? "width" : "height", g = 0 === f ? "height" : "width",
                    m = 0 === f ? "y" : "x";
                "end" === a ? c[f] += l[p] + d : u[f] += h[p] + d, c[1 - f] += l[g] / 2 - h[g] / 2, s.attr("position", c), r.attr("position", u);
                var v = {x: 0, y: 0};
                return v[p] = l[p] + d + h[p], v[g] = Math.max(l[g], h[g]), v[m] = Math.min(0, h[m] + c[1 - f]), v
            }
            return r.attr("position", u), this.group.getBoundingRect()
        }, remove: function () {
            this.getContentGroup().removeAll(), this._isFirstRender = !0
        }
    }), MB = function (t) {
        var e = t.findComponents({mainType: "legend"});
        e && e.length && t.filterSeries(function (t) {
            for (var i = 0; i < e.length; i++) if (!e[i].isSelected(t.name)) return !1;
            return !0
        })
    };
    Lu(mL.PROCESSOR.SERIES_FILTER, MB), ID.registerSubTypeDefaulter("legend", function () {
        return "plain"
    });
    var IB = xB.extend({
        type: "legend.scroll",
        setScrollDataIndex: function (t) {
            this.option.scrollDataIndex = t
        },
        defaultOption: {
            scrollDataIndex: 0,
            pageButtonItemGap: 5,
            pageButtonGap: null,
            pageButtonPosition: "end",
            pageFormatter: "{current}/{total}",
            pageIcons: {
                horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
                vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
            },
            pageIconColor: "#2f4554",
            pageIconInactiveColor: "#aaa",
            pageIconSize: 15,
            pageTextStyle: {color: "#333"},
            animationDurationUpdate: 800
        },
        init: function (t, e, i, n) {
            var o = as(t);
            IB.superCall(this, "init", t, e, i, n), D_(this, t, o)
        },
        mergeOption: function (t, e) {
            IB.superCall(this, "mergeOption", t, e), D_(this, this.option, t)
        }
    }), TB = iI, AB = ["width", "height"], DB = ["x", "y"], CB = SB.extend({
        type: "legend.scroll", newlineDisabled: !0, init: function () {
            CB.superCall(this, "init"), this._currentIndex = 0, this.group.add(this._containerGroup = new TB), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new TB), this._showController
        }, resetInner: function () {
            CB.superCall(this, "resetInner"), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null
        }, renderInner: function (t, e, i, n, o, a, r) {
            function s(t, i) {
                var o = t + "DataIndex",
                    a = dr(e.get("pageIcons", !0)[e.getOrient().name][i], {onclick: y(l._pageGo, l, o, e, n)}, {
                        x: -h[0] / 2,
                        y: -h[1] / 2,
                        width: h[0],
                        height: h[1]
                    });
                a.name = t, u.add(a)
            }

            var l = this;
            CB.superCall(this, "renderInner", t, e, i, n, o, a, r);
            var u = this._controllerGroup, h = e.get("pageIconSize", !0);
            _(h) || (h = [h, h]), s("pagePrev", 0);
            var c = e.getModel("pageTextStyle");
            u.add(new vA({
                name: "pageText",
                style: {
                    textFill: c.getTextColor(),
                    font: c.getFont(),
                    textVerticalAlign: "middle",
                    textAlign: "center"
                },
                silent: !0
            })), s("pageNext", 1)
        }, layoutInner: function (t, e, i, o, a, r) {
            var s = this.getSelectorGroup(), l = t.getOrient().index, u = AB[l], h = DB[l], c = AB[1 - l],
                d = DB[1 - l];
            a && bD("horizontal", s, t.get("selectorItemGap", !0));
            var f = t.get("selectorButtonGap", !0), p = s.getBoundingRect(), g = [-p.x, -p.y], m = n(i);
            a && (m[u] = i[u] - p[u] - f);
            var v = this._layoutContentAndController(t, o, m, l, u, c, d);
            if (a) {
                if ("end" === r) g[l] += v[u] + f; else {
                    var y = p[u] + f;
                    g[l] -= y, v[h] -= y
                }
                v[u] += p[u] + f, g[1 - l] += v[d] + v[c] / 2 - p[c] / 2, v[c] = Math.max(v[c], p[c]), v[d] = Math.min(v[d], p[d] + g[1 - l]), s.attr("position", g)
            }
            return v
        }, _layoutContentAndController: function (t, e, i, n, o, a, r) {
            var s = this.getContentGroup(), l = this._containerGroup, u = this._controllerGroup;
            bD(t.get("orient"), s, t.get("itemGap"), n ? i.width : null, n ? null : i.height), bD("horizontal", u, t.get("pageButtonItemGap", !0));
            var h = s.getBoundingRect(), c = u.getBoundingRect(), d = this._showController = h[o] > i[o],
                f = [-h.x, -h.y];
            e || (f[n] = s.position[n]);
            var p = [0, 0], g = [-c.x, -c.y], m = C(t.get("pageButtonGap", !0), t.get("itemGap", !0));
            if (d) {
                var v = t.get("pageButtonPosition", !0);
                "end" === v ? g[n] += i[o] - c[o] : p[n] += c[o] + m
            }
            g[1 - n] += h[a] / 2 - c[a] / 2, s.attr("position", f), l.attr("position", p), u.attr("position", g);
            var y = {x: 0, y: 0};
            if (y[o] = d ? i[o] : h[o], y[a] = Math.max(h[a], c[a]), y[r] = Math.min(0, c[r] + g[1 - n]), l.__rectSize = i[o], d) {
                var x = {x: 0, y: 0};
                x[o] = Math.max(i[o] - c[o] - m, 0), x[a] = y[a], l.setClipPath(new CA({shape: x})), l.__rectSize = x[o]
            } else u.eachChild(function (t) {
                t.attr({invisible: !0, silent: !0})
            });
            var _ = this._getPageInfo(t);
            return null != _.pageIndex && or(s, {position: _.contentPosition}, d ? t : !1), this._updatePageInfoView(t, _), y
        }, _pageGo: function (t, e, i) {
            var n = this._getPageInfo(e)[t];
            null != n && i.dispatchAction({type: "legendScroll", scrollDataIndex: n, legendId: e.id})
        }, _updatePageInfoView: function (t, e) {
            var i = this._controllerGroup;
            f(["pagePrev", "pageNext"], function (n) {
                var o = null != e[n + "DataIndex"], a = i.childOfName(n);
                a && (a.setStyle("fill", o ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), a.cursor = o ? "pointer" : "default")
            });
            var n = i.childOfName("pageText"), o = t.get("pageFormatter"), a = e.pageIndex, r = null != a ? a + 1 : 0,
                s = e.pageCount;
            n && o && n.setStyle("text", b(o) ? o.replace("{current}", r).replace("{total}", s) : o({
                current: r,
                total: s
            }))
        }, _getPageInfo: function (t) {
            function e(t) {
                if (t) {
                    var e = t.getBoundingRect(), i = e[l] + t.position[r];
                    return {s: i, e: i + e[s], i: t.__legendDataIndex}
                }
            }

            function i(t, e) {
                return t.e >= e && t.s <= e + a
            }

            var n = t.get("scrollDataIndex", !0), o = this.getContentGroup(), a = this._containerGroup.__rectSize,
                r = t.getOrient().index, s = AB[r], l = DB[r], u = this._findTargetItemIndex(n), h = o.children(),
                c = h[u], d = h.length, f = d ? 1 : 0, p = {
                    contentPosition: o.position.slice(),
                    pageCount: f,
                    pageIndex: f - 1,
                    pagePrevDataIndex: null,
                    pageNextDataIndex: null
                };
            if (!c) return p;
            var g = e(c);
            p.contentPosition[r] = -g.s;
            for (var m = u + 1, v = g, y = g, x = null; d >= m; ++m) x = e(h[m]), (!x && y.e > v.s + a || x && !i(x, v.s)) && (v = y.i > v.i ? y : x, v && (null == p.pageNextDataIndex && (p.pageNextDataIndex = v.i), ++p.pageCount)), y = x;
            for (var m = u - 1, v = g, y = g, x = null; m >= -1; --m) x = e(h[m]), x && i(y, x.s) || !(v.i < y.i) || (y = v, null == p.pagePrevDataIndex && (p.pagePrevDataIndex = v.i), ++p.pageCount, ++p.pageIndex), v = x;
            return p
        }, _findTargetItemIndex: function (t) {
            if (!this._showController) return 0;
            var e, i, n = this.getContentGroup();
            return n.eachChild(function (n, o) {
                var a = n.__legendDataIndex;
                null == i && null != a && (i = o), a === t && (e = o)
            }), null != e ? e : i
        }
    });
    Pu("legendScroll", "legendscroll", function (t, e) {
        var i = t.scrollDataIndex;
        null != i && e.eachComponent({mainType: "legend", subType: "scroll", query: t}, function (t) {
            t.setScrollDataIndex(i)
        })
    }), Vu({
        type: "tooltip",
        dependencies: ["axisPointer"],
        defaultOption: {
            zlevel: 0,
            z: 60,
            show: !0,
            showContent: !0,
            trigger: "item",
            triggerOn: "mousemove|click",
            alwaysShowContent: !1,
            displayMode: "single",
            renderMode: "auto",
            confine: !1,
            showDelay: 0,
            hideDelay: 100,
            transitionDuration: .4,
            enterable: !1,
            backgroundColor: "rgba(50,50,50,0.7)",
            borderColor: "#333",
            borderRadius: 4,
            borderWidth: 0,
            padding: 5,
            extraCssText: "",
            axisPointer: {
                type: "line",
                axis: "auto",
                animation: "auto",
                animationDurationUpdate: 200,
                animationEasingUpdate: "exponentialOut",
                crossStyle: {color: "#999", width: 1, type: "dashed", textStyle: {}}
            },
            textStyle: {color: "#fff", fontSize: 14}
        }
    });
    var LB = f, kB = Wr, PB = ["", "-webkit-", "-moz-", "-o-"],
        OB = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
    O_.prototype = {
        constructor: O_, _enterable: !0, update: function (t) {
            var e = this._container, i = e.currentStyle || document.defaultView.getComputedStyle(e), n = e.style;
            "absolute" !== n.position && "absolute" !== i.position && (n.position = "relative");
            var o = t.get("alwaysShowContent");
            o && this._moveTooltipIfResized()
        }, _moveTooltipIfResized: function () {
            var t = this._styleCoord[2], e = this._styleCoord[3], i = t * this._zr.getWidth(),
                n = e * this._zr.getHeight();
            this.moveTo(i, n)
        }, show: function (t) {
            clearTimeout(this._hideTimeout);
            var e = this.el, i = this._styleCoord;
            e.style.cssText = OB + k_(t) + ";left:" + i[0] + "px;top:" + i[1] + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", e.style.pointerEvents = this._enterable ? "auto" : "none", this._show = !0
        }, setContent: function (t) {
            this.el.innerHTML = null == t ? "" : t
        }, setEnterable: function (t) {
            this._enterable = t
        }, getSize: function () {
            var t = this.el;
            return [t.clientWidth, t.clientHeight]
        }, moveTo: function (t, e) {
            var i = this._styleCoord;
            P_(i, this._zr, this._appendToBody, t, e);
            var n = this.el.style;
            n.left = i[0] + "px", n.top = i[1] + "px"
        }, hide: function () {
            this.el.style.display = "none", this._show = !1
        }, hideLater: function (t) {
            !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide())
        }, isShow: function () {
            return this._show
        }, dispose: function () {
            this.el.parentNode.removeChild(this.el)
        }, getOuterSize: function () {
            var t = this.el.clientWidth, e = this.el.clientHeight;
            if (document.defaultView && document.defaultView.getComputedStyle) {
                var i = document.defaultView.getComputedStyle(this.el);
                i && (t += parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10), e += parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10))
            }
            return {width: t, height: e}
        }
    }, N_.prototype = {
        constructor: N_, _enterable: !0, update: function (t) {
            var e = t.get("alwaysShowContent");
            e && this._moveTooltipIfResized()
        }, _moveTooltipIfResized: function () {
            var t = this._styleCoord[2], e = this._styleCoord[3], i = t * this._zr.getWidth(),
                n = e * this._zr.getHeight();
            this.moveTo(i, n)
        }, show: function () {
            this._hideTimeout && clearTimeout(this._hideTimeout), this.el.attr("show", !0), this._show = !0
        }, setContent: function (t, e, i) {
            this.el && this._zr.remove(this.el);
            for (var n = {}, o = t, a = "{marker", r = "|}", s = o.indexOf(a); s >= 0;) {
                var l = o.indexOf(r), u = o.substr(s + a.length, l - s - a.length);
                n["marker" + u] = u.indexOf("sub") > -1 ? {
                    textWidth: 4,
                    textHeight: 4,
                    textBorderRadius: 2,
                    textBackgroundColor: e[u],
                    textOffset: [3, 0]
                } : {
                    textWidth: 10,
                    textHeight: 10,
                    textBorderRadius: 5,
                    textBackgroundColor: e[u]
                }, o = o.substr(l + 1), s = o.indexOf("{marker")
            }
            var h = i.getModel("textStyle"), c = h.get("fontSize"), d = i.get("textLineHeight");
            null == d && (d = Math.round(3 * c / 2)), this.el = new vA({
                style: ja({}, h, {
                    rich: n,
                    text: t,
                    textBackgroundColor: i.get("backgroundColor"),
                    textBorderRadius: i.get("borderRadius"),
                    textFill: i.get("textStyle.color"),
                    textPadding: i.get("padding"),
                    textLineHeight: d
                }), z: i.get("z")
            }), this._zr.add(this.el);
            var f = this;
            this.el.on("mouseover", function () {
                f._enterable && (clearTimeout(f._hideTimeout), f._show = !0), f._inContent = !0
            }), this.el.on("mouseout", function () {
                f._enterable && f._show && f.hideLater(f._hideDelay), f._inContent = !1
            })
        }, setEnterable: function (t) {
            this._enterable = t
        }, getSize: function () {
            var t = this.el.getBoundingRect();
            return [t.width, t.height]
        }, moveTo: function (t, e) {
            if (this.el) {
                var i = this._styleCoord;
                E_(i, this._zr, t, e), this.el.attr("position", [i[0], i[1]])
            }
        }, hide: function () {
            this.el && this.el.hide(), this._show = !1
        }, hideLater: function (t) {
            !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide())
        }, isShow: function () {
            return this._show
        }, dispose: function () {
            clearTimeout(this._hideTimeout), this.el && this._zr.remove(this.el)
        }, getOuterSize: function () {
            var t = this.getSize();
            return {width: t[0], height: t[1]}
        }
    };
    var EB = y, NB = f, RB = Ir, zB = new CA({shape: {x: -1, y: -1, width: 2, height: 2}});
    Gu({
        type: "tooltip", init: function (t, e) {
            if (!WS.node) {
                var i = t.getComponent("tooltip"), n = i.get("renderMode");
                this._renderMode = vo(n);
                var o;
                "html" === this._renderMode ? (o = new O_(e.getDom(), e, {appendToBody: i.get("appendToBody", !0)}), this._newLine = "<br/>") : (o = new N_(e), this._newLine = "\n"), this._tooltipContent = o
            }
        }, render: function (t, e, i) {
            if (!WS.node) {
                this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent");
                var n = this._tooltipContent;
                n.update(t), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow()
            }
        }, _initGlobalListener: function () {
            var t = this._tooltipModel, e = t.get("triggerOn");
            Ry("itemTooltip", this._api, EB(function (t, i, n) {
                "none" !== e && (e.indexOf(t) >= 0 ? this._tryShow(i, n) : "leave" === t && this._hide(n))
            }, this))
        }, _keepShow: function () {
            var t = this._tooltipModel, e = this._ecModel, i = this._api;
            if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) {
                var n = this;
                clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
                    !i.isDisposed() && n.manuallyShowTip(t, e, i, {x: n._lastX, y: n._lastY})
                })
            }
        }, manuallyShowTip: function (t, e, i, n) {
            if (n.from !== this.uid && !WS.node) {
                var o = z_(n, i);
                this._ticket = "";
                var a = n.dataByCoordSys;
                if (n.tooltip && null != n.x && null != n.y) {
                    var r = zB;
                    r.position = [n.x, n.y], r.update(), r.tooltip = n.tooltip, this._tryShow({
                        offsetX: n.x,
                        offsetY: n.y,
                        target: r
                    }, o)
                } else if (a) this._tryShow({
                    offsetX: n.x,
                    offsetY: n.y,
                    position: n.position,
                    dataByCoordSys: n.dataByCoordSys,
                    tooltipOption: n.tooltipOption
                }, o); else if (null != n.seriesIndex) {
                    if (this._manuallyAxisShowTip(t, e, i, n)) return;
                    var s = xz(n, e), l = s.point[0], u = s.point[1];
                    null != l && null != u && this._tryShow({
                        offsetX: l,
                        offsetY: u,
                        position: n.position,
                        target: s.el
                    }, o)
                } else null != n.x && null != n.y && (i.dispatchAction({
                    type: "updateAxisPointer",
                    x: n.x,
                    y: n.y
                }), this._tryShow({
                    offsetX: n.x,
                    offsetY: n.y,
                    position: n.position,
                    target: i.getZr().findHover(n.x, n.y).target
                }, o))
            }
        }, manuallyHideTip: function (t, e, i, n) {
            var o = this._tooltipContent;
            !this._alwaysShowContent && this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = null, n.from !== this.uid && this._hide(z_(n, i))
        }, _manuallyAxisShowTip: function (t, e, i, n) {
            var o = n.seriesIndex, a = n.dataIndex, r = e.getComponent("axisPointer").coordSysAxesInfo;
            if (null != o && null != a && null != r) {
                var s = e.getSeriesByIndex(o);
                if (s) {
                    var l = s.getData(), t = R_([l.getItemModel(a), s, (s.coordinateSystem || {}).model, t]);
                    if ("axis" === t.get("trigger")) return i.dispatchAction({
                        type: "updateAxisPointer",
                        seriesIndex: o,
                        dataIndex: a,
                        position: n.position
                    }), !0
                }
            }
        }, _tryShow: function (t, e) {
            var i = t.target, n = this._tooltipModel;
            if (n) {
                this._lastX = t.offsetX, this._lastY = t.offsetY;
                var o = t.dataByCoordSys;
                o && o.length ? this._showAxisTooltip(o, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e))
            }
        }, _showOrMove: function (t, e) {
            var i = t.get("showDelay");
            e = y(e, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(e, i) : e()
        }, _showAxisTooltip: function (t, e) {
            var i = this._ecModel, n = this._tooltipModel, a = [e.offsetX, e.offsetY], r = [], s = [],
                l = R_([e.tooltipOption, n]), u = this._renderMode, h = this._newLine, c = {};
            NB(t, function (t) {
                NB(t.dataByAxis, function (t) {
                    var e = i.getComponent(t.axisDim + "Axis", t.axisIndex), n = t.value, a = [];
                    if (e && null != n) {
                        var l = Jy(n, e.axis, i, t.seriesDataIndices, t.valueLabelOpt);
                        f(t.seriesDataIndices, function (r) {
                            var h = i.getSeriesByIndex(r.seriesIndex), d = r.dataIndexInside,
                                f = h && h.getDataParams(d);
                            if (f.axisDim = t.axisDim, f.axisIndex = t.axisIndex, f.axisType = t.axisType, f.axisId = t.axisId, f.axisValue = Qh(e.axis, n), f.axisValueLabel = l, f) {
                                s.push(f);
                                var p, g = h.formatTooltip(d, !0, null, u);
                                if (S(g)) {
                                    p = g.html;
                                    var m = g.markers;
                                    o(c, m)
                                } else p = g;
                                a.push(p)
                            }
                        });
                        var d = l;
                        r.push("html" !== u ? a.join(h) : (d ? Hr(d) + h : "") + a.join(h))
                    }
                })
            }, this), r.reverse(), r = r.join(this._newLine + this._newLine);
            var d = e.position;
            this._showOrMove(l, function () {
                this._updateContentNotChangedOnAxis(t) ? this._updatePosition(l, d, a[0], a[1], this._tooltipContent, s) : this._showTooltipContent(l, r, s, Math.random(), a[0], a[1], d, void 0, c)
            })
        }, _showSeriesItemTooltip: function (t, e, i) {
            var n = this._ecModel, o = e.seriesIndex, a = n.getSeriesByIndex(o), r = e.dataModel || a, s = e.dataIndex,
                l = e.dataType, u = r.getData(l),
                h = R_([u.getItemModel(s), r, a && (a.coordinateSystem || {}).model, this._tooltipModel]),
                c = h.get("trigger");
            if (null == c || "item" === c) {
                var d, f, p = r.getDataParams(s, l), g = r.formatTooltip(s, !1, l, this._renderMode);
                S(g) ? (d = g.html, f = g.markers) : (d = g, f = null);
                var m = "item_" + r.name + "_" + s;
                this._showOrMove(h, function () {
                    this._showTooltipContent(h, d, p, m, t.offsetX, t.offsetY, t.position, t.target, f)
                }), i({
                    type: "showTip",
                    dataIndexInside: s,
                    dataIndex: u.getRawIndex(s),
                    seriesIndex: o,
                    from: this.uid
                })
            }
        }, _showComponentItemTooltip: function (t, e, i) {
            var n = e.tooltip;
            if ("string" == typeof n) {
                var o = n;
                n = {content: o, formatter: o}
            }
            var a = new vr(n, this._tooltipModel, this._ecModel), r = a.get("content"), s = Math.random();
            this._showOrMove(a, function () {
                this._showTooltipContent(a, r, a.get("formatterParams") || {}, s, t.offsetX, t.offsetY, t.position, e)
            }), i({type: "showTip", from: this.uid})
        }, _showTooltipContent: function (t, e, i, n, o, a, r, s, l) {
            if (this._ticket = "", t.get("showContent") && t.get("show")) {
                var u = this._tooltipContent, h = t.get("formatter");
                r = r || t.get("position");
                var c = e;
                if (h && "string" == typeof h) c = Zr(h, i, !0); else if ("function" == typeof h) {
                    var d = EB(function (e, n) {
                        e === this._ticket && (u.setContent(n, l, t), this._updatePosition(t, r, o, a, u, i, s))
                    }, this);
                    this._ticket = n, c = h(i, n, d)
                }
                u.setContent(c, l, t), u.show(t), this._updatePosition(t, r, o, a, u, i, s)
            }
        }, _updatePosition: function (t, e, i, n, o, a, r) {
            var s = this._api.getWidth(), l = this._api.getHeight();
            e = e || t.get("position");
            var u = o.getSize(), h = t.get("align"), c = t.get("verticalAlign"), d = r && r.getBoundingRect().clone();
            if (r && d.applyTransform(r.transform), "function" == typeof e && (e = e([i, n], a, o.el, d, {
                viewSize: [s, l],
                contentSize: u.slice()
            })), _(e)) i = RB(e[0], s), n = RB(e[1], l); else if (S(e)) {
                e.width = u[0], e.height = u[1];
                var f = es(e, {width: s, height: l});
                i = f.x, n = f.y, h = null, c = null
            } else if ("string" == typeof e && r) {
                var p = G_(e, d, u);
                i = p[0], n = p[1]
            } else {
                var p = B_(i, n, o, s, l, h ? null : 20, c ? null : 20);
                i = p[0], n = p[1]
            }
            if (h && (i -= F_(h) ? u[0] / 2 : "right" === h ? u[0] : 0), c && (n -= F_(c) ? u[1] / 2 : "bottom" === c ? u[1] : 0), t.get("confine")) {
                var p = V_(i, n, o, s, l);
                i = p[0], n = p[1]
            }
            o.moveTo(i, n)
        }, _updateContentNotChangedOnAxis: function (t) {
            var e = this._lastDataByCoordSys, i = !!e && e.length === t.length;
            return i && NB(e, function (e, n) {
                var o = e.dataByAxis || {}, a = t[n] || {}, r = a.dataByAxis || [];
                i &= o.length === r.length, i && NB(o, function (t, e) {
                    var n = r[e] || {}, o = t.seriesDataIndices || [], a = n.seriesDataIndices || [];
                    i &= t.value === n.value && t.axisType === n.axisType && t.axisId === n.axisId && o.length === a.length, i && NB(o, function (t, e) {
                        var n = a[e];
                        i &= t.seriesIndex === n.seriesIndex && t.dataIndex === n.dataIndex
                    })
                })
            }), this._lastDataByCoordSys = t, !!i
        }, _hide: function (t) {
            this._lastDataByCoordSys = null, t({type: "hideTip", from: this.uid})
        }, dispose: function (t, e) {
            WS.node || (this._tooltipContent.dispose(), Wy("itemTooltip", e))
        }
    }), Pu({type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip"}, function () {
    }), Pu({type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip"}, function () {
    });
    var BB = Fr, VB = Hr, GB = Vu({
        type: "marker", dependencies: ["series", "grid", "polar", "geo"], init: function (t, e, i) {
            if (BS && "marker" === this.type) throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
            this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, !1, !0)
        }, isAnimationEnabled: function () {
            if (WS.node) return !1;
            var t = this.__hostSeries;
            return this.getShallow("animation") && t && t.isAnimationEnabled()
        }, mergeOption: function (t, e) {
            this._mergeOption(t, e, !1, !1)
        }, _mergeOption: function (t, e, i, n) {
            var o = this.constructor, a = this.mainType + "Model";
            i || e.eachSeries(function (t) {
                var i = t.get(this.mainType, !0), s = t[a];
                return i && i.data ? (s ? s._mergeOption(i, e, !0) : (n && W_(i), f(i.data, function (t) {
                    t instanceof Array ? (W_(t[0]), W_(t[1])) : W_(t)
                }), s = new o(i, this, e), r(s, {
                    mainType: this.mainType,
                    seriesIndex: t.seriesIndex,
                    name: t.name,
                    createdBySelf: !0
                }), s.__hostSeries = t), void (t[a] = s)) : void (t[a] = null)
            }, this)
        }, formatTooltip: function (t, e, i, n) {
            var o = this.getData(), a = this.getRawValue(t), r = _(a) ? p(a, BB).join(", ") : BB(a), s = o.getName(t),
                l = VB(this.name), u = "html" === n ? "<br/>" : "\n";
            return (null != a || s) && (l += u), s && (l += VB(s), null != a && (l += " : ")), null != a && (l += VB(r)), l
        }, getData: function () {
            return this._data
        }, setData: function (t) {
            this._data = t
        }
    });
    c(GB, lC), GB.extend({
        type: "markPoint",
        defaultOption: {
            zlevel: 0,
            z: 5,
            symbol: "pin",
            symbolSize: 50,
            tooltip: {trigger: "item"},
            label: {show: !0, position: "inside"},
            itemStyle: {borderWidth: 2},
            emphasis: {label: {show: !0}}
        }
    });
    var FB = u, WB = x, HB = {min: WB(U_, "min"), max: WB(U_, "max"), average: WB(U_, "average")}, ZB = Gu({
        type: "marker", init: function () {
            this.markerGroupMap = B()
        }, render: function (t, e, i) {
            var n = this.markerGroupMap;
            n.each(function (t) {
                t.__keep = !1
            });
            var o = this.type + "Model";
            e.eachSeries(function (t) {
                var n = t[o];
                n && this.renderSeries(t, n, e, i)
            }, this), n.each(function (t) {
                !t.__keep && this.group.remove(t.group)
            }, this)
        }, renderSeries: function () {
        }
    });
    ZB.extend({
        type: "markPoint", updateTransform: function (t, e, i) {
            e.eachSeries(function (t) {
                var e = t.markPointModel;
                e && (J_(e.getData(), t, i), this.markerGroupMap.get(t.id).updateLayout(e))
            }, this)
        }, renderSeries: function (t, e, i, n) {
            var o = t.coordinateSystem, a = t.id, r = t.getData(), s = this.markerGroupMap,
                l = s.get(a) || s.set(a, new Od), u = Q_(o, t, e);
            e.setData(u), J_(e.getData(), t, n), u.each(function (t) {
                var i = u.getItemModel(t), n = i.getShallow("symbol"), o = i.getShallow("symbolSize"),
                    a = i.getShallow("symbolRotate"), s = w(n), l = w(o), h = w(a);
                if (s || l || h) {
                    var c = e.getRawValue(t), d = e.getDataParams(t);
                    s && (n = n(c, d)), l && (o = o(c, d)), h && (a = a(c, d))
                }
                u.setItemVisual(t, {
                    symbol: n,
                    symbolSize: o,
                    symbolRotate: a,
                    color: i.get("itemStyle.color") || r.getVisual("color")
                })
            }), l.updateData(u), this.group.add(l.group), u.eachItemGraphicEl(function (t) {
                t.traverse(function (t) {
                    t.dataModel = e
                })
            }), l.__keep = !0, l.group.silent = e.get("silent") || t.get("silent")
        }
    }), Cu(function (t) {
        t.markPoint = t.markPoint || {}
    }), GB.extend({
        type: "markLine",
        defaultOption: {
            zlevel: 0,
            z: 5,
            symbol: ["circle", "arrow"],
            symbolSize: [8, 16],
            precision: 2,
            tooltip: {trigger: "item"},
            label: {show: !0, position: "end", distance: 5},
            lineStyle: {type: "dashed"},
            emphasis: {label: {show: !0}, lineStyle: {width: 3}},
            animationEasing: "linear"
        }
    });
    var UB = function (t, e, i, a) {
        var s = t.getData(), l = a.type;
        if (!_(a) && ("min" === l || "max" === l || "average" === l || "median" === l || null != a.xAxis || null != a.yAxis)) {
            var u, h;
            if (null != a.yAxis || null != a.xAxis) u = e.getAxis(null != a.yAxis ? "y" : "x"), h = D(a.yAxis, a.xAxis); else {
                var c = Y_(a, s, e, t);
                u = c.valueAxis;
                var d = bh(s, c.valueDataDim);
                h = $_(s, d, l)
            }
            var f = "x" === u.dim ? 0 : 1, p = 1 - f, g = n(a), m = {};
            g.type = null, g.coord = [], m.coord = [], g.coord[p] = -1 / 0, m.coord[p] = 1 / 0;
            var v = i.get("precision");
            v >= 0 && "number" == typeof h && (h = +h.toFixed(Math.min(v, 20))), g.coord[f] = m.coord[f] = h, a = [g, m, {
                type: l,
                valueIndex: a.valueIndex,
                value: h
            }]
        }
        return a = [X_(t, a[0]), X_(t, a[1]), r({}, a[2])], a[2].type = a[2].type || "", o(a[2], a[0]), o(a[2], a[1]), a
    };
    ZB.extend({
        type: "markLine", updateTransform: function (t, e, i) {
            e.eachSeries(function (t) {
                var e = t.markLineModel;
                if (e) {
                    var n = e.getData(), o = e.__from, a = e.__to;
                    o.each(function (e) {
                        nw(o, e, !0, t, i), nw(a, e, !1, t, i)
                    }), n.each(function (t) {
                        n.setItemLayout(t, [o.getItemLayout(t), a.getItemLayout(t)])
                    }), this.markerGroupMap.get(t.id).updateLayout()
                }
            }, this)
        }, renderSeries: function (t, e, i, n) {
            function o(e, i, o) {
                var a = e.getItemModel(i);
                nw(e, i, o, t, n), e.setItemVisual(i, {
                    symbolRotate: a.get("symbolRotate"),
                    symbolSize: a.get("symbolSize") || g[o ? 0 : 1],
                    symbol: a.get("symbol", !0) || p[o ? 0 : 1],
                    color: a.get("itemStyle.color") || s.getVisual("color")
                })
            }

            var a = t.coordinateSystem, r = t.id, s = t.getData(), l = this.markerGroupMap,
                u = l.get(r) || l.set(r, new Jg);
            this.group.add(u.group);
            var h = ow(a, t, e), c = h.from, d = h.to, f = h.line;
            e.__from = c, e.__to = d, e.setData(f);
            var p = e.get("symbol"), g = e.get("symbolSize");
            _(p) || (p = [p, p]), "number" == typeof g && (g = [g, g]), h.from.each(function (t) {
                o(c, t, !0), o(d, t, !1)
            }), f.each(function (t) {
                var e = f.getItemModel(t).get("lineStyle.color");
                f.setItemVisual(t, {color: e || c.getItemVisual(t, "color")}), f.setItemLayout(t, [c.getItemLayout(t), d.getItemLayout(t)]), f.setItemVisual(t, {
                    fromSymbolRotate: c.getItemVisual(t, "symbolRotate"),
                    fromSymbolSize: c.getItemVisual(t, "symbolSize"),
                    fromSymbol: c.getItemVisual(t, "symbol"),
                    toSymbolRotate: d.getItemVisual(t, "symbolRotate"),
                    toSymbolSize: d.getItemVisual(t, "symbolSize"),
                    toSymbol: d.getItemVisual(t, "symbol")
                })
            }), u.updateData(f), h.line.eachItemGraphicEl(function (t) {
                t.traverse(function (t) {
                    t.dataModel = e
                })
            }), u.__keep = !0, u.group.silent = e.get("silent") || t.get("silent")
        }
    }), Cu(function (t) {
        t.markLine = t.markLine || {}
    }), GB.extend({
        type: "markArea",
        defaultOption: {
            zlevel: 0,
            z: 1,
            tooltip: {trigger: "item"},
            animation: !1,
            label: {show: !0, position: "top"},
            itemStyle: {borderWidth: 0},
            emphasis: {label: {show: !0, position: "top"}}
        }
    });
    var XB = function (t, e, i, n) {
        var o = X_(t, n[0]), r = X_(t, n[1]), s = D, l = o.coord, u = r.coord;
        l[0] = s(l[0], -1 / 0), l[1] = s(l[1], -1 / 0), u[0] = s(u[0], 1 / 0), u[1] = s(u[1], 1 / 0);
        var h = a([{}, o, r]);
        return h.coord = [o.coord, r.coord], h.x0 = o.x, h.y0 = o.y, h.x1 = r.x, h.y1 = r.y, h
    }, YB = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
    ZB.extend({
        type: "markArea", updateTransform: function (t, e, i) {
            e.eachSeries(function (t) {
                var e = t.markAreaModel;
                if (e) {
                    var n = e.getData();
                    n.each(function (e) {
                        var o = p(YB, function (o) {
                            return lw(n, e, o, t, i)
                        });
                        n.setItemLayout(e, o);
                        var a = n.getItemGraphicEl(e);
                        a.setShape("points", o)
                    })
                }
            }, this)
        }, renderSeries: function (t, e, i, n) {
            var o = t.coordinateSystem, a = t.id, r = t.getData(), l = this.markerGroupMap,
                u = l.get(a) || l.set(a, {group: new iI});
            this.group.add(u.group), u.__keep = !0;
            var h = uw(o, t, e);
            e.setData(h), h.each(function (e) {
                var i = p(YB, function (i) {
                    return lw(h, e, i, t, n)
                }), a = !0;
                f(YB, function (t) {
                    if (a) {
                        var i = h.get(t[0], e), n = h.get(t[1], e);
                        (aw(i) || o.getAxis("x").containData(i)) && (aw(n) || o.getAxis("y").containData(n)) && (a = !1)
                    }
                }), h.setItemLayout(e, {points: i, allClipped: a}), h.setItemVisual(e, {color: r.getVisual("color")})
            }), h.diff(u.__data).add(function (t) {
                var e = h.getItemLayout(t);
                if (!e.allClipped) {
                    var i = new IA({shape: {points: e.points}});
                    h.setItemGraphicEl(t, i), u.group.add(i)
                }
            }).update(function (t, i) {
                var n = u.__data.getItemGraphicEl(i), o = h.getItemLayout(t);
                o.allClipped ? n && u.group.remove(n) : (n ? or(n, {shape: {points: o.points}}, e, t) : n = new IA({shape: {points: o.points}}), h.setItemGraphicEl(t, n), u.group.add(n))
            }).remove(function (t) {
                var e = u.__data.getItemGraphicEl(t);
                u.group.remove(e)
            }).execute(), h.eachItemGraphicEl(function (t, i) {
                var n = h.getItemModel(i), o = n.getModel("label"), a = n.getModel("emphasis.label"),
                    r = h.getItemVisual(i, "color");
                t.useStyle(s(n.getModel("itemStyle").getItemStyle(), {
                    fill: li(r, .4),
                    stroke: r
                })), t.hoverStyle = n.getModel("emphasis.itemStyle").getItemStyle(), Xa(t.style, t.hoverStyle, o, a, {
                    labelFetcher: e,
                    labelDataIndex: i,
                    defaultText: h.getName(i) || "",
                    isRectText: !0,
                    autoColor: r
                }), Wa(t, {}), t.dataModel = e
            }), u.__data = h, u.group.silent = e.get("silent") || t.get("silent")
        }
    }), Cu(function (t) {
        t.markArea = t.markArea || {}
    });
    var jB = function (t) {
        var e = t && t.timeline;
        _(e) || (e = e ? [e] : []), f(e, function (t) {
            t && hw(t)
        })
    };
    ID.registerSubTypeDefaulter("timeline", function () {
        return "slider"
    }), Pu({type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate"}, function (t, e) {
        var i = e.getComponent("timeline");
        return i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)), e.resetOption("timeline"), s({currentIndex: i.option.currentIndex}, t)
    }), Pu({type: "timelinePlayChange", event: "timelinePlayChanged", update: "update"}, function (t, e) {
        var i = e.getComponent("timeline");
        i && null != t.playState && i.setPlayState(t.playState)
    });
    var qB = ID.extend({
        type: "timeline",
        layoutMode: "box",
        defaultOption: {
            zlevel: 0,
            z: 4,
            show: !0,
            axisType: "time",
            realtime: !0,
            left: "20%",
            top: null,
            right: "20%",
            bottom: 0,
            width: null,
            height: 40,
            padding: 5,
            controlPosition: "left",
            autoPlay: !1,
            rewind: !1,
            loop: !0,
            playInterval: 2e3,
            currentIndex: 0,
            itemStyle: {},
            label: {color: "#000"},
            data: []
        },
        init: function (t, e, i) {
            this._data, this._names, this.mergeDefaultAndTheme(t, i), this._initData()
        },
        mergeOption: function () {
            qB.superApply(this, "mergeOption", arguments), this._initData()
        },
        setCurrentIndex: function (t) {
            null == t && (t = this.option.currentIndex);
            var e = this._data.count();
            this.option.loop ? t = (t % e + e) % e : (t >= e && (t = e - 1), 0 > t && (t = 0)), this.option.currentIndex = t
        },
        getCurrentIndex: function () {
            return this.option.currentIndex
        },
        isIndexMax: function () {
            return this.getCurrentIndex() >= this._data.count() - 1
        },
        setPlayState: function (t) {
            this.option.autoPlay = !!t
        },
        getPlayState: function () {
            return !!this.option.autoPlay
        },
        _initData: function () {
            var t = this.option, e = t.data || [], i = t.axisType, o = this._names = [];
            if ("category" === i) {
                var a = [];
                f(e, function (t, e) {
                    var i, r = no(t);
                    S(t) ? (i = n(t), i.value = e) : i = e, a.push(i), b(r) || null != r && !isNaN(r) || (r = ""), o.push(r + "")
                }), e = a
            }
            var r = {category: "ordinal", time: "time"}[i] || "number",
                s = this._data = new qL([{name: "value", type: r}], this);
            s.initData(e, o)
        },
        getData: function () {
            return this._data
        },
        getCategories: function () {
            return "category" === this.get("axisType") ? this._names.slice() : void 0
        }
    }), KB = qB.extend({
        type: "timeline.slider", defaultOption: {
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderWidth: 0,
            orient: "horizontal",
            inverse: !1,
            tooltip: {trigger: "item"},
            symbol: "emptyCircle",
            symbolSize: 10,
            lineStyle: {show: !0, width: 2, color: "#304654"},
            label: {position: "auto", show: !0, interval: "auto", rotate: 0, color: "#304654"},
            itemStyle: {color: "#304654", borderWidth: 1},
            checkpointStyle: {
                symbol: "circle",
                symbolSize: 13,
                color: "#c23531",
                borderWidth: 5,
                borderColor: "rgba(194,53,49, 0.5)",
                animation: !0,
                animationDuration: 300,
                animationEasing: "quinticInOut"
            },
            controlStyle: {
                show: !0,
                showPlayBtn: !0,
                showPrevBtn: !0,
                showNextBtn: !0,
                itemSize: 22,
                itemGap: 12,
                position: "left",
                playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
                prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
                color: "#304654",
                borderColor: "#304654",
                borderWidth: 1
            },
            emphasis: {
                label: {show: !0, color: "#c23531"},
                itemStyle: {color: "#c23531"},
                controlStyle: {color: "#c23531", borderColor: "#c23531", borderWidth: 2}
            },
            data: []
        }
    });
    c(KB, lC);
    var $B = fC.extend({type: "timeline"}), JB = function (t, e, i, n) {
        Zk.call(this, t, e, i), this.type = n || "value", this.model = null
    };
    JB.prototype = {
        constructor: JB, getLabelModel: function () {
            return this.model.getModel("label")
        }, isHorizontal: function () {
            return "horizontal" === this.model.get("orient")
        }
    }, h(JB, Zk);
    var QB = y, tV = f, eV = Math.PI;
    $B.extend({
        type: "timeline.slider", init: function (t, e) {
            this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup
        }, render: function (t, e, i) {
            if (this.model = t, this.api = i, this.ecModel = e, this.group.removeAll(), t.get("show", !0)) {
                var n = this._layout(t, i), o = this._createGroup("mainGroup"), a = this._createGroup("labelGroup"),
                    r = this._axis = this._createAxis(n, t);
                t.formatTooltip = function (t) {
                    return Hr(r.scale.getLabel(t))
                }, tV(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (e) {
                    this["_render" + e](n, o, r, t)
                }, this), this._renderAxisLabel(n, a, r, t), this._position(n, t)
            }
            this._doPlayStop()
        }, remove: function () {
            this._clearTimer(), this.group.removeAll()
        }, dispose: function () {
            this._clearTimer()
        }, _layout: function (t, e) {
            var i = t.get("label.position"), n = t.get("orient"), o = fw(t, e);
            null == i || "auto" === i ? i = "horizontal" === n ? o.y + o.height / 2 < e.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(i) && (i = {
                horizontal: {
                    top: "-",
                    bottom: "+"
                }, vertical: {left: "-", right: "+"}
            }[n][i]);
            var a = {horizontal: "center", vertical: i >= 0 || "+" === i ? "left" : "right"},
                r = {horizontal: i >= 0 || "+" === i ? "top" : "bottom", vertical: "middle"},
                s = {horizontal: 0, vertical: eV / 2}, l = "vertical" === n ? o.height : o.width,
                u = t.getModel("controlStyle"), h = u.get("show", !0), c = h ? u.get("itemSize") : 0,
                d = h ? u.get("itemGap") : 0, f = c + d, p = t.get("label.rotate") || 0;
            p = p * eV / 180;
            var g, m, v, y, x = u.get("position", !0), _ = h && u.get("showPlayBtn", !0),
                w = h && u.get("showPrevBtn", !0), b = h && u.get("showNextBtn", !0), S = 0, M = l;
            return "left" === x || "bottom" === x ? (_ && (g = [0, 0], S += f), w && (m = [S, 0], S += f), b && (v = [M - c, 0], M -= f)) : (_ && (g = [M - c, 0], M -= f), w && (m = [0, 0], S += f), b && (v = [M - c, 0], M -= f)), y = [S, M], t.get("inverse") && y.reverse(), {
                viewRect: o,
                mainLength: l,
                orient: n,
                rotation: s[n],
                labelRotation: p,
                labelPosOpt: i,
                labelAlign: t.get("label.align") || a[n],
                labelBaseline: t.get("label.verticalAlign") || t.get("label.baseline") || r[n],
                playPosition: g,
                prevBtnPosition: m,
                nextBtnPosition: v,
                axisExtent: y,
                controlSize: c,
                controlGap: d
            }
        }, _position: function (t) {
            function e(t) {
                var e = t.position;
                t.origin = [h[0][0] - e[0], h[1][0] - e[1]]
            }

            function i(t) {
                return [[t.x, t.x + t.width], [t.y, t.y + t.height]]
            }

            function n(t, e, i, n, o) {
                t[n] += i[n][o] - e[n][o]
            }

            var o = this._mainGroup, a = this._labelGroup, r = t.viewRect;
            if ("vertical" === t.orient) {
                var s = Oe(), l = r.x, u = r.y + r.height;
                ze(s, s, [-l, -u]), Be(s, s, -eV / 2), ze(s, s, [l, u]), r = r.clone(), r.applyTransform(s)
            }
            var h = i(r), c = i(o.getBoundingRect()), d = i(a.getBoundingRect()), f = o.position, p = a.position;
            p[0] = f[0] = h[0][0];
            var g = t.labelPosOpt;
            if (isNaN(g)) {
                var m = "+" === g ? 0 : 1;
                n(f, c, h, 1, m), n(p, d, h, 1, 1 - m)
            } else {
                var m = g >= 0 ? 0 : 1;
                n(f, c, h, 1, m), p[1] = f[1] + g
            }
            o.attr("position", f), a.attr("position", p), o.rotation = a.rotation = t.rotation, e(o), e(a)
        }, _createAxis: function (t, e) {
            var i = e.getData(), n = e.get("axisType"), o = Kh(e, n);
            o.getTicks = function () {
                return i.mapArray(["value"], function (t) {
                    return t
                })
            };
            var a = i.getDataExtent("value");
            o.setExtent(a[0], a[1]), o.niceTicks();
            var r = new JB("value", o, t.axisExtent, n);
            return r.model = e, r
        }, _createGroup: function (t) {
            var e = this["_" + t] = new iI;
            return this.group.add(e), e
        }, _renderAxisLine: function (t, e, i, n) {
            var o = i.getExtent();
            n.get("lineStyle.show") && e.add(new kA({
                shape: {x1: o[0], y1: 0, x2: o[1], y2: 0},
                style: r({lineCap: "round"}, n.getModel("lineStyle").getLineStyle()),
                silent: !0,
                z2: 1
            }))
        }, _renderAxisTick: function (t, e, i, n) {
            var o = n.getData(), a = i.scale.getTicks();
            tV(a, function (t) {
                var a = i.dataToCoord(t), r = o.getItemModel(t), s = r.getModel("itemStyle"),
                    l = r.getModel("emphasis.itemStyle"),
                    u = {position: [a, 0], onclick: QB(this._changeTimeline, this, t)}, h = gw(r, s, e, u);
                Wa(h, l.getItemStyle()), r.get("tooltip") ? (h.dataIndex = t, h.dataModel = n) : h.dataIndex = h.dataModel = null
            }, this)
        }, _renderAxisLabel: function (t, e, i, n) {
            var o = i.getLabelModel();
            if (o.get("show")) {
                var a = n.getData(), r = i.getViewLabels();
                tV(r, function (n) {
                    var o = n.tickValue, r = a.getItemModel(o), s = r.getModel("label"),
                        l = r.getModel("emphasis.label"), u = i.dataToCoord(n.tickValue), h = new vA({
                            position: [u, 0],
                            rotation: t.labelRotation - t.rotation,
                            onclick: QB(this._changeTimeline, this, o),
                            silent: !1
                        });
                    ja(h.style, s, {
                        text: n.formattedLabel,
                        textAlign: t.labelAlign,
                        textVerticalAlign: t.labelBaseline
                    }), e.add(h), Wa(h, ja({}, l))
                }, this)
            }
        }, _renderControl: function (t, e, i, n) {
            function o(t, i, o, h) {
                if (t) {
                    var c = {
                        position: t,
                        origin: [a / 2, 0],
                        rotation: h ? -r : 0,
                        rectHover: !0,
                        style: s,
                        onclick: o
                    }, d = pw(n, i, u, c);
                    e.add(d), Wa(d, l)
                }
            }

            var a = t.controlSize, r = t.rotation, s = n.getModel("controlStyle").getItemStyle(),
                l = n.getModel("emphasis.controlStyle").getItemStyle(), u = [0, -a / 2, a, a], h = n.getPlayState(),
                c = n.get("inverse", !0);
            o(t.nextBtnPosition, "controlStyle.nextIcon", QB(this._changeTimeline, this, c ? "-" : "+")), o(t.prevBtnPosition, "controlStyle.prevIcon", QB(this._changeTimeline, this, c ? "+" : "-")), o(t.playPosition, "controlStyle." + (h ? "stopIcon" : "playIcon"), QB(this._handlePlayClick, this, !h), !0)
        }, _renderCurrentPointer: function (t, e, i, n) {
            var o = n.getData(), a = n.getCurrentIndex(), r = o.getItemModel(a).getModel("checkpointStyle"), s = this,
                l = {
                    onCreate: function (t) {
                        t.draggable = !0, t.drift = QB(s._handlePointerDrag, s), t.ondragend = QB(s._handlePointerDragend, s), mw(t, a, i, n, !0)
                    }, onUpdate: function (t) {
                        mw(t, a, i, n)
                    }
                };
            this._currentPointer = gw(r, r, this._mainGroup, {}, this._currentPointer, l)
        }, _handlePlayClick: function (t) {
            this._clearTimer(), this.api.dispatchAction({type: "timelinePlayChange", playState: t, from: this.uid})
        }, _handlePointerDrag: function (t, e, i) {
            this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY])
        }, _handlePointerDragend: function (t) {
            this._pointerChangeTimeline([t.offsetX, t.offsetY], !0)
        }, _pointerChangeTimeline: function (t, e) {
            var i = this._toAxisCoord(t)[0], n = this._axis, o = Ar(n.getExtent().slice());
            i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.position[0] = i, this._currentPointer.dirty();
            var a = this._findNearestTick(i), r = this.model;
            (e || a !== r.getCurrentIndex() && r.get("realtime")) && this._changeTimeline(a)
        }, _doPlayStop: function () {
            function t() {
                var t = this.model;
                this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1))
            }

            this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(QB(t, this), this.model.get("playInterval")))
        }, _toAxisCoord: function (t) {
            var e = this._mainGroup.getLocalTransform();
            return sr(t, e, !0)
        }, _findNearestTick: function (t) {
            var e, i = this.model.getData(), n = 1 / 0, o = this._axis;
            return i.each(["value"], function (i, a) {
                var r = o.dataToCoord(i), s = Math.abs(r - t);
                n > s && (n = s, e = a)
            }), e
        }, _clearTimer: function () {
            this._timer && (clearTimeout(this._timer), this._timer = null)
        }, _changeTimeline: function (t) {
            var e = this.model.getCurrentIndex();
            "+" === t ? t = e + 1 : "-" === t && (t = e - 1), this.api.dispatchAction({
                type: "timelineChange",
                currentIndex: t,
                from: this.uid
            })
        }
    }), Cu(jB), ID.registerSubTypeDefaulter("dataZoom", function () {
        return "slider"
    });
    var iV = ["x", "y", "z", "radius", "angle", "single"], nV = ["cartesian2d", "polar", "singleAxis"],
        oV = yw(iV, ["axisIndex", "axis", "index", "id"]), aV = f, rV = Ar, sV = function (t, e, i, n) {
            this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this._minMaxSpan, this.ecModel = n, this._dataZoomModel = i
        };
    sV.prototype = {
        constructor: sV, hostedBy: function (t) {
            return this._dataZoomModel === t
        }, getDataValueWindow: function () {
            return this._valueWindow.slice()
        }, getDataPercentWindow: function () {
            return this._percentWindow.slice()
        }, getTargetSeriesModels: function () {
            var t = [], e = this.ecModel;
            return e.eachSeries(function (i) {
                if (vw(i.get("coordinateSystem"))) {
                    var n = this._dimName, o = e.queryComponents({
                        mainType: n + "Axis",
                        index: i.get(n + "AxisIndex"),
                        id: i.get(n + "AxisId")
                    })[0];
                    this._axisIndex === (o && o.componentIndex) && t.push(i)
                }
            }, this), t
        }, getAxisModel: function () {
            return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex)
        }, getOtherAxisModel: function () {
            var t, e, i = this._dimName, n = this.ecModel, o = this.getAxisModel(), a = "x" === i || "y" === i;
            a ? (e = "gridIndex", t = "x" === i ? "y" : "x") : (e = "polarIndex", t = "angle" === i ? "radius" : "angle");
            var r;
            return n.eachComponent(t + "Axis", function (t) {
                (t.get(e) || 0) === (o.get(e) || 0) && (r = t)
            }), r
        }, getMinMaxSpan: function () {
            return n(this._minMaxSpan)
        }, calculateDataWindow: function (t) {
            function e(t, e, i, n, o) {
                var r = o ? "Span" : "ValueSpan";
                xR(0, t, i, "all", h["min" + r], h["max" + r]);
                for (var s = 0; 2 > s; s++) e[s] = Mr(t[s], i, n, !0), o && (e[s] = a.parse(e[s]))
            }

            var i, n = this._dataExtent, o = this.getAxisModel(), a = o.axis.scale,
                r = this._dataZoomModel.getRangePropMode(), s = [0, 100], l = [], u = [];
            aV(["start", "end"], function (e, o) {
                var h = t[e], c = t[e + "Value"];
                "percent" === r[o] ? (null == h && (h = s[o]), c = a.parse(Mr(h, s, n))) : (i = !0, c = null == c ? n[o] : a.parse(c), h = Mr(c, n, s)), u[o] = c, l[o] = h
            }), rV(u), rV(l);
            var h = this._minMaxSpan;
            return i ? e(u, l, n, s, !1) : e(l, u, s, n, !0), {valueWindow: u, percentWindow: l}
        }, reset: function (t) {
            if (t === this._dataZoomModel) {
                var e = this.getTargetSeriesModels();
                this._dataExtent = _w(this, this._dimName, e), Sw(this);
                var i = this.calculateDataWindow(t.settledOption);
                this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, bw(this)
            }
        }, restore: function (t) {
            t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, bw(this, !0))
        }, filterData: function (t) {
            function e(t) {
                return t >= a[0] && t <= a[1]
            }

            if (t === this._dataZoomModel) {
                var i = this._dimName, n = this.getTargetSeriesModels(), o = t.get("filterMode"), a = this._valueWindow;
                "none" !== o && aV(n, function (t) {
                    var n = t.getData(), r = n.mapDimension(i, !0);
                    r.length && ("weakFilter" === o ? n.filterSelf(function (t) {
                        for (var e, i, o, s = 0; s < r.length; s++) {
                            var l = n.get(r[s], t), u = !isNaN(l), h = l < a[0], c = l > a[1];
                            if (u && !h && !c) return !0;
                            u && (o = !0), h && (e = !0), c && (i = !0)
                        }
                        return o && e && i
                    }) : aV(r, function (i) {
                        if ("empty" === o) t.setData(n = n.map(i, function (t) {
                            return e(t) ? t : 0 / 0
                        })); else {
                            var r = {};
                            r[i] = a, n.selectRange(r)
                        }
                    }), aV(r, function (t) {
                        n.setApproximateExtent(a, t)
                    }))
                })
            }
        }
    };
    var lV = f, uV = oV, hV = Vu({
            type: "dataZoom",
            dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"],
            defaultOption: {
                zlevel: 0,
                z: 4,
                orient: null,
                xAxisIndex: null,
                yAxisIndex: null,
                filterMode: "filter",
                throttle: null,
                start: 0,
                end: 100,
                startValue: null,
                endValue: null,
                minSpan: null,
                maxSpan: null,
                minValueSpan: null,
                maxValueSpan: null,
                rangeMode: null
            },
            init: function (t, e, i) {
                this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, this._autoThrottle = !0, this._rangePropMode = ["percent", "percent"];
                var n = Mw(t);
                this.settledOption = n, this.mergeDefaultAndTheme(t, i), this.doInit(n)
            },
            mergeOption: function (t) {
                var e = Mw(t);
                o(this.option, t, !0), o(this.settledOption, e, !0), this.doInit(e)
            },
            doInit: function (t) {
                var e = this.option;
                WS.canvasSupported || (e.realtime = !1), this._setDefaultThrottle(t), Iw(this, t);
                var i = this.settledOption;
                lV([["start", "startValue"], ["end", "endValue"]], function (t, n) {
                    "value" === this._rangePropMode[n] && (e[t[0]] = i[t[0]] = null)
                }, this), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), this._giveAxisProxies()
            },
            _giveAxisProxies: function () {
                var t = this._axisProxies;
                this.eachTargetAxis(function (e, i, n, o) {
                    var a = this.dependentModels[e.axis][i],
                        r = a.__dzAxisProxy || (a.__dzAxisProxy = new sV(e.name, i, this, o));
                    t[e.name + "_" + i] = r
                }, this)
            },
            _resetTarget: function () {
                var t = this.option, e = this._judgeAutoMode();
                uV(function (e) {
                    var i = e.axisIndex;
                    t[i] = eo(t[i])
                }, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient()
            },
            _judgeAutoMode: function () {
                var t = this.option, e = !1;
                uV(function (i) {
                    null != t[i.axisIndex] && (e = !0)
                }, this);
                var i = t.orient;
                return null == i && e ? "orient" : e ? void 0 : (null == i && (t.orient = "horizontal"), "axisIndex")
            },
            _autoSetAxisIndex: function () {
                var t = !0, e = this.get("orient", !0), i = this.option, n = this.dependentModels;
                if (t) {
                    var o = "vertical" === e ? "y" : "x";
                    n[o + "Axis"].length ? (i[o + "AxisIndex"] = [0], t = !1) : lV(n.singleAxis, function (n) {
                        t && n.get("orient", !0) === e && (i.singleAxisIndex = [n.componentIndex], t = !1)
                    })
                }
                t && uV(function (e) {
                    if (t) {
                        var n = [], o = this.dependentModels[e.axis];
                        if (o.length && !n.length) for (var a = 0, r = o.length; r > a; a++) "category" === o[a].get("type") && n.push(a);
                        i[e.axisIndex] = n, n.length && (t = !1)
                    }
                }, this), t && this.ecModel.eachSeries(function (t) {
                    this._isSeriesHasAllAxesTypeOf(t, "value") && uV(function (e) {
                        var n = i[e.axisIndex], o = t.get(e.axisIndex), a = t.get(e.axisId),
                            r = t.ecModel.queryComponents({mainType: e.axis, index: o, id: a})[0];
                        if (BS && !r) throw new Error(e.axis + ' "' + D(o, a, 0) + '" not found');
                        o = r.componentIndex, u(n, o) < 0 && n.push(o)
                    })
                }, this)
            },
            _autoSetOrient: function () {
                var t;
                this.eachTargetAxis(function (e) {
                    !t && (t = e.name)
                }, this), this.option.orient = "y" === t ? "vertical" : "horizontal"
            },
            _isSeriesHasAllAxesTypeOf: function (t, e) {
                var i = !0;
                return uV(function (n) {
                    var o = t.get(n.axisIndex), a = this.dependentModels[n.axis][o];
                    a && a.get("type") === e || (i = !1)
                }, this), i
            },
            _setDefaultThrottle: function (t) {
                if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
                    var e = this.ecModel.option;
                    this.option.throttle = e.animation && e.animationDurationUpdate > 0 ? 100 : 20
                }
            },
            getFirstTargetAxisModel: function () {
                var t;
                return uV(function (e) {
                    if (null == t) {
                        var i = this.get(e.axisIndex);
                        i.length && (t = this.dependentModels[e.axis][i[0]])
                    }
                }, this), t
            },
            eachTargetAxis: function (t, e) {
                var i = this.ecModel;
                uV(function (n) {
                    lV(this.get(n.axisIndex), function (o) {
                        t.call(e, n, o, this, i)
                    }, this)
                }, this)
            },
            getAxisProxy: function (t, e) {
                return this._axisProxies[t + "_" + e]
            },
            getAxisModel: function (t, e) {
                var i = this.getAxisProxy(t, e);
                return i && i.getAxisModel()
            },
            setRawRange: function (t) {
                var e = this.option, i = this.settledOption;
                lV([["start", "startValue"], ["end", "endValue"]], function (n) {
                    (null != t[n[0]] || null != t[n[1]]) && (e[n[0]] = i[n[0]] = t[n[0]], e[n[1]] = i[n[1]] = t[n[1]])
                }, this), Iw(this, t)
            },
            setCalculatedRange: function (t) {
                var e = this.option;
                lV(["start", "startValue", "end", "endValue"], function (i) {
                    e[i] = t[i]
                })
            },
            getPercentRange: function () {
                var t = this.findRepresentativeAxisProxy();
                return t ? t.getDataPercentWindow() : void 0
            },
            getValueRange: function (t, e) {
                if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();
                var i = this.findRepresentativeAxisProxy();
                return i ? i.getDataValueWindow() : void 0
            },
            findRepresentativeAxisProxy: function (t) {
                if (t) return t.__dzAxisProxy;
                var e = this._axisProxies;
                for (var i in e) if (e.hasOwnProperty(i) && e[i].hostedBy(this)) return e[i];
                for (var i in e) if (e.hasOwnProperty(i) && !e[i].hostedBy(this)) return e[i]
            },
            getRangePropMode: function () {
                return this._rangePropMode.slice()
            }
        }), cV = fC.extend({
            type: "dataZoom", render: function (t, e, i) {
                this.dataZoomModel = t, this.ecModel = e, this.api = i
            }, getTargetCoordInfo: function () {
                function t(t, e, i, n) {
                    for (var o, a = 0; a < i.length; a++) if (i[a].model === t) {
                        o = i[a];
                        break
                    }
                    o || i.push(o = {model: t, axisModels: [], coordIndex: n}), o.axisModels.push(e)
                }

                var e = this.dataZoomModel, i = this.ecModel, n = {};
                return e.eachTargetAxis(function (e, o) {
                    var a = i.getComponent(e.axis, o);
                    if (a) {
                        var r = a.getCoordSysModel();
                        r && t(r, a, n[r.mainType] || (n[r.mainType] = []), r.componentIndex)
                    }
                }, this), n
            }
        }), dV = (hV.extend({
            type: "dataZoom.slider",
            layoutMode: "box",
            defaultOption: {
                show: !0,
                right: "ph",
                top: "ph",
                width: "ph",
                height: "ph",
                left: null,
                bottom: null,
                backgroundColor: "rgba(47,69,84,0)",
                dataBackground: {
                    lineStyle: {color: "#2f4554", width: .5, opacity: .3},
                    areaStyle: {color: "rgba(47,69,84,0.3)", opacity: .3}
                },
                borderColor: "#ddd",
                fillerColor: "rgba(167,183,204,0.4)",
                handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
                handleSize: "100%",
                handleStyle: {color: "#a7b7cc"},
                labelPrecision: null,
                labelFormatter: null,
                showDetail: !0,
                showDataShadow: "auto",
                realtime: !0,
                zoomLock: !1,
                textStyle: {color: "#333"}
            }
        }), CA), fV = Mr, pV = Ar, gV = y, mV = f, vV = 7, yV = 1, xV = 30, _V = "horizontal", wV = "vertical", bV = 5,
        SV = ["line", "bar", "candlestick", "scatter"], MV = cV.extend({
            type: "dataZoom.slider", init: function (t, e) {
                this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, this.api = e
            }, render: function (t, e, i, n) {
                return MV.superApply(this, "render", arguments), Ml(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), this.dataZoomModel.get("show") === !1 ? void this.group.removeAll() : (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), void this._updateView())
            }, remove: function () {
                MV.superApply(this, "remove", arguments), Il(this, "_dispatchZoomAction")
            }, dispose: function () {
                MV.superApply(this, "dispose", arguments), Il(this, "_dispatchZoomAction")
            }, _buildView: function () {
                var t = this.group;
                t.removeAll(), this._resetLocation(), this._resetInterval();
                var e = this._displayables.barGroup = new iI;
                this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), this._positionGroup()
            }, _resetLocation: function () {
                var t = this.dataZoomModel, e = this.api, i = this._findCoordRect(),
                    n = {width: e.getWidth(), height: e.getHeight()}, o = this._orient === _V ? {
                        right: n.width - i.x - i.width,
                        top: n.height - xV - vV,
                        width: i.width,
                        height: xV
                    } : {right: vV, top: i.y, width: xV, height: i.height}, a = as(t.option);
                f(["right", "top", "width", "height"], function (t) {
                    "ph" === a[t] && (a[t] = o[t])
                });
                var r = es(a, n, t.padding);
                this._location = {
                    x: r.x,
                    y: r.y
                }, this._size = [r.width, r.height], this._orient === wV && this._size.reverse()
            }, _positionGroup: function () {
                var t = this.group, e = this._location, i = this._orient, n = this.dataZoomModel.getFirstTargetAxisModel(),
                    o = n && n.get("inverse"), a = this._displayables.barGroup,
                    r = (this._dataShadowInfo || {}).otherAxisInverse;
                a.attr(i !== _V || o ? i === _V && o ? {scale: r ? [-1, 1] : [-1, -1]} : i !== wV || o ? {
                    scale: r ? [-1, -1] : [-1, 1],
                    rotation: Math.PI / 2
                } : {scale: r ? [1, -1] : [1, 1], rotation: Math.PI / 2} : {scale: r ? [1, 1] : [1, -1]});
                var s = t.getBoundingRect([a]);
                t.attr("position", [e.x - s.x, e.y - s.y])
            }, _getViewExtent: function () {
                return [0, this._size[0]]
            }, _renderBackground: function () {
                var t = this.dataZoomModel, e = this._size, i = this._displayables.barGroup;
                i.add(new dV({
                    silent: !0,
                    shape: {x: 0, y: 0, width: e[0], height: e[1]},
                    style: {fill: t.get("backgroundColor")},
                    z2: -40
                })), i.add(new dV({
                    shape: {x: 0, y: 0, width: e[0], height: e[1]},
                    style: {fill: "transparent"},
                    z2: 0,
                    onclick: y(this._onClickPanelClick, this)
                }))
            }, _renderDataShadow: function () {
                var t = this._dataShadowInfo = this._prepareDataShadowInfo();
                if (t) {
                    var e = this._size, i = t.series, n = i.getRawData(),
                        o = i.getShadowDim ? i.getShadowDim() : t.otherDim;
                    if (null != o) {
                        var a = n.getDataExtent(o), r = .3 * (a[1] - a[0]);
                        a = [a[0] - r, a[1] + r];
                        var l, u = [0, e[1]], h = [0, e[0]], c = [[e[0], 0], [0, 0]], d = [], f = h[1] / (n.count() - 1),
                            p = 0, g = Math.round(n.count() / e[0]);
                        n.each([o], function (t, e) {
                            if (g > 0 && e % g) return void (p += f);
                            var i = null == t || isNaN(t) || "" === t, n = i ? 0 : fV(t, a, u, !0);
                            i && !l && e ? (c.push([c[c.length - 1][0], 0]), d.push([d[d.length - 1][0], 0])) : !i && l && (c.push([p, 0]), d.push([p, 0])), c.push([p, n]), d.push([p, n]), p += f, l = i
                        });
                        var m = this.dataZoomModel;
                        this._displayables.barGroup.add(new IA({
                            shape: {points: c},
                            style: s({fill: m.get("dataBackgroundColor")}, m.getModel("dataBackground.areaStyle").getAreaStyle()),
                            silent: !0,
                            z2: -20
                        })), this._displayables.barGroup.add(new TA({
                            shape: {points: d},
                            style: m.getModel("dataBackground.lineStyle").getLineStyle(),
                            silent: !0,
                            z2: -19
                        }))
                    }
                }
            }, _prepareDataShadowInfo: function () {
                var t = this.dataZoomModel, e = t.get("showDataShadow");
                if (e !== !1) {
                    var i, n = this.ecModel;
                    return t.eachTargetAxis(function (o, a) {
                        var r = t.getAxisProxy(o.name, a).getTargetSeriesModels();
                        f(r, function (t) {
                            if (!(i || e !== !0 && u(SV, t.get("type")) < 0)) {
                                var r, s = n.getComponent(o.axis, a).axis, l = Tw(o.name), h = t.coordinateSystem;
                                null != l && h.getOtherAxis && (r = h.getOtherAxis(s).inverse), l = t.getData().mapDimension(l), i = {
                                    thisAxis: s,
                                    series: t,
                                    thisDim: o.name,
                                    otherDim: l,
                                    otherAxisInverse: r
                                }
                            }
                        }, this)
                    }, this), i
                }
            }, _renderHandle: function () {
                var t = this._displayables, e = t.handles = [], i = t.handleLabels = [], n = this._displayables.barGroup,
                    o = this._size, a = this.dataZoomModel;
                n.add(t.filler = new dV({
                    draggable: !0,
                    cursor: Aw(this._orient),
                    drift: gV(this._onDragMove, this, "all"),
                    ondragstart: gV(this._showDataInfo, this, !0),
                    ondragend: gV(this._onDragEnd, this),
                    onmouseover: gV(this._showDataInfo, this, !0),
                    onmouseout: gV(this._showDataInfo, this, !1),
                    style: {fill: a.get("fillerColor"), textPosition: "inside"}
                })), n.add(new dV({
                    silent: !0,
                    subPixelOptimize: !0,
                    shape: {x: 0, y: 0, width: o[0], height: o[1]},
                    style: {
                        stroke: a.get("dataBackgroundColor") || a.get("borderColor"),
                        lineWidth: yV,
                        fill: "rgba(0,0,0,0)"
                    }
                })), mV([0, 1], function (t) {
                    var o = dr(a.get("handleIcon"), {
                        cursor: Aw(this._orient),
                        draggable: !0,
                        drift: gV(this._onDragMove, this, t),
                        ondragend: gV(this._onDragEnd, this),
                        onmouseover: gV(this._showDataInfo, this, !0),
                        onmouseout: gV(this._showDataInfo, this, !1)
                    }, {x: -1, y: 0, width: 2, height: 2}), r = o.getBoundingRect();
                    this._handleHeight = Ir(a.get("handleSize"), this._size[1]), this._handleWidth = r.width / r.height * this._handleHeight, o.setStyle(a.getModel("handleStyle").getItemStyle());
                    var s = a.get("handleColor");
                    null != s && (o.style.fill = s), n.add(e[t] = o);
                    var l = a.textStyleModel;
                    this.group.add(i[t] = new vA({
                        silent: !0,
                        invisible: !0,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            textFill: l.getTextColor(),
                            textFont: l.getFont()
                        },
                        z2: 10
                    }))
                }, this)
            }, _resetInterval: function () {
                var t = this._range = this.dataZoomModel.getPercentRange(), e = this._getViewExtent();
                this._handleEnds = [fV(t[0], [0, 100], e, !0), fV(t[1], [0, 100], e, !0)]
            }, _updateInterval: function (t, e) {
                var i = this.dataZoomModel, n = this._handleEnds, o = this._getViewExtent(),
                    a = i.findRepresentativeAxisProxy().getMinMaxSpan(), r = [0, 100];
                xR(e, n, o, i.get("zoomLock") ? "all" : t, null != a.minSpan ? fV(a.minSpan, r, o, !0) : null, null != a.maxSpan ? fV(a.maxSpan, r, o, !0) : null);
                var s = this._range, l = this._range = pV([fV(n[0], o, r, !0), fV(n[1], o, r, !0)]);
                return !s || s[0] !== l[0] || s[1] !== l[1]
            }, _updateView: function (t) {
                var e = this._displayables, i = this._handleEnds, n = pV(i.slice()), o = this._size;
                mV([0, 1], function (t) {
                    var n = e.handles[t], a = this._handleHeight;
                    n.attr({scale: [a / 2, a / 2], position: [i[t], o[1] / 2 - a / 2]})
                }, this), e.filler.setShape({x: n[0], y: 0, width: n[1] - n[0], height: o[1]}), this._updateDataInfo(t)
            }, _updateDataInfo: function (t) {
                function e(t) {
                    var e = rr(n.handles[t].parent, this.group), i = lr(0 === t ? "right" : "left", e),
                        s = this._handleWidth / 2 + bV, l = sr([c[t] + (0 === t ? -s : s), this._size[1] / 2], e);
                    o[t].setStyle({
                        x: l[0],
                        y: l[1],
                        textVerticalAlign: a === _V ? "middle" : i,
                        textAlign: a === _V ? i : "center",
                        text: r[t]
                    })
                }

                var i = this.dataZoomModel, n = this._displayables, o = n.handleLabels, a = this._orient, r = ["", ""];
                if (i.get("showDetail")) {
                    var s = i.findRepresentativeAxisProxy();
                    if (s) {
                        var l = s.getAxisModel().axis, u = this._range,
                            h = t ? s.calculateDataWindow({start: u[0], end: u[1]}).valueWindow : s.getDataValueWindow();
                        r = [this._formatLabel(h[0], l), this._formatLabel(h[1], l)]
                    }
                }
                var c = pV(this._handleEnds.slice());
                e.call(this, 0), e.call(this, 1)
            }, _formatLabel: function (t, e) {
                var i = this.dataZoomModel, n = i.get("labelFormatter"), o = i.get("labelPrecision");
                (null == o || "auto" === o) && (o = e.getPixelPrecision());
                var a = null == t || isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(o, 20));
                return w(n) ? n(t, a) : b(n) ? n.replace("{value}", a) : a
            }, _showDataInfo: function (t) {
                t = this._dragging || t;
                var e = this._displayables.handleLabels;
                e[0].attr("invisible", !t), e[1].attr("invisible", !t)
            }, _onDragMove: function (t, e, i, n) {
                this._dragging = !0, vM(n.event);
                var o = this._displayables.barGroup.getLocalTransform(), a = sr([e, i], o, !0),
                    r = this._updateInterval(t, a[0]), s = this.dataZoomModel.get("realtime");
                this._updateView(!s), r && s && this._dispatchZoomAction()
            }, _onDragEnd: function () {
                this._dragging = !1, this._showDataInfo(!1);
                var t = this.dataZoomModel.get("realtime");
                !t && this._dispatchZoomAction()
            }, _onClickPanelClick: function (t) {
                var e = this._size, i = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY);
                if (!(i[0] < 0 || i[0] > e[0] || i[1] < 0 || i[1] > e[1])) {
                    var n = this._handleEnds, o = (n[0] + n[1]) / 2, a = this._updateInterval("all", i[0] - o);
                    this._updateView(), a && this._dispatchZoomAction()
                }
            }, _dispatchZoomAction: function () {
                var t = this._range;
                this.api.dispatchAction({
                    type: "dataZoom",
                    from: this.uid,
                    dataZoomId: this.dataZoomModel.id,
                    start: t[0],
                    end: t[1]
                })
            }, _findCoordRect: function () {
                var t;
                if (mV(this.getTargetCoordInfo(), function (e) {
                    if (!t && e.length) {
                        var i = e[0].model.coordinateSystem;
                        t = i.getRect && i.getRect()
                    }
                }), !t) {
                    var e = this.api.getWidth(), i = this.api.getHeight();
                    t = {x: .2 * e, y: .2 * i, width: .6 * e, height: .6 * i}
                }
                return t
            }
        });
    Lu({
        getTargetSeries: function (t) {
            var e = B();
            return t.eachComponent("dataZoom", function (t) {
                t.eachTargetAxis(function (t, i, n) {
                    var o = n.getAxisProxy(t.name, i);
                    f(o.getTargetSeriesModels(), function (t) {
                        e.set(t.uid, t)
                    })
                })
            }), e
        }, modifyOutputEnd: !0, overallReset: function (t, e) {
            t.eachComponent("dataZoom", function (t) {
                t.eachTargetAxis(function (t, i, n) {
                    n.getAxisProxy(t.name, i).reset(n, e)
                }), t.eachTargetAxis(function (t, i, n) {
                    n.getAxisProxy(t.name, i).filterData(n, e)
                })
            }), t.eachComponent("dataZoom", function (t) {
                var e = t.findRepresentativeAxisProxy(), i = e.getDataPercentWindow(), n = e.getDataValueWindow();
                t.setCalculatedRange({start: i[0], end: i[1], startValue: n[0], endValue: n[1]})
            })
        }
    }), Pu("dataZoom", function (t, e) {
        var i = xw(y(e.eachComponent, e, "dataZoom"), oV, function (t, e) {
            return t.get(e.axisIndex)
        }), n = [];
        e.eachComponent({mainType: "dataZoom", query: t}, function (t) {
            n.push.apply(n, i(t).nodes)
        }), f(n, function (e) {
            e.setRawRange({start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue})
        })
    }), hV.extend({
        type: "dataZoom.inside",
        defaultOption: {
            disabled: !1,
            zoomLock: !1,
            zoomOnMouseWheel: !0,
            moveOnMouseMove: !0,
            moveOnMouseWheel: !1,
            preventDefaultMouseMove: !0
        }
    });
    var IV = "\x00_ec_dataZoom_roams", TV = y, AV = cV.extend({
            type: "dataZoom.inside", init: function () {
                this._range
            }, render: function (t, e, i) {
                AV.superApply(this, "render", arguments), this._range = t.getPercentRange(), f(this.getTargetCoordInfo(), function (e, n) {
                    var o = p(e, function (t) {
                        return Lw(t.model)
                    });
                    f(e, function (e) {
                        var a = e.model, r = {};
                        f(["pan", "zoom", "scrollMove"], function (t) {
                            r[t] = TV(DV[t], this, e, n)
                        }, this), Dw(i, {
                            coordId: Lw(a), allCoordIds: o, containsPoint: function (t, e, i) {
                                return a.coordinateSystem.containPoint([e, i])
                            }, dataZoomId: t.id, dataZoomModel: t, getRange: r
                        })
                    }, this)
                }, this)
            }, dispose: function () {
                Cw(this.api, this.dataZoomModel.id), AV.superApply(this, "dispose", arguments), this._range = null
            }
        }), DV = {
            zoom: function (t, e, i, n) {
                var o = this._range, a = o.slice(), r = t.axisModels[0];
                if (r) {
                    var s = CV[e](null, [n.originX, n.originY], r, i, t),
                        l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0],
                        u = Math.max(1 / n.scale, 0);
                    a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
                    var h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
                    return xR(0, a, [0, 100], 0, h.minSpan, h.maxSpan), this._range = a, o[0] !== a[0] || o[1] !== a[1] ? a : void 0
                }
            }, pan: Rw(function (t, e, i, n, o, a) {
                var r = CV[n]([a.oldX, a.oldY], [a.newX, a.newY], e, o, i);
                return r.signal * (t[1] - t[0]) * r.pixel / r.pixelLength
            }), scrollMove: Rw(function (t, e, i, n, o, a) {
                var r = CV[n]([0, 0], [a.scrollDelta, a.scrollDelta], e, o, i);
                return r.signal * (t[1] - t[0]) * a.scrollDelta
            })
        }, CV = {
            grid: function (t, e, i, n, o) {
                var a = i.axis, r = {}, s = o.model.coordinateSystem.getRect();
                return t = t || [0, 0], "x" === a.dim ? (r.pixel = e[0] - t[0], r.pixelLength = s.width, r.pixelStart = s.x, r.signal = a.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = s.height, r.pixelStart = s.y, r.signal = a.inverse ? -1 : 1), r
            }, polar: function (t, e, i, n, o) {
                var a = i.axis, r = {}, s = o.model.coordinateSystem, l = s.getRadiusAxis().getExtent(),
                    u = s.getAngleAxis().getExtent();
                return t = t ? s.pointToCoord(t) : [0, 0], e = s.pointToCoord(e), "radiusAxis" === i.mainType ? (r.pixel = e[0] - t[0], r.pixelLength = l[1] - l[0], r.pixelStart = l[0], r.signal = a.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = u[1] - u[0], r.pixelStart = u[0], r.signal = a.inverse ? -1 : 1), r
            }, singleAxis: function (t, e, i, n, o) {
                var a = i.axis, r = o.model.coordinateSystem.getRect(), s = {};
                return t = t || [0, 0], "horizontal" === a.orient ? (s.pixel = e[0] - t[0], s.pixelLength = r.width, s.pixelStart = r.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = r.height, s.pixelStart = r.y, s.signal = a.inverse ? -1 : 1), s
            }
        }, LV = ["rect", "polygon", "keep", "clear"], kV = function (t, e) {
            var i = t && t.brush;
            if (_(i) || (i = i ? [i] : []), i.length) {
                var n = [];
                f(i, function (t) {
                    var e = t.hasOwnProperty("toolbox") ? t.toolbox : [];
                    e instanceof Array && (n = n.concat(e))
                });
                var o = t && t.toolbox;
                _(o) && (o = o[0]), o || (o = {feature: {}}, t.toolbox = [o]);
                var a = o.feature || (o.feature = {}), r = a.brush || (a.brush = {}), s = r.type || (r.type = []);
                s.push.apply(s, n), zw(s), e && !s.length && s.push.apply(s, LV)
            }
        }, PV = f, OV = {
            lineX: Hw(0), lineY: Hw(1), rect: {
                point: function (t, e, i) {
                    return t && i.boundingRect.contain(t[0], t[1])
                }, rect: function (t, e, i) {
                    return t && i.boundingRect.intersect(t)
                }
            }, polygon: {
                point: function (t, e, i) {
                    return t && i.boundingRect.contain(t[0], t[1]) && hc(i.range, t[0], t[1])
                }, rect: function (t, e, i) {
                    var n = i.range;
                    if (!t || n.length <= 1) return !1;
                    var o = t.x, a = t.y, r = t.width, s = t.height, l = n[0];
                    return hc(n, o, a) || hc(n, o + r, a) || hc(n, o, a + s) || hc(n, o + r, a + s) || Ti.create(t).contain(l[0], l[1]) || fr(o, a, o + r, a, n) || fr(o, a, o, a + s, n) || fr(o + r, a, o + r, a + s, n) || fr(o, a + s, o + r, a + s, n) ? !0 : void 0
                }
            }
        }, EV = f, NV = u, RV = x, zV = ["dataToPoint", "pointToData"],
        BV = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], VV = Uw.prototype;
    VV.setOutputRanges = function (t, e) {
        this.matchOutputRanges(t, e, function (t, e, i) {
            if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) {
                t.coordRange = e;
                var n = HV[t.brushType](0, i, e);
                t.__rangeOffset = {offset: ZV[t.brushType](n.values, t.range, [1, 1]), xyMinMax: n.xyMinMax}
            }
        })
    }, VV.matchOutputRanges = function (t, e, i) {
        EV(t, function (t) {
            var n = this.findTargetInfo(t, e);
            n && n !== !0 && f(n.coordSyses, function (n) {
                var o = HV[t.brushType](1, n, t.range);
                i(t, o.values, n, e)
            })
        }, this)
    }, VV.setInputRanges = function (t, e) {
        EV(t, function (t) {
            var i = this.findTargetInfo(t, e);
            if (BS && (O(!i || i === !0 || t.coordRange, "coordRange must be specified when coord index specified."), O(!i || i !== !0 || t.range, "range must be specified in global brush.")), t.range = t.range || [], i && i !== !0) {
                t.panelId = i.panelId;
                var n = HV[t.brushType](0, i.coordSys, t.coordRange), o = t.__rangeOffset;
                t.range = o ? ZV[t.brushType](n.values, o.offset, Kw(n.xyMinMax, o.xyMinMax)) : n.values
            }
        }, this)
    }, VV.makePanelOpts = function (t, e) {
        return p(this._targetInfoList, function (i) {
            var n = i.getPanelRect();
            return {
                panelId: i.panelId,
                defaultBrushType: e && e(i),
                clipPath: Dv(n),
                isTargetByCursor: Lv(n, t, i.coordSysModel),
                getLinearBrushOtherExtent: Cv(n)
            }
        })
    }, VV.controlSeries = function (t, e, i) {
        var n = this.findTargetInfo(t, i);
        return n === !0 || n && NV(n.coordSyses, e.coordinateSystem) >= 0
    }, VV.findTargetInfo = function (t, e) {
        for (var i = this._targetInfoList, n = Yw(e, t), o = 0; o < i.length; o++) {
            var a = i[o], r = t.panelId;
            if (r) {
                if (a.panelId === r) return a
            } else for (var o = 0; o < FV.length; o++) if (FV[o](n, a)) return a
        }
        return !0
    };
    var GV = {
        grid: function (t, e) {
            var i = t.xAxisModels, n = t.yAxisModels, o = t.gridModels, a = B(), r = {}, s = {};
            (i || n || o) && (EV(i, function (t) {
                var e = t.axis.grid.model;
                a.set(e.id, e), r[e.id] = !0
            }), EV(n, function (t) {
                var e = t.axis.grid.model;
                a.set(e.id, e), s[e.id] = !0
            }), EV(o, function (t) {
                a.set(t.id, t), r[t.id] = !0, s[t.id] = !0
            }), a.each(function (t) {
                var o = t.coordinateSystem, a = [];
                EV(o.getCartesians(), function (t) {
                    (NV(i, t.getAxis("x").model) >= 0 || NV(n, t.getAxis("y").model) >= 0) && a.push(t)
                }), e.push({
                    panelId: "grid--" + t.id,
                    gridModel: t,
                    coordSysModel: t,
                    coordSys: a[0],
                    coordSyses: a,
                    getPanelRect: WV.grid,
                    xAxisDeclared: r[t.id],
                    yAxisDeclared: s[t.id]
                })
            }))
        }, geo: function (t, e) {
            EV(t.geoModels, function (t) {
                var i = t.coordinateSystem;
                e.push({
                    panelId: "geo--" + t.id,
                    geoModel: t,
                    coordSysModel: t,
                    coordSys: i,
                    coordSyses: [i],
                    getPanelRect: WV.geo
                })
            })
        }
    }, FV = [function (t, e) {
        var i = t.xAxisModel, n = t.yAxisModel, o = t.gridModel;
        return !o && i && (o = i.axis.grid.model), !o && n && (o = n.axis.grid.model), o && o === e.gridModel
    }, function (t, e) {
        var i = t.geoModel;
        return i && i === e.geoModel
    }], WV = {
        grid: function () {
            return this.coordSys.grid.getRect().clone()
        }, geo: function () {
            var t = this.coordSys, e = t.getBoundingRect().clone();
            return e.applyTransform(rr(t)), e
        }
    }, HV = {
        lineX: RV(jw, 0), lineY: RV(jw, 1), rect: function (t, e, i) {
            var n = e[zV[t]]([i[0][0], i[1][0]]), o = e[zV[t]]([i[0][1], i[1][1]]),
                a = [Xw([n[0], o[0]]), Xw([n[1], o[1]])];
            return {values: a, xyMinMax: a}
        }, polygon: function (t, e, i) {
            var n = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], o = p(i, function (i) {
                var o = e[zV[t]](i);
                return n[0][0] = Math.min(n[0][0], o[0]), n[1][0] = Math.min(n[1][0], o[1]), n[0][1] = Math.max(n[0][1], o[0]), n[1][1] = Math.max(n[1][1], o[1]), o
            });
            return {values: o, xyMinMax: n}
        }
    }, ZV = {
        lineX: RV(qw, 0), lineY: RV(qw, 1), rect: function (t, e, i) {
            return [[t[0][0] - i[0] * e[0][0], t[0][1] - i[0] * e[0][1]], [t[1][0] - i[1] * e[1][0], t[1][1] - i[1] * e[1][1]]]
        }, polygon: function (t, e, i) {
            return p(t, function (t, n) {
                return [t[0] - i[0] * e[n][0], t[1] - i[1] * e[n][1]]
            })
        }
    }, UV = ["inBrush", "outOfBrush"], XV = "__ecBrushSelect", YV = "__ecInBrushSelectEvent", jV = mL.VISUAL.BRUSH;
    Nu(jV, function (t, e, i) {
        t.eachComponent({mainType: "brush"}, function (t) {
            i && "takeGlobalCursor" === i.type && t.setBrushOption("brush" === i.key ? i.brushOption : {brushType: !1})
        }), Jw(t)
    }), Ru(jV, function (t, e, i) {
        var o, a, r = [];
        t.eachComponent({mainType: "brush"}, function (e, i) {
            function l(t) {
                return "all" === m || v[t]
            }

            function u(t) {
                return !!t.length
            }

            function h(t, e) {
                var i = t.coordinateSystem;
                w |= i.hasAxisBrushed(), l(e) && i.eachActiveState(t.getData(), function (t, e) {
                    "active" === t && (y[e] = 1)
                })
            }

            function c(i, n, o) {
                var a = ib(i);
                if (a && !nb(e, n) && (f(b, function (n) {
                    a[n.brushType] && e.brushTargetManager.controlSeries(n, i, t) && o.push(n), w |= u(o)
                }), l(n) && u(o))) {
                    var r = i.getData();
                    r.each(function (t) {
                        eb(a, o, r, t) && (y[t] = 1)
                    })
                }
            }

            var d = {brushId: e.id, brushIndex: i, brushName: e.name, areas: n(e.areas), selected: []};
            r.push(d);
            var g = e.option, m = g.brushLink, v = [], y = [], x = [], w = 0;
            i || (o = g.throttleType, a = g.throttleDelay);
            var b = p(e.areas, function (t) {
                return ob(s({boundingRect: qV[t.brushType](t)}, t))
            }), S = Vw(e.option, UV, function (t) {
                t.mappingMethod = "fixed"
            });
            _(m) && f(m, function (t) {
                v[t] = 1
            }), t.eachSeries(function (t, e) {
                var i = x[e] = [];
                "parallel" === t.subType ? h(t, e, i) : c(t, e, i)
            }), t.eachSeries(function (t, e) {
                var i = {seriesId: t.id, seriesIndex: e, seriesName: t.name, dataIndex: []};
                d.selected.push(i);
                var n = ib(t), o = x[e], a = t.getData(), r = l(e) ? function (t) {
                    return y[t] ? (i.dataIndex.push(a.getRawIndex(t)), "inBrush") : "outOfBrush"
                } : function (t) {
                    return eb(n, o, a, t) ? (i.dataIndex.push(a.getRawIndex(t)), "inBrush") : "outOfBrush"
                };
                (l(e) ? w : u(o)) && Fw(UV, S, a, r)
            })
        }), Qw(e, o, a, r, i)
    });
    {
        var qV = {
            lineX: G, lineY: G, rect: function (t) {
                return ab(t.range)
            }, polygon: function (t) {
                for (var e, i = t.range, n = 0, o = i.length; o > n; n++) {
                    e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
                    var a = i[n];
                    a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1])
                }
                return e && ab(e)
            }
        }, KV = ["#ddd"];
        Vu({
            type: "brush",
            dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
            defaultOption: {
                toolbox: null,
                brushLink: null,
                seriesIndex: "all",
                geoIndex: null,
                xAxisIndex: null,
                yAxisIndex: null,
                brushType: "rect",
                brushMode: "single",
                transformable: !0,
                brushStyle: {borderWidth: 1, color: "rgba(120,140,180,0.3)", borderColor: "rgba(120,140,180,0.8)"},
                throttleType: "fixRate",
                throttleDelay: 0,
                removeOnClick: !0,
                z: 1e4
            },
            areas: [],
            brushType: null,
            brushOption: {},
            coordInfoList: [],
            optionUpdated: function (t, e) {
                var i = this.option;
                !e && Gw(i, t, ["inBrush", "outOfBrush"]);
                var n = i.inBrush = i.inBrush || {};
                i.outOfBrush = i.outOfBrush || {color: KV}, n.hasOwnProperty("liftZ") || (n.liftZ = 5)
            },
            setAreas: function (t) {
                BS && (O(_(t)), f(t, function (t) {
                    O(t.brushType, "Illegal areas")
                })), t && (this.areas = p(t, function (t) {
                    return rb(this.option, t)
                }, this))
            },
            setBrushOption: function (t) {
                this.brushOption = rb(this.option, t), this.brushType = this.brushOption.brushType
            }
        })
    }
    Gu({
        type: "brush", init: function (t, e) {
            this.ecModel = t, this.api = e, this.model, (this._brushController = new Zm(e.getZr())).on("brush", y(this._onBrush, this)).mount()
        }, render: function (t) {
            return this.model = t, sb.apply(this, arguments)
        }, updateTransform: function (t, e) {
            return Jw(e), sb.apply(this, arguments)
        }, updateView: sb, dispose: function () {
            this._brushController.dispose()
        }, _onBrush: function (t, e) {
            var i = this.model.id;
            this.model.brushTargetManager.setOutputRanges(t, this.ecModel), (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({
                type: "brush",
                brushId: i,
                areas: n(t),
                $from: i
            }), e.isEnd && this.api.dispatchAction({type: "brushEnd", brushId: i, areas: n(t), $from: i})
        }
    }), Pu({type: "brush", event: "brush"}, function (t, e) {
        e.eachComponent({mainType: "brush", query: t}, function (e) {
            e.setAreas(t.areas)
        })
    }), Pu({type: "brushSelect", event: "brushSelected", update: "none"}, function () {
    }), Pu({type: "brushEnd", event: "brushEnd", update: "none"}, function () {
    });
    var $V = {}, JV = MC.toolbox.brush;
    hb.defaultOption = {
        show: !0, type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"], icon: {
            rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
            polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
            lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
            lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
            keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
            clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        }, title: n(JV.title)
    };
    var QV = hb.prototype;
    QV.render = QV.updateView = function (t, e) {
        var i, n, o;
        e.eachComponent({mainType: "brush"}, function (t) {
            i = t.brushType, n = t.brushOption.brushMode || "single", o |= t.areas.length
        }), this._brushType = i, this._brushMode = n, f(t.get("type", !0), function (e) {
            t.setIconStatus(e, ("keep" === e ? "multiple" === n : "clear" === e ? o : e === i) ? "emphasis" : "normal")
        })
    }, QV.getIcons = function () {
        var t = this.model, e = t.get("icon", !0), i = {};
        return f(t.get("type", !0), function (t) {
            e[t] && (i[t] = e[t])
        }), i
    }, QV.onclick = function (t, e, i) {
        var n = this._brushType, o = this._brushMode;
        "clear" === i ? (e.dispatchAction({type: "axisAreaSelect", intervals: []}), e.dispatchAction({
            type: "brush",
            command: "clear",
            areas: []
        })) : e.dispatchAction({
            type: "takeGlobalCursor",
            key: "brush",
            brushOption: {
                brushType: "keep" === i ? n : n === i ? !1 : i,
                brushMode: "keep" === i ? "multiple" === o ? "single" : "multiple" : o
            }
        })
    }, lb("brush", hb), Cu(kV);
    var tG = f, eG = function (t) {
        var e = t && t.visualMap;
        _(e) || (e = e ? [e] : []), tG(e, function (t) {
            if (t) {
                cb(t, "splitList") && !cb(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
                var e = t.pieces;
                e && _(e) && tG(e, function (t) {
                    S(t) && (cb(t, "start") && !cb(t, "min") && (t.min = t.start), cb(t, "end") && !cb(t, "max") && (t.max = t.end))
                })
            }
        })
    };
    ID.registerSubTypeDefaulter("visualMap", function (t) {
        return t.categories || (t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) && !t.calculable ? "piecewise" : "continuous"
    });
    var iG = mL.VISUAL.COMPONENT;
    Ru(iG, {
        createOnAllSeries: !0, reset: function (t, e) {
            var i = [];
            return e.eachComponent("visualMap", function (e) {
                var n = t.pipelineContext;
                !e.isTargetSeries(t) || n && n.large || i.push(Ww(e.stateList, e.targetVisuals, y(e.getValueState, e), e.getDataDimension(t.getData())))
            }), i
        }
    }), Ru(iG, {
        createOnAllSeries: !0, reset: function (t, e) {
            var i = t.getData(), n = [];
            e.eachComponent("visualMap", function (e) {
                if (e.isTargetSeries(t)) {
                    var o = e.getVisualMeta(y(db, null, t, e)) || {stops: [], outerColors: []},
                        a = e.getDataDimension(i), r = i.getDimensionInfo(a);
                    null != r && (o.dimension = r.index, n.push(o))
                }
            }), t.getData().setVisual("visualMeta", n)
        }
    });
    var nG = {
        get: function (t, e, i) {
            var o = n((oG[t] || {})[e]);
            return i && _(o) ? o[o.length - 1] : o
        }
    }, oG = {
        color: {active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"]},
        colorHue: {active: [0, 360], inactive: [0, 0]},
        colorSaturation: {active: [.3, 1], inactive: [0, 0]},
        colorLightness: {active: [.9, .5], inactive: [0, 0]},
        colorAlpha: {active: [.3, 1], inactive: [0, 0]},
        opacity: {active: [.3, 1], inactive: [0, 0]},
        symbol: {active: ["circle", "roundRect", "diamond"], inactive: ["none"]},
        symbolSize: {active: [10, 50], inactive: [0, 0]}
    }, aG = pE.mapVisual, rG = pE.eachVisual, sG = _, lG = f, uG = Ar, hG = Mr, cG = G, dG = Vu({
        type: "visualMap",
        dependencies: ["series"],
        stateList: ["inRange", "outOfRange"],
        replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
        dataBound: [-1 / 0, 1 / 0],
        layoutMode: {type: "box", ignoreSize: !0},
        defaultOption: {
            show: !0,
            zlevel: 0,
            z: 4,
            seriesIndex: "all",
            min: 0,
            max: 200,
            dimension: null,
            inRange: null,
            outOfRange: null,
            left: 0,
            right: null,
            top: null,
            bottom: 0,
            itemWidth: null,
            itemHeight: null,
            inverse: !1,
            orient: "vertical",
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            contentColor: "#5793f3",
            inactiveColor: "#aaa",
            borderWidth: 0,
            padding: 5,
            textGap: 10,
            precision: 0,
            color: null,
            formatter: null,
            text: null,
            textStyle: {color: "#333"}
        },
        init: function (t, e, i) {
            this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, this.itemSize, this.mergeDefaultAndTheme(t, i)
        },
        optionUpdated: function (t, e) {
            var i = this.option;
            WS.canvasSupported || (i.realtime = !1), !e && Gw(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption()
        },
        resetVisual: function (t) {
            var e = this.stateList;
            t = y(t, this), this.controllerVisuals = Vw(this.option.controller, e, t), this.targetVisuals = Vw(this.option.target, e, t)
        },
        getTargetSeriesIndices: function () {
            var t = this.option.seriesIndex, e = [];
            return null == t || "all" === t ? this.ecModel.eachSeries(function (t, i) {
                e.push(i)
            }) : e = eo(t), e
        },
        eachTargetSeries: function (t, e) {
            f(this.getTargetSeriesIndices(), function (i) {
                t.call(e, this.ecModel.getSeriesByIndex(i))
            }, this)
        },
        isTargetSeries: function (t) {
            var e = !1;
            return this.eachTargetSeries(function (i) {
                i === t && (e = !0)
            }), e
        },
        formatValueText: function (t, e, i) {
            function n(t) {
                return t === l[0] ? "min" : t === l[1] ? "max" : (+t).toFixed(Math.min(s, 20))
            }

            var o, a, r = this.option, s = r.precision, l = this.dataBound, u = r.formatter;
            return i = i || ["<", ">"], _(t) && (t = t.slice(), o = !0), a = e ? t : o ? [n(t[0]), n(t[1])] : n(t), b(u) ? u.replace("{value}", o ? a[0] : a).replace("{value2}", o ? a[1] : a) : w(u) ? o ? u(t[0], t[1]) : u(t) : o ? t[0] === l[0] ? i[0] + " " + a[1] : t[1] === l[1] ? i[1] + " " + a[0] : a[0] + " - " + a[1] : a
        },
        resetExtent: function () {
            var t = this.option, e = uG([t.min, t.max]);
            this._dataExtent = e
        },
        getDataDimension: function (t) {
            var e = this.option.dimension, i = t.dimensions;
            if (null != e || i.length) {
                if (null != e) return t.getDimension(e);
                for (var n = t.dimensions, o = n.length - 1; o >= 0; o--) {
                    var a = n[o], r = t.getDimensionInfo(a);
                    if (!r.isCalculationCoord) return a
                }
            }
        },
        getExtent: function () {
            return this._dataExtent.slice()
        },
        completeVisualOption: function () {
            function t(t) {
                sG(r.color) && !t.inRange && (t.inRange = {color: r.color.slice().reverse()}), t.inRange = t.inRange || {color: a.get("gradientColor")}, lG(this.stateList, function (e) {
                    var i = t[e];
                    if (b(i)) {
                        var n = nG.get(i, "active", h);
                        n ? (t[e] = {}, t[e][i] = n) : delete t[e]
                    }
                }, this)
            }

            function e(t, e, i) {
                var n = t[e], o = t[i];
                n && !o && (o = t[i] = {}, lG(n, function (t, e) {
                    if (pE.isValidType(e)) {
                        var i = nG.get(e, "inactive", h);
                        null != i && (o[e] = i, "color" !== e || o.hasOwnProperty("opacity") || o.hasOwnProperty("colorAlpha") || (o.opacity = [0, 0]))
                    }
                }))
            }

            function i(t) {
                var e = (t.inRange || {}).symbol || (t.outOfRange || {}).symbol,
                    i = (t.inRange || {}).symbolSize || (t.outOfRange || {}).symbolSize, o = this.get("inactiveColor");
                lG(this.stateList, function (a) {
                    var r = this.itemSize, s = t[a];
                    s || (s = t[a] = {color: h ? o : [o]}), null == s.symbol && (s.symbol = e && n(e) || (h ? "roundRect" : ["roundRect"])), null == s.symbolSize && (s.symbolSize = i && n(i) || (h ? r[0] : [r[0], r[0]])), s.symbol = aG(s.symbol, function (t) {
                        return "none" === t || "square" === t ? "roundRect" : t
                    });
                    var l = s.symbolSize;
                    if (null != l) {
                        var u = -1 / 0;
                        rG(l, function (t) {
                            t > u && (u = t)
                        }), s.symbolSize = aG(l, function (t) {
                            return hG(t, [0, u], [0, r[0]], !0)
                        })
                    }
                }, this)
            }

            var a = this.ecModel, r = this.option, s = {inRange: r.inRange, outOfRange: r.outOfRange},
                l = r.target || (r.target = {}), u = r.controller || (r.controller = {});
            o(l, s), o(u, s);
            var h = this.isCategory();
            t.call(this, l), t.call(this, u), e.call(this, l, "inRange", "outOfRange"), i.call(this, u)
        },
        resetItemSize: function () {
            this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]
        },
        isCategory: function () {
            return !!this.option.categories
        },
        setSelected: cG,
        getValueState: cG,
        getVisualMeta: cG
    }), fG = [20, 140], pG = dG.extend({
        type: "visualMap.continuous",
        defaultOption: {
            align: "auto",
            calculable: !1,
            range: null,
            realtime: !0,
            itemHeight: null,
            itemWidth: null,
            hoverLink: !0,
            hoverLinkDataSize: null,
            hoverLinkOnHandle: null
        },
        optionUpdated: function () {
            pG.superApply(this, "optionUpdated", arguments), this.resetExtent(), this.resetVisual(function (t) {
                t.mappingMethod = "linear", t.dataExtent = this.getExtent()
            }), this._resetRange()
        },
        resetItemSize: function () {
            pG.superApply(this, "resetItemSize", arguments);
            var t = this.itemSize;
            "horizontal" === this._orient && t.reverse(), (null == t[0] || isNaN(t[0])) && (t[0] = fG[0]), (null == t[1] || isNaN(t[1])) && (t[1] = fG[1])
        },
        _resetRange: function () {
            var t = this.getExtent(), e = this.option.range;
            !e || e.auto ? (t.auto = 1, this.option.range = t) : _(e) && (e[0] > e[1] && e.reverse(), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]))
        },
        completeVisualOption: function () {
            dG.prototype.completeVisualOption.apply(this, arguments), f(this.stateList, function (t) {
                var e = this.option.controller[t].symbolSize;
                e && e[0] !== e[1] && (e[0] = 0)
            }, this)
        },
        setSelected: function (t) {
            this.option.range = t.slice(), this._resetRange()
        },
        getSelected: function () {
            var t = this.getExtent(), e = Ar((this.get("range") || []).slice());
            return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e
        },
        getValueState: function (t) {
            var e = this.option.range, i = this.getExtent();
            return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange"
        },
        findTargetDataIndices: function (t) {
            var e = [];
            return this.eachTargetSeries(function (i) {
                var n = [], o = i.getData();
                o.each(this.getDataDimension(o), function (e, i) {
                    t[0] <= e && e <= t[1] && n.push(i)
                }, this), e.push({seriesId: i.id, dataIndex: n})
            }, this), e
        },
        getVisualMeta: function (t) {
            function e(e, i) {
                o.push({value: e, color: t(e, i)})
            }

            for (var i = fb(this, "outOfRange", this.getExtent()), n = fb(this, "inRange", this.option.range.slice()), o = [], a = 0, r = 0, s = n.length, l = i.length; l > r && (!n.length || i[r] <= n[0]); r++) i[r] < n[a] && e(i[r], "outOfRange");
            for (var u = 1; s > a; a++, u = 0) u && o.length && e(n[a], "outOfRange"), e(n[a], "inRange");
            for (var u = 1; l > r; r++) (!n.length || n[n.length - 1] < i[r]) && (u && (o.length && e(o[o.length - 1].value, "outOfRange"), u = 0), e(i[r], "outOfRange"));
            var h = o.length;
            return {stops: o, outerColors: [h ? o[0].color : "transparent", h ? o[h - 1].color : "transparent"]}
        }
    }), gG = Gu({
        type: "visualMap", autoPositionValues: {left: 1, right: 1, top: 1, bottom: 1}, init: function (t, e) {
            this.ecModel = t, this.api = e, this.visualMapModel
        }, render: function (t) {
            return this.visualMapModel = t, t.get("show") === !1 ? void this.group.removeAll() : void this.doRender.apply(this, arguments)
        }, renderBackground: function (t) {
            var e = this.visualMapModel, i = dD(e.get("padding") || 0), n = t.getBoundingRect();
            t.add(new CA({
                z2: -1,
                silent: !0,
                shape: {x: n.x - i[3], y: n.y - i[0], width: n.width + i[3] + i[1], height: n.height + i[0] + i[2]},
                style: {fill: e.get("backgroundColor"), stroke: e.get("borderColor"), lineWidth: e.get("borderWidth")}
            }))
        }, getControllerVisual: function (t, e, i) {
            function n(t) {
                return s[t]
            }

            function o(t, e) {
                s[t] = e
            }

            i = i || {};
            var a = i.forceState, r = this.visualMapModel, s = {};
            if ("symbol" === e && (s.symbol = r.get("itemSymbol")), "color" === e) {
                var l = r.get("contentColor");
                s.color = l
            }
            var u = r.controllerVisuals[a || r.getValueState(t)], h = pE.prepareVisualTypes(u);
            return f(h, function (a) {
                var r = u[a];
                i.convertOpacityToAlpha && "opacity" === a && (a = "colorAlpha", r = u.__alphaForOpacity), pE.dependsOn(a, e) && r && r.applyVisual(t, n, o)
            }), s[e]
        }, positionGroup: function (t) {
            var e = this.visualMapModel, i = this.api;
            is(t, e.getBoxLayoutParams(), {width: i.getWidth(), height: i.getHeight()})
        }, doRender: G
    }), mG = Mr, vG = f, yG = Math.min, xG = Math.max, _G = 12, wG = 6, bG = gG.extend({
        type: "visualMap.continuous", init: function () {
            bG.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], this._dragging, this._hovering
        }, doRender: function (t, e, i, n) {
            n && "selectDataRange" === n.type && n.from === this.uid || this._buildView()
        }, _buildView: function () {
            this.group.removeAll();
            var t = this.visualMapModel, e = this.group;
            this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(e);
            var i = t.get("text");
            this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e)
        }, _renderEndsText: function (t, e, i) {
            if (e) {
                var n = e[1 - i];
                n = null != n ? n + "" : "";
                var o = this.visualMapModel, a = o.get("textGap"), r = o.itemSize, s = this._shapes.barGroup,
                    l = this._applyTransform([r[0] / 2, 0 === i ? -a : r[1] + a], s),
                    u = this._applyTransform(0 === i ? "bottom" : "top", s), h = this._orient,
                    c = this.visualMapModel.textStyleModel;
                this.group.add(new vA({
                    style: {
                        x: l[0],
                        y: l[1],
                        textVerticalAlign: "horizontal" === h ? "middle" : u,
                        textAlign: "horizontal" === h ? u : "center",
                        text: n,
                        textFont: c.getFont(),
                        textFill: c.getTextColor()
                    }
                }))
            }
        }, _renderBar: function (t) {
            var e = this.visualMapModel, i = this._shapes, n = e.itemSize, o = this._orient, a = this._useHandle,
                r = pb(e, this.api, n), s = i.barGroup = this._createBarGroup(r);
            s.add(i.outOfRange = mb()), s.add(i.inRange = mb(null, a ? wb(this._orient) : null, y(this._dragHandle, this, "all", !1), y(this._dragHandle, this, "all", !0)));
            var l = e.textStyleModel.getTextRect("国"), u = xG(l.width, l.height);
            a && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(s, 0, n, u, o, r), this._createHandle(s, 1, n, u, o, r)), this._createIndicator(s, n, u, o), t.add(s)
        }, _createHandle: function (t, e, i, n, o) {
            var a = y(this._dragHandle, this, e, !1), r = y(this._dragHandle, this, e, !0),
                s = mb(vb(e, n), wb(this._orient), a, r);
            s.position[0] = i[0], t.add(s);
            var l = this.visualMapModel.textStyleModel, u = new vA({
                draggable: !0, drift: a, onmousemove: function (t) {
                    vM(t.event)
                }, ondragend: r, style: {x: 0, y: 0, text: "", textFont: l.getFont(), textFill: l.getTextColor()}
            });
            this.group.add(u);
            var h = ["horizontal" === o ? n / 2 : 1.5 * n, "horizontal" === o ? 0 === e ? -(1.5 * n) : 1.5 * n : 0 === e ? -n / 2 : n / 2],
                c = this._shapes;
            c.handleThumbs[e] = s, c.handleLabelPoints[e] = h, c.handleLabels[e] = u
        }, _createIndicator: function (t, e, i, n) {
            var o = mb([[0, 0]], "move");
            o.position[0] = e[0], o.attr({invisible: !0, silent: !0}), t.add(o);
            var a = this.visualMapModel.textStyleModel, r = new vA({
                silent: !0,
                invisible: !0,
                style: {x: 0, y: 0, text: "", textFont: a.getFont(), textFill: a.getTextColor()}
            });
            this.group.add(r);
            var s = ["horizontal" === n ? i / 2 : wG + 3, 0], l = this._shapes;
            l.indicator = o, l.indicatorLabel = r, l.indicatorLabelPoint = s
        }, _dragHandle: function (t, e, i, n) {
            if (this._useHandle) {
                if (this._dragging = !e, !e) {
                    var o = this._applyTransform([i, n], this._shapes.barGroup, !0);
                    this._updateInterval(t, o[1]), this._updateView()
                }
                e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: this._dataInterval.slice()
                }), e ? !this._hovering && this._clearHoverLinkToSeries() : _b(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1)
            }
        }, _resetInterval: function () {
            var t = this.visualMapModel, e = this._dataInterval = t.getSelected(), i = t.getExtent(),
                n = [0, t.itemSize[1]];
            this._handleEnds = [mG(e[0], i, n, !0), mG(e[1], i, n, !0)]
        }, _updateInterval: function (t, e) {
            e = e || 0;
            var i = this.visualMapModel, n = this._handleEnds, o = [0, i.itemSize[1]];
            xR(e, n, o, t, 0);
            var a = i.getExtent();
            this._dataInterval = [mG(n[0], o, a, !0), mG(n[1], o, a, !0)]
        }, _updateView: function (t) {
            var e = this.visualMapModel, i = e.getExtent(), n = this._shapes, o = [0, e.itemSize[1]],
                a = t ? o : this._handleEnds, r = this._createBarVisual(this._dataInterval, i, a, "inRange"),
                s = this._createBarVisual(i, i, o, "outOfRange");
            n.inRange.setStyle({
                fill: r.barColor,
                opacity: r.opacity
            }).setShape("points", r.barPoints), n.outOfRange.setStyle({
                fill: s.barColor,
                opacity: s.opacity
            }).setShape("points", s.barPoints), this._updateHandle(a, r)
        }, _createBarVisual: function (t, e, i, n) {
            var o = {forceState: n, convertOpacityToAlpha: !0}, a = this._makeColorGradient(t, o),
                r = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)],
                s = this._createBarPoints(i, r);
            return {barColor: new zA(0, 0, 0, 1, a), barPoints: s, handlesColor: [a[0].color, a[a.length - 1].color]}
        }, _makeColorGradient: function (t, e) {
            var i = 100, n = [], o = (t[1] - t[0]) / i;
            n.push({color: this.getControllerVisual(t[0], "color", e), offset: 0});
            for (var a = 1; i > a; a++) {
                var r = t[0] + o * a;
                if (r > t[1]) break;
                n.push({color: this.getControllerVisual(r, "color", e), offset: a / i})
            }
            return n.push({color: this.getControllerVisual(t[1], "color", e), offset: 1}), n
        }, _createBarPoints: function (t, e) {
            var i = this.visualMapModel.itemSize;
            return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]]
        }, _createBarGroup: function (t) {
            var e = this._orient, i = this.visualMapModel.get("inverse");
            return new iI("horizontal" !== e || i ? "horizontal" === e && i ? {
                scale: "bottom" === t ? [-1, 1] : [1, 1],
                rotation: -Math.PI / 2
            } : "vertical" !== e || i ? {scale: "left" === t ? [1, 1] : [-1, 1]} : {scale: "left" === t ? [1, -1] : [-1, -1]} : {
                scale: "bottom" === t ? [1, 1] : [-1, 1],
                rotation: Math.PI / 2
            })
        }, _updateHandle: function (t, e) {
            if (this._useHandle) {
                var i = this._shapes, n = this.visualMapModel, o = i.handleThumbs, a = i.handleLabels;
                vG([0, 1], function (r) {
                    var s = o[r];
                    s.setStyle("fill", e.handlesColor[r]), s.position[1] = t[r];
                    var l = sr(i.handleLabelPoints[r], rr(s, this.group));
                    a[r].setStyle({
                        x: l[0],
                        y: l[1],
                        text: n.formatValueText(this._dataInterval[r]),
                        textVerticalAlign: "middle",
                        textAlign: this._applyTransform("horizontal" === this._orient ? 0 === r ? "bottom" : "top" : "left", i.barGroup)
                    })
                }, this)
            }
        }, _showIndicator: function (t, e, i, n) {
            var o = this.visualMapModel, a = o.getExtent(), r = o.itemSize, s = [0, r[1]], l = mG(t, a, s, !0),
                u = this._shapes, h = u.indicator;
            if (h) {
                h.position[1] = l, h.attr("invisible", !1), h.setShape("points", yb(!!i, n, l, r[1]));
                var c = {convertOpacityToAlpha: !0}, d = this.getControllerVisual(t, "color", c);
                h.setStyle("fill", d);
                var f = sr(u.indicatorLabelPoint, rr(h, this.group)), p = u.indicatorLabel;
                p.attr("invisible", !1);
                var g = this._applyTransform("left", u.barGroup), m = this._orient;
                p.setStyle({
                    text: (i ? i : "") + o.formatValueText(e),
                    textVerticalAlign: "horizontal" === m ? g : "middle",
                    textAlign: "horizontal" === m ? "center" : g,
                    x: f[0],
                    y: f[1]
                })
            }
        }, _enableHoverLinkToSeries: function () {
            var t = this;
            this._shapes.barGroup.on("mousemove", function (e) {
                if (t._hovering = !0, !t._dragging) {
                    var i = t.visualMapModel.itemSize,
                        n = t._applyTransform([e.offsetX, e.offsetY], t._shapes.barGroup, !0, !0);
                    n[1] = yG(xG(0, n[1]), i[1]), t._doHoverLinkToSeries(n[1], 0 <= n[0] && n[0] <= i[0])
                }
            }).on("mouseout", function () {
                t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries()
            })
        }, _enableHoverLinkFromSeries: function () {
            var t = this.api.getZr();
            this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries()
        }, _doHoverLinkToSeries: function (t, e) {
            var i = this.visualMapModel, n = i.itemSize;
            if (i.option.hoverLink) {
                var o = [0, n[1]], a = i.getExtent();
                t = yG(xG(o[0], t), o[1]);
                var r = xb(i, a, o), s = [t - r, t + r], l = mG(t, o, a, !0),
                    u = [mG(s[0], o, a, !0), mG(s[1], o, a, !0)];
                s[0] < o[0] && (u[0] = -1 / 0), s[1] > o[1] && (u[1] = 1 / 0), e && (u[0] === -1 / 0 ? this._showIndicator(l, u[1], "< ", r) : 1 / 0 === u[1] ? this._showIndicator(l, u[0], "> ", r) : this._showIndicator(l, l, "≈ ", r));
                var h = this._hoverLinkDataIndices, c = [];
                (e || _b(i)) && (c = this._hoverLinkDataIndices = i.findTargetDataIndices(u));
                var d = uo(h, c);
                this._dispatchHighDown("downplay", gb(d[0], i)), this._dispatchHighDown("highlight", gb(d[1], i))
            }
        }, _hoverLinkFromSeriesMouseOver: function (t) {
            var e = t.target, i = this.visualMapModel;
            if (e && null != e.dataIndex) {
                var n = this.ecModel.getSeriesByIndex(e.seriesIndex);
                if (i.isTargetSeries(n)) {
                    var o = n.getData(e.dataType), a = o.get(i.getDataDimension(o), e.dataIndex, !0);
                    isNaN(a) || this._showIndicator(a, a)
                }
            }
        }, _hideIndicator: function () {
            var t = this._shapes;
            t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0)
        }, _clearHoverLinkToSeries: function () {
            this._hideIndicator();
            var t = this._hoverLinkDataIndices;
            this._dispatchHighDown("downplay", gb(t, this.visualMapModel)), t.length = 0
        }, _clearHoverLinkFromSeries: function () {
            this._hideIndicator();
            var t = this.api.getZr();
            t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator)
        }, _applyTransform: function (t, e, i, n) {
            var o = rr(e, n ? null : this.group);
            return tD[_(t) ? "applyTransform" : "transformDirection"](t, o, i)
        }, _dispatchHighDown: function (t, e) {
            e && e.length && this.api.dispatchAction({type: t, batch: e})
        }, dispose: function () {
            this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
        }, remove: function () {
            this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
        }
    }), SG = {type: "selectDataRange", event: "dataRangeSelected", update: "update"};
    Pu(SG, function (t, e) {
        e.eachComponent({mainType: "visualMap", query: t}, function (e) {
            e.setSelected(t.selected)
        })
    }), Cu(eG);
    {
        var MG = dG.extend({
            type: "visualMap.piecewise",
            defaultOption: {
                selected: null,
                minOpen: !1,
                maxOpen: !1,
                align: "auto",
                itemWidth: 20,
                itemHeight: 14,
                itemSymbol: "roundRect",
                pieceList: null,
                categories: null,
                splitNumber: 5,
                selectedMode: "multiple",
                itemGap: 10,
                hoverLink: !0,
                showLabel: null
            },
            optionUpdated: function (t, e) {
                MG.superApply(this, "optionUpdated", arguments), this._pieceList = [], this.resetExtent();
                var i = this._mode = this._determineMode();
                IG[this._mode].call(this), this._resetSelected(t, e);
                var o = this.option.categories;
                this.resetVisual(function (t, e) {
                    "categories" === i ? (t.mappingMethod = "category", t.categories = n(o)) : (t.dataExtent = this.getExtent(), t.mappingMethod = "piecewise", t.pieceList = p(this._pieceList, function (t) {
                        var t = n(t);
                        return "inRange" !== e && (t.visual = null), t
                    }))
                })
            },
            completeVisualOption: function () {
                function t(t, e, i) {
                    return t && t[e] && (S(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i)
                }

                var e = this.option, i = {}, n = pE.listVisualTypes(), o = this.isCategory();
                f(e.pieces, function (t) {
                    f(n, function (e) {
                        t.hasOwnProperty(e) && (i[e] = 1)
                    })
                }), f(i, function (i, n) {
                    var a = 0;
                    f(this.stateList, function (i) {
                        a |= t(e, i, n) || t(e.target, i, n)
                    }, this), !a && f(this.stateList, function (t) {
                        (e[t] || (e[t] = {}))[n] = nG.get(n, "inRange" === t ? "active" : "inactive", o)
                    })
                }, this), dG.prototype.completeVisualOption.apply(this, arguments)
            },
            _resetSelected: function (t, e) {
                var i = this.option, n = this._pieceList, o = (e ? i : t).selected || {};
                if (i.selected = o, f(n, function (t) {
                    var e = this.getSelectedMapKey(t);
                    o.hasOwnProperty(e) || (o[e] = !0)
                }, this), "single" === i.selectedMode) {
                    var a = !1;
                    f(n, function (t) {
                        var e = this.getSelectedMapKey(t);
                        o[e] && (a ? o[e] = !1 : a = !0)
                    }, this)
                }
            },
            getSelectedMapKey: function (t) {
                return "categories" === this._mode ? t.value + "" : t.index + ""
            },
            getPieceList: function () {
                return this._pieceList
            },
            _determineMode: function () {
                var t = this.option;
                return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber"
            },
            setSelected: function (t) {
                this.option.selected = n(t)
            },
            getValueState: function (t) {
                var e = pE.findPieceIndex(t, this._pieceList);
                return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function (t) {
                var e = [];
                return this.eachTargetSeries(function (i) {
                    var n = [], o = i.getData();
                    o.each(this.getDataDimension(o), function (e, i) {
                        var o = pE.findPieceIndex(e, this._pieceList);
                        o === t && n.push(i)
                    }, this), e.push({seriesId: i.id, dataIndex: n})
                }, this), e
            },
            getRepresentValue: function (t) {
                var e;
                if (this.isCategory()) e = t.value; else if (null != t.value) e = t.value; else {
                    var i = t.interval || [];
                    e = i[0] === -1 / 0 && 1 / 0 === i[1] ? 0 : (i[0] + i[1]) / 2
                }
                return e
            },
            getVisualMeta: function (t) {
                function e(e, a) {
                    var r = o.getRepresentValue({interval: e});
                    a || (a = o.getValueState(r));
                    var s = t(r, a);
                    e[0] === -1 / 0 ? n[0] = s : 1 / 0 === e[1] ? n[1] = s : i.push({
                        value: e[0],
                        color: s
                    }, {value: e[1], color: s})
                }

                if (!this.isCategory()) {
                    var i = [], n = [], o = this, a = this._pieceList.slice();
                    if (a.length) {
                        var r = a[0].interval[0];
                        r !== -1 / 0 && a.unshift({interval: [-1 / 0, r]}), r = a[a.length - 1].interval[1], 1 / 0 !== r && a.push({interval: [r, 1 / 0]})
                    } else a.push({interval: [-1 / 0, 1 / 0]});
                    var s = -1 / 0;
                    return f(a, function (t) {
                        var i = t.interval;
                        i && (i[0] > s && e([s, i[0]], "outOfRange"), e(i.slice()), s = i[1])
                    }, this), {stops: i, outerColors: n}
                }
            }
        }), IG = {
            splitNumber: function () {
                var t = this.option, e = this._pieceList, i = Math.min(t.precision, 20), n = this.getExtent(),
                    o = t.splitNumber;
                o = Math.max(parseInt(o, 10), 1), t.splitNumber = o;
                for (var a = (n[1] - n[0]) / o; +a.toFixed(i) !== a && 5 > i;) i++;
                t.precision = i, a = +a.toFixed(i), t.minOpen && e.push({interval: [-1 / 0, n[0]], close: [0, 0]});
                for (var r = 0, s = n[0]; o > r; s += a, r++) {
                    var l = r === o - 1 ? n[1] : s + a;
                    e.push({interval: [s, l], close: [1, 1]})
                }
                t.maxOpen && e.push({interval: [n[1], 1 / 0], close: [0, 0]}), Vr(e), f(e, function (t, e) {
                    t.index = e, t.text = this.formatValueText(t.interval)
                }, this)
            }, categories: function () {
                var t = this.option;
                f(t.categories, function (t) {
                    this._pieceList.push({text: this.formatValueText(t, !0), value: t})
                }, this), bb(t, this._pieceList)
            }, pieces: function () {
                var t = this.option, e = this._pieceList;
                f(t.pieces, function (t, i) {
                    S(t) || (t = {value: t});
                    var n = {text: "", index: i};
                    if (null != t.label && (n.text = t.label), t.hasOwnProperty("value")) {
                        var o = n.value = t.value;
                        n.interval = [o, o], n.close = [1, 1]
                    } else {
                        for (var a = n.interval = [], r = n.close = [0, 0], s = [1, 0, 1], l = [-1 / 0, 1 / 0], u = [], h = 0; 2 > h; h++) {
                            for (var c = [["gte", "gt", "min"], ["lte", "lt", "max"]][h], d = 0; 3 > d && null == a[h]; d++) a[h] = t[c[d]], r[h] = s[d], u[h] = 2 === d;
                            null == a[h] && (a[h] = l[h])
                        }
                        u[0] && 1 / 0 === a[1] && (r[0] = 0), u[1] && a[0] === -1 / 0 && (r[1] = 0), BS && a[0] > a[1] && console.warn("Piece " + i + "is illegal: " + a + " lower bound should not greater then uppper bound."), a[0] === a[1] && r[0] && r[1] && (n.value = a[0])
                    }
                    n.visual = pE.retrieveVisuals(t), e.push(n)
                }, this), bb(t, e), Vr(e), f(e, function (t) {
                    var e = t.close, i = [["<", "≤"][e[1]], [">", "≥"][e[0]]];
                    t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, i)
                }, this)
            }
        };
        gG.extend({
            type: "visualMap.piecewise", doRender: function () {
                function t(t) {
                    var o = t.piece, u = new iI;
                    u.onclick = y(this._onItemClick, this, o), this._enableHoverLink(u, t.indexInModelPieceList);
                    var h = i.getRepresentValue(o);
                    if (this._createItemSymbol(u, h, [0, 0, l[0], l[1]]), c) {
                        var d = this.visualMapModel.getValueState(h);
                        u.add(new vA({
                            style: {
                                x: "right" === s ? -n : l[0] + n,
                                y: l[1] / 2,
                                text: o.text,
                                textVerticalAlign: "middle",
                                textAlign: s,
                                textFont: a,
                                textFill: r,
                                opacity: "outOfRange" === d ? .5 : 1
                            }
                        }))
                    }
                    e.add(u)
                }

                var e = this.group;
                e.removeAll();
                var i = this.visualMapModel, n = i.get("textGap"), o = i.textStyleModel, a = o.getFont(),
                    r = o.getTextColor(), s = this._getItemAlign(), l = i.itemSize, u = this._getViewData(),
                    h = u.endsText, c = D(i.get("showLabel", !0), !h);
                h && this._renderEndsText(e, h[0], l, c, s), f(u.viewPieceList, t, this), h && this._renderEndsText(e, h[1], l, c, s), bD(i.get("orient"), e, i.get("itemGap")), this.renderBackground(e), this.positionGroup(e)
            }, _enableHoverLink: function (t, e) {
                function i(t) {
                    var i = this.visualMapModel;
                    i.option.hoverLink && this.api.dispatchAction({type: t, batch: gb(i.findTargetDataIndices(e), i)})
                }

                t.on("mouseover", y(i, this, "highlight")).on("mouseout", y(i, this, "downplay"))
            }, _getItemAlign: function () {
                var t = this.visualMapModel, e = t.option;
                if ("vertical" === e.orient) return pb(t, this.api, t.itemSize);
                var i = e.align;
                return i && "auto" !== i || (i = "left"), i
            }, _renderEndsText: function (t, e, i, n, o) {
                if (e) {
                    var a = new iI, r = this.visualMapModel.textStyleModel;
                    a.add(new vA({
                        style: {
                            x: n ? "right" === o ? i[0] : 0 : i[0] / 2,
                            y: i[1] / 2,
                            textVerticalAlign: "middle",
                            textAlign: n ? o : "center",
                            text: e,
                            textFont: r.getFont(),
                            textFill: r.getTextColor()
                        }
                    })), t.add(a)
                }
            }, _getViewData: function () {
                var t = this.visualMapModel, e = p(t.getPieceList(), function (t, e) {
                    return {piece: t, indexInModelPieceList: e}
                }), i = t.get("text"), n = t.get("orient"), o = t.get("inverse");
                return ("horizontal" === n ? o : !o) ? e.reverse() : i && (i = i.slice().reverse()), {
                    viewPieceList: e,
                    endsText: i
                }
            }, _createItemSymbol: function (t, e, i) {
                t.add(ac(this.getControllerVisual(e, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")))
            }, _onItemClick: function (t) {
                var e = this.visualMapModel, i = e.option, o = n(i.selected), a = e.getSelectedMapKey(t);
                "single" === i.selectedMode ? (o[a] = !0, f(o, function (t, e) {
                    o[e] = e === a
                })) : o[a] = !o[a], this.api.dispatchAction({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: o
                })
            }
        })
    }
    Cu(eG);
    var TG = Vu({
        type: "toolbox",
        layoutMode: {type: "box", ignoreSize: !0},
        optionUpdated: function () {
            TG.superApply(this, "optionUpdated", arguments), f(this.option.feature, function (t, e) {
                var i = ub(e);
                i && o(t, i.defaultOption)
            })
        },
        defaultOption: {
            show: !0,
            z: 6,
            zlevel: 0,
            orient: "horizontal",
            left: "right",
            top: "top",
            backgroundColor: "transparent",
            borderColor: "#ccc",
            borderRadius: 0,
            borderWidth: 0,
            padding: 5,
            itemSize: 15,
            itemGap: 8,
            showTitle: !0,
            iconStyle: {borderColor: "#666", color: "none"},
            emphasis: {iconStyle: {borderColor: "#3E98C5"}},
            tooltip: {show: !1}
        }
    });
    Gu({
        type: "toolbox", render: function (t, e, i, n) {
            function o(o, r) {
                var s, l = c[o], d = c[r], f = u[l], p = new vr(f, t, t.ecModel);
                if (n && null != n.newTitle && n.featureName === l && (f.title = n.newTitle), l && !d) {
                    if (Sb(l)) s = {model: p, onclick: p.option.onclick, featureName: l}; else {
                        var g = ub(l);
                        if (!g) return;
                        s = new g(p, e, i)
                    }
                    h[l] = s
                } else {
                    if (s = h[d], !s) return;
                    s.model = p, s.ecModel = e, s.api = i
                }
                return !l && d ? void (s.dispose && s.dispose(e, i)) : !p.get("show") || s.unusable ? void (s.remove && s.remove(e, i)) : (a(p, s, l), p.setIconStatus = function (t, e) {
                    var i = this.option, n = this.iconPaths;
                    i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t].trigger(e)
                }, void (s.render && s.render(p, e, i, n)))
            }

            function a(n, o, a) {
                var u = n.getModel("iconStyle"), h = n.getModel("emphasis.iconStyle"),
                    c = o.getIcons ? o.getIcons() : n.get("icon"), d = n.get("title") || {};
                if ("string" == typeof c) {
                    var p = c, g = d;
                    c = {}, d = {}, c[a] = p, d[a] = g
                }
                var m = n.iconPaths = {};
                f(c, function (a, c) {
                    var f = dr(a, {}, {x: -l / 2, y: -l / 2, width: l, height: l});
                    f.setStyle(u.getItemStyle()), f.hoverStyle = h.getItemStyle(), f.setStyle({
                        text: d[c],
                        textAlign: h.get("textAlign"),
                        textBorderRadius: h.get("textBorderRadius"),
                        textPadding: h.get("textPadding"),
                        textFill: null
                    });
                    var p = t.getModel("tooltip");
                    p && p.get("show") && f.attr("tooltip", r({
                        content: d[c],
                        formatter: p.get("formatter", !0) || function () {
                            return d[c]
                        },
                        formatterParams: {componentType: "toolbox", name: c, title: d[c], $vars: ["name", "title"]},
                        position: p.get("position", !0) || "bottom"
                    }, p.option)), Wa(f), t.get("showTitle") && (f.__title = d[c], f.on("mouseover", function () {
                        var e = h.getItemStyle(),
                            i = "vertical" === t.get("orient") ? null == t.get("right") ? "right" : "left" : null == t.get("bottom") ? "bottom" : "top";
                        f.setStyle({
                            textFill: h.get("textFill") || e.fill || e.stroke || "#000",
                            textBackgroundColor: h.get("textBackgroundColor"),
                            textPosition: h.get("textPosition") || i
                        })
                    }).on("mouseout", function () {
                        f.setStyle({textFill: null, textBackgroundColor: null})
                    })), f.trigger(n.get("iconStatus." + c) || "normal"), s.add(f), f.on("click", y(o.onclick, o, e, i, c)), m[c] = f
                })
            }

            var s = this.group;
            if (s.removeAll(), t.get("show")) {
                var l = +t.get("itemSize"), u = t.get("feature") || {}, h = this._features || (this._features = {}),
                    c = [];
                f(u, function (t, e) {
                    c.push(e)
                }), new Yu(this._featureNames || [], c).add(o).update(o).remove(x(o, null)).execute(), this._featureNames = c, b_(s, t, i), s.add(S_(s.getBoundingRect(), t)), s.eachChild(function (t) {
                    var e = t.__title, n = t.hoverStyle;
                    if (n && e) {
                        var o = Xi(e, ln(n)), a = t.position[0] + s.position[0], r = t.position[1] + s.position[1] + l,
                            u = !1;
                        r + o.height > i.getHeight() && (n.textPosition = "top", u = !0);
                        var h = u ? -5 - o.height : l + 8;
                        a + o.width / 2 > i.getWidth() ? (n.textPosition = ["100%", h], n.textAlign = "right") : a - o.width / 2 < 0 && (n.textPosition = [0, h], n.textAlign = "left")
                    }
                })
            }
        }, updateView: function (t, e, i, n) {
            f(this._features, function (t) {
                t.updateView && t.updateView(t.model, e, i, n)
            })
        }, remove: function (t, e) {
            f(this._features, function (i) {
                i.remove && i.remove(t, e)
            }), this.group.removeAll()
        }, dispose: function (t, e) {
            f(this._features, function (i) {
                i.dispose && i.dispose(t, e)
            })
        }
    });
    var AG = MC.toolbox.saveAsImage;
    Mb.defaultOption = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: AG.title,
        type: "png",
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        pixelRatio: 1,
        lang: AG.lang.slice()
    }, Mb.prototype.unusable = !WS.canvasSupported;
    var DG = Mb.prototype;
    DG.onclick = function (t, e) {
        var i = this.model, n = i.get("name") || t.get("title.0.text") || "echarts",
            o = "svg" === e.getZr().painter.getType(), a = o ? "svg" : i.get("type", !0) || "png",
            r = e.getConnectedDataURL({
                type: a,
                backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
                connectedBackgroundColor: i.get("connectedBackgroundColor"),
                excludeComponents: i.get("excludeComponents"),
                pixelRatio: i.get("pixelRatio")
            });
        if ("function" != typeof MouseEvent || WS.browser.ie || WS.browser.edge) if (window.navigator.msSaveOrOpenBlob) {
            for (var s = atob(r.split(",")[1]), l = s.length, u = new Uint8Array(l); l--;) u[l] = s.charCodeAt(l);
            var h = new Blob([u]);
            window.navigator.msSaveOrOpenBlob(h, n + "." + a)
        } else {
            var c = i.get("lang"),
                d = '<body style="margin:0;"><img src="' + r + '" style="max-width:100%;" title="' + (c && c[0] || "") + '" /></body>',
                f = window.open();
            f.document.write(d)
        } else {
            var p = document.createElement("a");
            p.download = n + "." + a, p.target = "_blank", p.href = r;
            var g = new MouseEvent("click", {view: document.defaultView, bubbles: !0, cancelable: !1});
            p.dispatchEvent(g)
        }
    }, lb("saveAsImage", Mb);
    var CG = MC.toolbox.magicType, LG = "__ec_magicType_stack__";
    Ib.defaultOption = {
        show: !0,
        type: [],
        icon: {
            line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
            bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
            stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
        },
        title: n(CG.title),
        option: {},
        seriesIndex: {}
    };
    var kG = Ib.prototype;
    kG.getIcons = function () {
        var t = this.model, e = t.get("icon"), i = {};
        return f(t.get("type"), function (t) {
            e[t] && (i[t] = e[t])
        }), i
    };
    var PG = {
        line: function (t, e, i, n) {
            return "bar" === t ? o({
                id: e,
                type: "line",
                data: i.get("data"),
                stack: i.get("stack"),
                markPoint: i.get("markPoint"),
                markLine: i.get("markLine")
            }, n.get("option.line") || {}, !0) : void 0
        }, bar: function (t, e, i, n) {
            return "line" === t ? o({
                id: e,
                type: "bar",
                data: i.get("data"),
                stack: i.get("stack"),
                markPoint: i.get("markPoint"),
                markLine: i.get("markLine")
            }, n.get("option.bar") || {}, !0) : void 0
        }, stack: function (t, e, i, n) {
            var a = i.get("stack") === LG;
            return "line" === t || "bar" === t ? (n.setIconStatus("stack", a ? "normal" : "emphasis"), o({
                id: e,
                stack: a ? "" : LG
            }, n.get("option.stack") || {}, !0)) : void 0
        }
    }, OG = [["line", "bar"], ["stack"]];
    kG.onclick = function (t, e, i) {
        var a = this.model, r = a.get("seriesIndex." + i);
        if (PG[i]) {
            var l = {series: []}, h = function (e) {
                var n = e.subType, o = e.id, r = PG[i](n, o, e, a);
                r && (s(r, e.option), l.series.push(r));
                var u = e.coordinateSystem;
                if (u && "cartesian2d" === u.type && ("line" === i || "bar" === i)) {
                    var h = u.getAxesByScale("ordinal")[0];
                    if (h) {
                        var c = h.dim, d = c + "Axis", f = t.queryComponents({
                            mainType: d,
                            index: e.get(name + "Index"),
                            id: e.get(name + "Id")
                        })[0], p = f.componentIndex;
                        l[d] = l[d] || [];
                        for (var g = 0; p >= g; g++) l[d][p] = l[d][p] || {};
                        l[d][p].boundaryGap = "bar" === i
                    }
                }
            };
            f(OG, function (t) {
                u(t, i) >= 0 && f(t, function (t) {
                    a.setIconStatus(t, "normal")
                })
            }), a.setIconStatus(i, "emphasis"), t.eachComponent({
                mainType: "series",
                query: null == r ? null : {seriesIndex: r}
            }, h);
            var c;
            if ("stack" === i) {
                var d = l.series && l.series[0] && l.series[0].stack === LG;
                c = d ? o({stack: CG.title.tiled}, CG.title) : n(CG.title)
            }
            e.dispatchAction({
                type: "changeMagicType",
                currentType: i,
                newOption: l,
                newTitle: c,
                featureName: "magicType"
            })
        }
    }, Pu({type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate"}, function (t, e) {
        e.mergeOption(t.newOption)
    }), lb("magicType", Ib);
    var EG = MC.toolbox.dataView, NG = new Array(60).join("-"), RG = "    ", zG = new RegExp("[" + RG + "]+", "g");
    Nb.defaultOption = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: n(EG.title),
        lang: n(EG.lang),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
    }, Nb.prototype.onclick = function (t, e) {
        function i() {
            n.removeChild(a), x._dom = null
        }

        var n = e.getDom(), o = this.model;
        this._dom && n.removeChild(this._dom);
        var a = document.createElement("div");
        a.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", a.style.backgroundColor = o.get("backgroundColor") || "#fff";
        var r = document.createElement("h4"), s = o.get("lang") || [];
        r.innerHTML = s[0] || o.get("title"), r.style.cssText = "margin: 10px 20px;", r.style.color = o.get("textColor");
        var l = document.createElement("div"), u = document.createElement("textarea");
        l.style.cssText = "display:block;width:100%;overflow:auto;";
        var h = o.get("optionToContent"), c = o.get("contentToOption"), d = Cb(t);
        if ("function" == typeof h) {
            var f = h(e.getOption());
            "string" == typeof f ? l.innerHTML = f : T(f) && l.appendChild(f)
        } else l.appendChild(u), u.readOnly = o.get("readOnly"), u.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", u.style.color = o.get("textColor"), u.style.borderColor = o.get("textareaBorderColor"), u.style.backgroundColor = o.get("textareaColor"), u.value = d.value;
        var p = d.meta, g = document.createElement("div");
        g.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
        var m = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
            v = document.createElement("div"), y = document.createElement("div");
        m += ";background-color:" + o.get("buttonColor"), m += ";color:" + o.get("buttonTextColor");
        var x = this;
        Se(v, "click", i), Se(y, "click", function () {
            var t;
            try {
                t = "function" == typeof c ? c(l, e.getOption()) : Eb(u.value, p)
            } catch (n) {
                throw i(), new Error("Data view format error " + n)
            }
            t && e.dispatchAction({type: "changeDataView", newOption: t}), i()
        }), v.innerHTML = s[1], y.innerHTML = s[2], y.style.cssText = m, v.style.cssText = m, !o.get("readOnly") && g.appendChild(y), g.appendChild(v), a.appendChild(r), a.appendChild(l), a.appendChild(g), l.style.height = n.clientHeight - 80 + "px", n.appendChild(a), this._dom = a
    }, Nb.prototype.remove = function (t, e) {
        this._dom && e.getDom().removeChild(this._dom)
    }, Nb.prototype.dispose = function (t, e) {
        this.remove(t, e)
    }, lb("dataView", Nb), Pu({
        type: "changeDataView",
        event: "dataViewChanged",
        update: "prepareAndUpdate"
    }, function (t, e) {
        var i = [];
        f(t.newOption.series, function (t) {
            var n = e.getSeriesByName(t.name)[0];
            if (n) {
                var o = n.get("data");
                i.push({name: t.name, data: Rb(t.data, o)})
            } else i.push(r({type: "scatter"}, t))
        }), e.mergeOption(s({series: i}, t.newOption))
    });
    var BG = f, VG = "\x00_ec_hist_store";
    hV.extend({type: "dataZoom.select"}), cV.extend({type: "dataZoom.select"});
    var GG = MC.toolbox.dataZoom, FG = f, WG = "\x00_ec_\x00toolbox-dataZoom_";
    Wb.defaultOption = {
        show: !0,
        filterMode: "filter",
        icon: {
            zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
            back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: n(GG.title),
        brushStyle: {borderWidth: 0, color: "rgba(0,0,0,0.2)"}
    };
    var HG = Wb.prototype;
    HG.render = function (t, e, i, n) {
        this.model = t, this.ecModel = e, this.api = i, Ub(t, e, this, n, i), Zb(t, e)
    }, HG.onclick = function (t, e, i) {
        ZG[i].call(this)
    }, HG.remove = function () {
        this._brushController.unmount()
    }, HG.dispose = function () {
        this._brushController.dispose()
    };
    var ZG = {
        zoom: function () {
            var t = !this._isZoomActive;
            this.api.dispatchAction({type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: t})
        }, back: function () {
            this._dispatchZoomAction(Bb(this.ecModel))
        }
    };
    HG._onBrush = function (t, e) {
        function i(t, e, i) {
            var r = e.getAxis(t), s = r.model, l = n(t, s, a), u = l.findRepresentativeAxisProxy(s).getMinMaxSpan();
            (null != u.minValueSpan || null != u.maxValueSpan) && (i = xR(0, i.slice(), r.scale.getExtent(), 0, u.minValueSpan, u.maxValueSpan)), l && (o[l.id] = {
                dataZoomId: l.id,
                startValue: i[0],
                endValue: i[1]
            })
        }

        function n(t, e, i) {
            var n;
            return i.eachComponent({mainType: "dataZoom", subType: "select"}, function (i) {
                var o = i.getAxisModel(t, e.componentIndex);
                o && (n = i)
            }), n
        }

        if (e.isEnd && t.length) {
            var o = {}, a = this.ecModel;
            this._brushController.updateCovers([]);
            var r = new Uw(Hb(this.model.option), a, {include: ["grid"]});
            r.matchOutputRanges(t, a, function (t, e, n) {
                if ("cartesian2d" === n.type) {
                    var o = t.brushType;
                    "rect" === o ? (i("x", n, e[0]), i("y", n, e[1])) : i({lineX: "x", lineY: "y"}[o], n, e)
                }
            }), zb(a, o), this._dispatchZoomAction(o)
        }
    }, HG._dispatchZoomAction = function (t) {
        var e = [];
        FG(t, function (t) {
            e.push(n(t))
        }), e.length && this.api.dispatchAction({type: "dataZoom", from: this.uid, batch: e})
    }, lb("dataZoom", Wb), Cu(function (t) {
        function e(t, e) {
            if (e) {
                var o = t + "Index", a = e[o];
                null == a || "all" === a || _(a) || (a = a === !1 || "none" === a ? [] : [a]), i(t, function (i, r) {
                    if (null == a || "all" === a || -1 !== u(a, r)) {
                        var s = {
                            type: "select",
                            $fromToolbox: !0,
                            filterMode: e.filterMode || "filter",
                            id: WG + t + r
                        };
                        s[o] = r, n.push(s)
                    }
                })
            }
        }

        function i(e, i) {
            var n = t[e];
            _(n) || (n = n ? [n] : []), FG(n, i)
        }

        if (t) {
            var n = t.dataZoom || (t.dataZoom = []);
            _(n) || (t.dataZoom = n = [n]);
            var o = t.toolbox;
            if (o && (_(o) && (o = o[0]), o && o.feature)) {
                var a = o.feature.dataZoom;
                e("xAxis", a), e("yAxis", a)
            }
        }
    });
    var UG = MC.toolbox.restore;
    Xb.defaultOption = {
        show: !0,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: UG.title
    };
    var XG = Xb.prototype;
    XG.onclick = function (t, e) {
        Vb(t), e.dispatchAction({type: "restore", from: this.uid})
    }, lb("restore", Xb), Pu({type: "restore", event: "restore", update: "prepareAndUpdate"}, function (t, e) {
        e.resetOption("recreate")
    });
    var YG = {path: null, compoundPath: null, group: iI, image: Cn, text: vA};
    Cu(function (t) {
        var e = t.graphic;
        _(e) ? t.graphic = e[0] && e[0].elements ? [t.graphic[0]] : [{elements: e}] : e && !e.elements && (t.graphic = [{elements: [e]}])
    });
    var jG = Vu({
        type: "graphic",
        defaultOption: {elements: [], parentId: null},
        _elOptionsToUpdate: null,
        mergeOption: function () {
            var t = this.option.elements;
            this.option.elements = null, jG.superApply(this, "mergeOption", arguments), this.option.elements = t
        },
        optionUpdated: function (t, e) {
            var i = this.option, n = (e ? i : t).elements, o = i.elements = e ? [] : i.elements, a = [];
            this._flatten(n, a);
            var r = ao(o, a);
            ro(r);
            var s = this._elOptionsToUpdate = [];
            f(r, function (t, e) {
                var i = t.option;
                BS && O(S(i) || t.exist, "Empty graphic option definition"), i && (s.push(i), $b(t, i), Jb(o, e, i), Qb(o[e], i))
            }, this);
            for (var l = o.length - 1; l >= 0; l--) null == o[l] ? o.splice(l, 1) : delete o[l].$action
        },
        _flatten: function (t, e, i) {
            f(t, function (t) {
                if (t) {
                    i && (t.parentOption = i), e.push(t);
                    var n = t.children;
                    "group" === t.type && n && this._flatten(n, e, t), delete t.children
                }
            }, this)
        },
        useElOptionsToUpdate: function () {
            var t = this._elOptionsToUpdate;
            return this._elOptionsToUpdate = null, t
        }
    });
    Gu({
        type: "graphic", init: function () {
            this._elMap = B(), this._lastGraphicModel
        }, render: function (t, e, i) {
            t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i)
        }, _updateElements: function (t) {
            var e = t.useElOptionsToUpdate();
            if (e) {
                var i = this._elMap, n = this.group;
                f(e, function (e) {
                    var o = e.$action, a = e.id, r = i.get(a), s = e.parentId, l = null != s ? i.get(s) : n,
                        u = e.style;
                    "text" === e.type && u && (e.hv && e.hv[1] && (u.textVerticalAlign = u.textBaseline = null), !u.hasOwnProperty("textFill") && u.fill && (u.textFill = u.fill), !u.hasOwnProperty("textStroke") && u.stroke && (u.textStroke = u.stroke));
                    var h = qb(e);
                    BS && r && O(l === r.parent, "Changing parent is not supported."), o && "merge" !== o ? "replace" === o ? (jb(r, i), Yb(a, l, h, i)) : "remove" === o && jb(r, i) : r ? r.attr(h) : Yb(a, l, h, i);
                    var c = i.get(a);
                    c && (c.__ecGraphicWidthOption = e.width, c.__ecGraphicHeightOption = e.height, tS(c, t, e))
                })
            }
        }, _relocate: function (t, e) {
            for (var i = t.option.elements, n = this.group, o = this._elMap, a = e.getWidth(), r = e.getHeight(), s = 0; s < i.length; s++) {
                var l = i[s], u = o.get(l.id);
                if (u && u.isGroup) {
                    var h = u.parent, c = h === n;
                    u.__ecGraphicWidth = Ir(u.__ecGraphicWidthOption, c ? a : h.__ecGraphicWidth) || 0, u.__ecGraphicHeight = Ir(u.__ecGraphicHeightOption, c ? r : h.__ecGraphicHeight) || 0
                }
            }
            for (var s = i.length - 1; s >= 0; s--) {
                var l = i[s], u = o.get(l.id);
                if (u) {
                    var h = u.parent,
                        d = h === n ? {width: a, height: r} : {width: h.__ecGraphicWidth, height: h.__ecGraphicHeight};
                    is(u, l, d, null, {hv: l.hv, boundingMode: l.bounding})
                }
            }
        }, _clear: function () {
            var t = this._elMap;
            t.each(function (e) {
                jb(e, t)
            }), this._elMap = B()
        }, dispose: function () {
            this._clear()
        }
    });
    var qG, KG = "urn:schemas-microsoft-com:vml", $G = "undefined" == typeof window ? null : window, JG = !1,
        QG = $G && $G.document;
    if (QG && !WS.canvasSupported) try {
        !QG.namespaces.zrvml && QG.namespaces.add("zrvml", KG), qG = function (t) {
            return QG.createElement("<zrvml:" + t + ' class="zrvml">')
        }
    } catch (tF) {
        qG = function (t) {
            return QG.createElement("<" + t + ' xmlns="' + KG + '" class="zrvml">')
        }
    }
    var eF = XT.CMD, iF = Math.round, nF = Math.sqrt, oF = Math.abs, aF = Math.cos, rF = Math.sin, sF = Math.max;
    if (!WS.canvasSupported) {
        var lF = ",", uF = "progid:DXImageTransform.Microsoft", hF = 21600, cF = hF / 2, dF = 1e5, fF = 1e3,
            pF = function (t) {
                t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = hF + "," + hF, t.coordorigin = "0,0"
            }, gF = function (t) {
                return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
            }, mF = function (t, e, i) {
                return "rgb(" + [t, e, i].join(",") + ")"
            }, vF = function (t, e) {
                e && t && e.parentNode !== t && t.appendChild(e)
            }, yF = function (t, e) {
                e && t && e.parentNode === t && t.removeChild(e)
            }, xF = function (t, e, i) {
                return (parseFloat(t) || 0) * dF + (parseFloat(e) || 0) * fF + i
            }, _F = In, wF = function (t, e, i) {
                var n = ti(e);
                i = +i, isNaN(i) && (i = 1), n && (t.color = mF(n[0], n[1], n[2]), t.opacity = i * n[3])
            }, bF = function (t) {
                var e = ti(t);
                return [mF(e[0], e[1], e[2]), e[3]]
            }, SF = function (t, e, i) {
                var n = e.fill;
                if (null != n) if (n instanceof RA) {
                    var o, a = 0, r = [0, 0], s = 0, l = 1, u = i.getBoundingRect(), h = u.width, c = u.height;
                    if ("linear" === n.type) {
                        o = "gradient";
                        var d = i.transform, f = [n.x * h, n.y * c], p = [n.x2 * h, n.y2 * c];
                        d && (ae(f, f, d), ae(p, p, d));
                        var g = p[0] - f[0], m = p[1] - f[1];
                        a = 180 * Math.atan2(g, m) / Math.PI, 0 > a && (a += 360), 1e-6 > a && (a = 0)
                    } else {
                        o = "gradientradial";
                        var f = [n.x * h, n.y * c], d = i.transform, v = i.scale, y = h, x = c;
                        r = [(f[0] - u.x) / y, (f[1] - u.y) / x], d && ae(f, f, d), y /= v[0] * hF, x /= v[1] * hF;
                        var _ = sF(y, x);
                        s = 0 / _, l = 2 * n.r / _ - s
                    }
                    var w = n.colorStops.slice();
                    w.sort(function (t, e) {
                        return t.offset - e.offset
                    });
                    for (var b = w.length, S = [], M = [], I = 0; b > I; I++) {
                        var T = w[I], A = bF(T.color);
                        M.push(T.offset * l + s + " " + A[0]), (0 === I || I === b - 1) && S.push(A)
                    }
                    if (b >= 2) {
                        var D = S[0][0], C = S[1][0], L = S[0][1] * e.opacity, k = S[1][1] * e.opacity;
                        t.type = o, t.method = "none", t.focus = "100%", t.angle = a, t.color = D, t.color2 = C, t.colors = M.join(","), t.opacity = k, t.opacity2 = L
                    }
                    "radial" === o && (t.focusposition = r.join(","))
                } else wF(t, n, e.opacity)
            }, MF = function (t, e) {
                e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e.stroke || e.stroke instanceof RA || wF(t, e.stroke, e.opacity)
            }, IF = function (t, e, i, n) {
                var o = "fill" === e, a = t.getElementsByTagName(e)[0];
                null != i[e] && "none" !== i[e] && (o || !o && i.lineWidth) ? (t[o ? "filled" : "stroked"] = "true", i[e] instanceof RA && yF(t, a), a || (a = eS(e)), o ? SF(a, i, n) : MF(a, i), vF(t, a)) : (t[o ? "filled" : "stroked"] = "false", yF(t, a))
            }, TF = [[], [], []], AF = function (t, e) {
                var i, n, o, a, r, s, l = eF.M, u = eF.C, h = eF.L, c = eF.A, d = eF.Q, f = [], p = t.data, g = t.len();
                for (a = 0; g > a;) {
                    switch (o = p[a++], n = "", i = 0, o) {
                        case l:
                            n = " m ", i = 1, r = p[a++], s = p[a++], TF[0][0] = r, TF[0][1] = s;
                            break;
                        case h:
                            n = " l ", i = 1, r = p[a++], s = p[a++], TF[0][0] = r, TF[0][1] = s;
                            break;
                        case d:
                        case u:
                            n = " c ", i = 3;
                            var m, v, y = p[a++], x = p[a++], _ = p[a++], w = p[a++];
                            o === d ? (m = _, v = w, _ = (_ + 2 * y) / 3, w = (w + 2 * x) / 3, y = (r + 2 * y) / 3, x = (s + 2 * x) / 3) : (m = p[a++], v = p[a++]), TF[0][0] = y, TF[0][1] = x, TF[1][0] = _, TF[1][1] = w, TF[2][0] = m, TF[2][1] = v, r = m, s = v;
                            break;
                        case c:
                            var b = 0, S = 0, M = 1, I = 1, T = 0;
                            e && (b = e[4], S = e[5], M = nF(e[0] * e[0] + e[1] * e[1]), I = nF(e[2] * e[2] + e[3] * e[3]), T = Math.atan2(-e[1] / I, e[0] / M));
                            var A = p[a++], D = p[a++], C = p[a++], L = p[a++], k = p[a++] + T, P = p[a++] + k + T;
                            a++;
                            var O = p[a++], E = A + aF(k) * C, N = D + rF(k) * L, y = A + aF(P) * C, x = D + rF(P) * L,
                                R = O ? " wa " : " at ";
                            Math.abs(E - y) < 1e-4 && (Math.abs(P - k) > .01 ? O && (E += 270 / hF) : Math.abs(N - D) < 1e-4 ? O && A > E || !O && E > A ? x -= 270 / hF : x += 270 / hF : O && D > N || !O && N > D ? y += 270 / hF : y -= 270 / hF), f.push(R, iF(((A - C) * M + b) * hF - cF), lF, iF(((D - L) * I + S) * hF - cF), lF, iF(((A + C) * M + b) * hF - cF), lF, iF(((D + L) * I + S) * hF - cF), lF, iF((E * M + b) * hF - cF), lF, iF((N * I + S) * hF - cF), lF, iF((y * M + b) * hF - cF), lF, iF((x * I + S) * hF - cF)), r = y, s = x;
                            break;
                        case eF.R:
                            var z = TF[0], B = TF[1];
                            z[0] = p[a++], z[1] = p[a++], B[0] = z[0] + p[a++], B[1] = z[1] + p[a++], e && (ae(z, z, e), ae(B, B, e)), z[0] = iF(z[0] * hF - cF), B[0] = iF(B[0] * hF - cF), z[1] = iF(z[1] * hF - cF), B[1] = iF(B[1] * hF - cF), f.push(" m ", z[0], lF, z[1], " l ", B[0], lF, z[1], " l ", B[0], lF, B[1], " l ", z[0], lF, B[1]);
                            break;
                        case eF.Z:
                            f.push(" x ")
                    }
                    if (i > 0) {
                        f.push(n);
                        for (var V = 0; i > V; V++) {
                            var G = TF[V];
                            e && ae(G, G, e), f.push(iF(G[0] * hF - cF), lF, iF(G[1] * hF - cF), i - 1 > V ? lF : "")
                        }
                    }
                }
                return f.join("")
            };
        aa.prototype.brushVML = function (t) {
            var e = this.style, i = this._vmlEl;
            i || (i = eS("shape"), pF(i), this._vmlEl = i), IF(i, "fill", e, this), IF(i, "stroke", e, this);
            var n = this.transform, o = null != n, a = i.getElementsByTagName("stroke")[0];
            if (a) {
                var r = e.lineWidth;
                if (o && !e.strokeNoScale) {
                    var s = n[0] * n[3] - n[1] * n[2];
                    r *= nF(oF(s))
                }
                a.weight = r + "px"
            }
            var l = this.path || (this.path = new XT);
            this.__dirtyPath && (l.beginPath(), l.subPixelOptimize = !1, this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), i.path = AF(l, this.transform), i.style.zIndex = xF(this.zlevel, this.z, this.z2), vF(t, i), null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t)
        }, aa.prototype.onRemove = function (t) {
            yF(t, this._vmlEl), this.removeRectText(t)
        }, aa.prototype.onAdd = function (t) {
            vF(t, this._vmlEl), this.appendRectText(t)
        };
        var DF = function (t) {
            return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
        };
        Cn.prototype.brushVML = function (t) {
            var e, i, n = this.style, o = n.image;
            if (DF(o)) {
                var a = o.src;
                if (a === this._imageSrc) e = this._imageWidth, i = this._imageHeight; else {
                    var r = o.runtimeStyle, s = r.width, l = r.height;
                    r.width = "auto", r.height = "auto", e = o.width, i = o.height, r.width = s, r.height = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i
                }
                o = a
            } else o === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
            if (o) {
                var u = n.x || 0, h = n.y || 0, c = n.width, d = n.height, f = n.sWidth, p = n.sHeight, g = n.sx || 0,
                    m = n.sy || 0, v = f && p, y = this._vmlEl;
                y || (y = QG.createElement("div"), pF(y), this._vmlEl = y);
                var x, _ = y.style, w = !1, b = 1, S = 1;
                if (this.transform && (x = this.transform, b = nF(x[0] * x[0] + x[1] * x[1]), S = nF(x[2] * x[2] + x[3] * x[3]), w = x[1] || x[2]), w) {
                    var M = [u, h], I = [u + c, h], T = [u, h + d], A = [u + c, h + d];
                    ae(M, M, x), ae(I, I, x), ae(T, T, x), ae(A, A, x);
                    var D = sF(M[0], I[0], T[0], A[0]), C = sF(M[1], I[1], T[1], A[1]), L = [];
                    L.push("M11=", x[0] / b, lF, "M12=", x[2] / S, lF, "M21=", x[1] / b, lF, "M22=", x[3] / S, lF, "Dx=", iF(u * b + x[4]), lF, "Dy=", iF(h * S + x[5])), _.padding = "0 " + iF(D) + "px " + iF(C) + "px 0", _.filter = uF + ".Matrix(" + L.join("") + ", SizingMethod=clip)"
                } else x && (u = u * b + x[4], h = h * S + x[5]), _.filter = "", _.left = iF(u) + "px", _.top = iF(h) + "px";
                var k = this._imageEl, P = this._cropEl;
                k || (k = QG.createElement("div"), this._imageEl = k);
                var O = k.style;
                if (v) {
                    if (e && i) O.width = iF(b * e * c / f) + "px", O.height = iF(S * i * d / p) + "px"; else {
                        var E = new Image, N = this;
                        E.onload = function () {
                            E.onload = null, e = E.width, i = E.height, O.width = iF(b * e * c / f) + "px", O.height = iF(S * i * d / p) + "px", N._imageWidth = e, N._imageHeight = i, N._imageSrc = o
                        }, E.src = o
                    }
                    P || (P = QG.createElement("div"), P.style.overflow = "hidden", this._cropEl = P);
                    var R = P.style;
                    R.width = iF((c + g * c / f) * b), R.height = iF((d + m * d / p) * S), R.filter = uF + ".Matrix(Dx=" + -g * c / f * b + ",Dy=" + -m * d / p * S + ")", P.parentNode || y.appendChild(P), k.parentNode !== P && P.appendChild(k)
                } else O.width = iF(b * c) + "px", O.height = iF(S * d) + "px", y.appendChild(k), P && P.parentNode && (y.removeChild(P), this._cropEl = null);
                var z = "", B = n.opacity;
                1 > B && (z += ".Alpha(opacity=" + iF(100 * B) + ") "), z += uF + ".AlphaImageLoader(src=" + o + ", SizingMethod=scale)", O.filter = z, y.style.zIndex = xF(this.zlevel, this.z, this.z2), vF(t, y), null != n.text && this.drawRectText(t, this.getBoundingRect())
            }
        }, Cn.prototype.onRemove = function (t) {
            yF(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t)
        }, Cn.prototype.onAdd = function (t) {
            vF(t, this._vmlEl), this.appendRectText(t)
        };
        var CF, LF = "normal", kF = {}, PF = 0, OF = 100, EF = document.createElement("div"), NF = function (t) {
            var e = kF[t];
            if (!e) {
                PF > OF && (PF = 0, kF = {});
                var i, n = EF.style;
                try {
                    n.font = t, i = n.fontFamily.split(",")[0]
                } catch (o) {
                }
                e = {
                    style: n.fontStyle || LF,
                    variant: n.fontVariant || LF,
                    weight: n.fontWeight || LF,
                    size: 0 | parseFloat(n.fontSize || 12),
                    family: i || "Microsoft YaHei"
                }, kF[t] = e, PF++
            }
            return e
        };
        Zi("measureText", function (t, e) {
            var i = QG;
            CF || (CF = i.createElement("div"), CF.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", QG.body.appendChild(CF));
            try {
                CF.style.font = e
            } catch (n) {
            }
            return CF.innerHTML = "", CF.appendChild(i.createTextNode(t)), {width: CF.offsetWidth}
        });
        for (var RF = new Ti, zF = function (t, e, i, n) {
            var o = this.style;
            this.__dirty && hn(o, !0);
            var a = o.text;
            if (null != a && (a += ""), a) {
                if (o.rich) {
                    var r = rn(a, o);
                    a = [];
                    for (var s = 0; s < r.lines.length; s++) {
                        for (var l = r.lines[s].tokens, u = [], h = 0; h < l.length; h++) u.push(l[h].text);
                        a.push(u.join(""))
                    }
                    a = a.join("\n")
                }
                var c, d, f = o.textAlign, p = o.textVerticalAlign, g = NF(o.font),
                    m = g.style + " " + g.variant + " " + g.weight + " " + g.size + 'px "' + g.family + '"';
                i = i || Xi(a, m, f, p, o.textPadding, o.textLineHeight);
                var v = this.transform;
                if (v && !n && (RF.copy(e), RF.applyTransform(v), e = RF), n) c = e.x, d = e.y; else {
                    var y = o.textPosition;
                    if (y instanceof Array) c = e.x + _F(y[0], e.width), d = e.y + _F(y[1], e.height), f = f || "left"; else {
                        var x = this.calculateTextPosition ? this.calculateTextPosition({}, o, e) : $i({}, o, e);
                        c = x.x, d = x.y, f = f || x.textAlign, p = p || x.textVerticalAlign
                    }
                }
                c = qi(c, i.width, f), d = Ki(d, i.height, p), d += i.height / 2;
                var _, w, b, S = eS, M = this._textVmlEl;
                M ? (b = M.firstChild, _ = b.nextSibling, w = _.nextSibling) : (M = S("line"), _ = S("path"), w = S("textpath"), b = S("skew"), w.style["v-text-align"] = "left", pF(M), _.textpathok = !0, w.on = !0, M.from = "0 0", M.to = "1000 0.05", vF(M, b), vF(M, _), vF(M, w), this._textVmlEl = M);
                var I = [c, d], T = M.style;
                v && n ? (ae(I, I, v), b.on = !0, b.matrix = v[0].toFixed(3) + lF + v[2].toFixed(3) + lF + v[1].toFixed(3) + lF + v[3].toFixed(3) + ",0,0", b.offset = (iF(I[0]) || 0) + "," + (iF(I[1]) || 0), b.origin = "0 0", T.left = "0px", T.top = "0px") : (b.on = !1, T.left = iF(c) + "px", T.top = iF(d) + "px"), w.string = gF(a);
                try {
                    w.style.font = m
                } catch (A) {
                }
                IF(M, "fill", {fill: o.textFill, opacity: o.opacity}, this), IF(M, "stroke", {
                    stroke: o.textStroke,
                    opacity: o.opacity,
                    lineDash: o.lineDash || null
                }, this), M.style.zIndex = xF(this.zlevel, this.z, this.z2), vF(t, M)
            }
        }, BF = function (t) {
            yF(t, this._textVmlEl), this._textVmlEl = null
        }, VF = function (t) {
            vF(t, this._textVmlEl)
        }, GF = [PI, Dn, Cn, aa, vA], FF = 0; FF < GF.length; FF++) {
            var WF = GF[FF].prototype;
            WF.drawRectText = zF, WF.removeRectText = BF, WF.appendRectText = VF
        }
        vA.prototype.brushVML = function (t) {
            var e = this.style;
            null != e.text ? this.drawRectText(t, {
                x: e.x || 0,
                y: e.y || 0,
                width: 0,
                height: 0
            }, this.getBoundingRect(), !0) : this.removeRectText(t)
        }, vA.prototype.onRemove = function (t) {
            this.removeRectText(t)
        }, vA.prototype.onAdd = function (t) {
            this.appendRectText(t)
        }
    }
    oS.prototype = {
        constructor: oS, getType: function () {
            return "vml"
        }, getViewportRoot: function () {
            return this._vmlViewport
        }, getViewportRootOffset: function () {
            var t = this.getViewportRoot();
            return t ? {offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0} : void 0
        }, refresh: function () {
            var t = this.storage.getDisplayList(!0, !0);
            this._paintList(t)
        }, _paintList: function (t) {
            for (var e = this._vmlRoot, i = 0; i < t.length; i++) {
                var n = t[i];
                n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1
            }
            this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
        }, resize: function (t, e) {
            var t = null == t ? this._getWidth() : t, e = null == e ? this._getHeight() : e;
            if (this._width !== t || this._height !== e) {
                this._width = t, this._height = e;
                var i = this._vmlViewport.style;
                i.width = t + "px", i.height = e + "px"
            }
        }, dispose: function () {
            this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null
        }, getWidth: function () {
            return this._width
        }, getHeight: function () {
            return this._height
        }, clear: function () {
            this._vmlViewport && this.root.removeChild(this._vmlViewport)
        }, _getWidth: function () {
            var t = this.root, e = t.currentStyle;
            return (t.clientWidth || nS(e.width)) - nS(e.paddingLeft) - nS(e.paddingRight) | 0
        }, _getHeight: function () {
            var t = this.root, e = t.currentStyle;
            return (t.clientHeight || nS(e.height)) - nS(e.paddingTop) - nS(e.paddingBottom) | 0
        }
    }, f(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function (t) {
        oS.prototype[t] = aS(t)
    }), Qn("vml", oS);
    var HF = "http://www.w3.org/2000/svg", ZF = XT.CMD, UF = Array.prototype.join, XF = "none", YF = Math.round,
        jF = Math.sin, qF = Math.cos, KF = Math.PI, $F = 2 * Math.PI, JF = 180 / KF, QF = 1e-4, tW = {};
    tW.brush = function (t) {
        var e = t.style, i = t.__svgEl;
        i || (i = rS("path"), t.__svgEl = i), t.path || t.createPathProxy();
        var n = t.path;
        if (t.__dirtyPath) {
            n.beginPath(), n.subPixelOptimize = !1, t.buildPath(n, t.shape), t.__dirtyPath = !1;
            var o = gS(n);
            o.indexOf("NaN") < 0 && dS(i, "d", o)
        }
        pS(i, e, !1, t), cS(i, t.transform), null != e.text ? sW(t, t.getBoundingRect()) : xS(t)
    };
    var eW = {};
    eW.brush = function (t) {
        var e = t.style, i = e.image;
        if (i instanceof HTMLImageElement) {
            var n = i.src;
            i = n
        }
        if (i) {
            var o = e.x || 0, a = e.y || 0, r = e.width, s = e.height, l = t.__svgEl;
            l || (l = rS("image"), t.__svgEl = l), i !== t.__imageSrc && (fS(l, "href", i), t.__imageSrc = i), dS(l, "width", r), dS(l, "height", s), dS(l, "x", o), dS(l, "y", a), cS(l, t.transform), null != e.text ? sW(t, t.getBoundingRect()) : xS(t)
        }
    };
    var iW = {}, nW = new Ti, oW = {}, aW = [], rW = {left: "start", right: "end", center: "middle", middle: "middle"},
        sW = function (t, e) {
            var i = t.style, n = t.transform, o = t instanceof vA || i.transformText;
            t.__dirty && hn(i, !0);
            var a = i.text;
            if (null != a && (a += ""), An(a, i)) {
                null == a && (a = ""), !o && n && (nW.copy(e), nW.applyTransform(n), e = nW);
                var r = t.__textSvgEl;
                r || (r = rS("text"), t.__textSvgEl = r);
                var s = r.style, l = i.font || SI, u = r.__computedFont;
                l !== r.__styleFont && (s.font = r.__styleFont = l, u = r.__computedFont = s.font);
                var h = i.textPadding, c = i.textLineHeight, d = t.__textCotentBlock;
                (!d || t.__dirtyText) && (d = t.__textCotentBlock = an(a, u, h, c, i.truncate));
                var f = d.outerHeight, p = d.lineHeight;
                wn(oW, t, i, e);
                var g = oW.baseX, m = oW.baseY, v = oW.textAlign || "left", y = oW.textVerticalAlign;
                mS(r, o, n, i, e, g, m);
                var x = Ki(m, f, y), _ = g, w = x;
                h && (_ = vS(g, v, h), w += h[0]), w += p / 2, pS(r, i, !0, t);
                var b = d.canCacheByTextString, S = t.__tspanList || (t.__tspanList = []), M = S.length;
                if (b && t.__canCacheByTextString && t.__text === a) {
                    if (t.__dirtyText && M) for (var I = 0; M > I; ++I) yS(S[I], v, _, w + I * p)
                } else {
                    t.__text = a, t.__canCacheByTextString = b;
                    for (var T = d.lines, A = T.length, I = 0; A > I; I++) {
                        var D = S[I], C = T[I];
                        D ? D.__zrText !== C && (D.innerHTML = "", D.appendChild(document.createTextNode(C))) : (D = S[I] = rS("tspan"), r.appendChild(D), D.appendChild(document.createTextNode(C))), yS(D, v, _, w + I * p)
                    }
                    if (M > A) {
                        for (; M > I; I++) r.removeChild(S[I]);
                        S.length = A
                    }
                }
            }
        };
    iW.drawRectText = sW, iW.brush = function (t) {
        var e = t.style;
        null != e.text ? sW(t, !1) : xS(t)
    }, _S.prototype = {
        diff: function (t, e, i) {
            function n() {
                for (var i = -1 * s; s >= i; i += 2) {
                    var n, l = u[i - 1], h = u[i + 1], c = (h ? h.newPos : 0) - i;
                    l && (u[i - 1] = void 0);
                    var d = l && l.newPos + 1 < a, f = h && c >= 0 && r > c;
                    if (d || f) {
                        if (!d || f && l.newPos < h.newPos ? (n = bS(h), o.pushComponent(n.components, void 0, !0)) : (n = l, n.newPos++, o.pushComponent(n.components, !0, void 0)), c = o.extractCommon(n, e, t, i), n.newPos + 1 >= a && c + 1 >= r) return wS(o, n.components, e, t);
                        u[i] = n
                    } else u[i] = void 0
                }
                s++
            }

            i || (i = function (t, e) {
                return t === e
            }), this.equals = i;
            var o = this;
            t = t.slice(), e = e.slice();
            var a = e.length, r = t.length, s = 1, l = a + r, u = [{newPos: -1, components: []}],
                h = this.extractCommon(u[0], e, t, 0);
            if (u[0].newPos + 1 >= a && h + 1 >= r) {
                for (var c = [], d = 0; d < e.length; d++) c.push(d);
                return [{indices: c, count: e.length}]
            }
            for (; l >= s;) {
                var f = n();
                if (f) return f
            }
        }, pushComponent: function (t, e, i) {
            var n = t[t.length - 1];
            n && n.added === e && n.removed === i ? t[t.length - 1] = {
                count: n.count + 1,
                added: e,
                removed: i
            } : t.push({count: 1, added: e, removed: i})
        }, extractCommon: function (t, e, i, n) {
            for (var o = e.length, a = i.length, r = t.newPos, s = r - n, l = 0; o > r + 1 && a > s + 1 && this.equals(e[r + 1], i[s + 1]);) r++, s++, l++;
            return l && t.components.push({count: l}), t.newPos = r, s
        }, tokenize: function (t) {
            return t.slice()
        }, join: function (t) {
            return t.slice()
        }
    };
    var lW = new _S, uW = function (t, e, i) {
        return lW.diff(t, e, i)
    }, hW = "0", cW = "1";
    SS.prototype.createElement = rS, SS.prototype.getDefs = function (t) {
        var e = this._svgRoot, i = this._svgRoot.getElementsByTagName("defs");
        return 0 === i.length ? t ? (i = e.insertBefore(this.createElement("defs"), e.firstChild), i.contains || (i.contains = function (t) {
            var e = i.children;
            if (!e) return !1;
            for (var n = e.length - 1; n >= 0; --n) if (e[n] === t) return !0;
            return !1
        }), i) : null : i[0]
    }, SS.prototype.update = function (t, e) {
        if (t) {
            var i = this.getDefs(!1);
            if (t[this._domName] && i.contains(t[this._domName])) "function" == typeof e && e(t); else {
                var n = this.add(t);
                n && (t[this._domName] = n)
            }
        }
    }, SS.prototype.addDom = function (t) {
        var e = this.getDefs(!0);
        e.appendChild(t)
    }, SS.prototype.removeDom = function (t) {
        var e = this.getDefs(!1);
        e && t[this._domName] && (e.removeChild(t[this._domName]), t[this._domName] = null)
    }, SS.prototype.getDoms = function () {
        var t = this.getDefs(!1);
        if (!t) return [];
        var e = [];
        return f(this._tagNames, function (i) {
            var n = t.getElementsByTagName(i);
            e = e.concat([].slice.call(n))
        }), e
    }, SS.prototype.markAllUnused = function () {
        var t = this.getDoms(), e = this;
        f(t, function (t) {
            t[e._markLabel] = hW
        })
    }, SS.prototype.markUsed = function (t) {
        t && (t[this._markLabel] = cW)
    }, SS.prototype.removeUnused = function () {
        var t = this.getDefs(!1);
        if (t) {
            var e = this.getDoms(), i = this;
            f(e, function (e) {
                e[i._markLabel] !== cW && t.removeChild(e)
            })
        }
    }, SS.prototype.getSvgProxy = function (t) {
        return t instanceof aa ? tW : t instanceof Cn ? eW : t instanceof vA ? iW : tW
    }, SS.prototype.getTextSvgElement = function (t) {
        return t.__textSvgEl
    }, SS.prototype.getSvgElement = function (t) {
        return t.__svgEl
    }, h(MS, SS), MS.prototype.addWithoutUpdate = function (t, e) {
        if (e && e.style) {
            var i = this;
            f(["fill", "stroke"], function (n) {
                if (e.style[n] && ("linear" === e.style[n].type || "radial" === e.style[n].type)) {
                    var o, a = e.style[n], r = i.getDefs(!0);
                    a._dom ? (o = a._dom, r.contains(a._dom) || i.addDom(o)) : o = i.add(a), i.markUsed(e);
                    var s = o.getAttribute("id");
                    t.setAttribute(n, "url(#" + s + ")")
                }
            })
        }
    }, MS.prototype.add = function (t) {
        var e;
        if ("linear" === t.type) e = this.createElement("linearGradient"); else {
            if ("radial" !== t.type) return KM("Illegal gradient type."), null;
            e = this.createElement("radialGradient")
        }
        return t.id = t.id || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-gradient-" + t.id), this.updateDom(t, e), this.addDom(e), e
    }, MS.prototype.update = function (t) {
        var e = this;
        SS.prototype.update.call(this, t, function () {
            var i = t.type, n = t._dom.tagName;
            "linear" === i && "linearGradient" === n || "radial" === i && "radialGradient" === n ? e.updateDom(t, t._dom) : (e.removeDom(t), e.add(t))
        })
    }, MS.prototype.updateDom = function (t, e) {
        if ("linear" === t.type) e.setAttribute("x1", t.x), e.setAttribute("y1", t.y), e.setAttribute("x2", t.x2), e.setAttribute("y2", t.y2); else {
            if ("radial" !== t.type) return void KM("Illegal gradient type.");
            e.setAttribute("cx", t.x), e.setAttribute("cy", t.y), e.setAttribute("r", t.r)
        }
        t.global ? e.setAttribute("gradientUnits", "userSpaceOnUse") : e.setAttribute("gradientUnits", "objectBoundingBox"), e.innerHTML = "";
        for (var i = t.colorStops, n = 0, o = i.length; o > n; ++n) {
            var a = this.createElement("stop");
            a.setAttribute("offset", 100 * i[n].offset + "%");
            var r = i[n].color;
            if (r.indexOf("rgba") > -1) {
                var s = ti(r)[3], l = oi(r);
                a.setAttribute("stop-color", "#" + l), a.setAttribute("stop-opacity", s)
            } else a.setAttribute("stop-color", i[n].color);
            e.appendChild(a)
        }
        t._dom = e
    }, MS.prototype.markUsed = function (t) {
        if (t.style) {
            var e = t.style.fill;
            e && e._dom && SS.prototype.markUsed.call(this, e._dom), e = t.style.stroke, e && e._dom && SS.prototype.markUsed.call(this, e._dom)
        }
    }, h(IS, SS), IS.prototype.update = function (t) {
        var e = this.getSvgElement(t);
        e && this.updateDom(e, t.__clipPaths, !1);
        var i = this.getTextSvgElement(t);
        i && this.updateDom(i, t.__clipPaths, !0), this.markUsed(t)
    }, IS.prototype.updateDom = function (t, e, i) {
        if (e && e.length > 0) {
            var n, o, a = this.getDefs(!0), r = e[0], s = i ? "_textDom" : "_dom";
            r[s] ? (o = r[s].getAttribute("id"), n = r[s], a.contains(n) || a.appendChild(n)) : (o = "zr" + this._zrId + "-clip-" + this.nextId, ++this.nextId, n = this.createElement("clipPath"), n.setAttribute("id", o), a.appendChild(n), r[s] = n);
            var l = this.getSvgProxy(r);
            if (r.transform && r.parent.invTransform && !i) {
                var u = Array.prototype.slice.call(r.transform);
                Re(r.transform, r.parent.invTransform, r.transform), l.brush(r), r.transform = u
            } else l.brush(r);
            var h = this.getSvgElement(r);
            n.innerHTML = "", n.appendChild(h.cloneNode()), t.setAttribute("clip-path", "url(#" + o + ")"), e.length > 1 && this.updateDom(n, e.slice(1), i)
        } else t && t.setAttribute("clip-path", "none")
    }, IS.prototype.markUsed = function (t) {
        var e = this;
        t.__clipPaths && f(t.__clipPaths, function (t) {
            t._dom && SS.prototype.markUsed.call(e, t._dom), t._textDom && SS.prototype.markUsed.call(e, t._textDom)
        })
    }, h(TS, SS), TS.prototype.addWithoutUpdate = function (t, e) {
        if (e && AS(e.style)) {
            var i;
            if (e._shadowDom) {
                i = e._shadowDom;
                var n = this.getDefs(!0);
                n.contains(e._shadowDom) || this.addDom(i)
            } else i = this.add(e);
            this.markUsed(e);
            var o = i.getAttribute("id");
            t.style.filter = "url(#" + o + ")"
        }
    }, TS.prototype.add = function (t) {
        var e = this.createElement("filter");
        return t._shadowDomId = t._shadowDomId || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-shadow-" + t._shadowDomId), this.updateDom(t, e), this.addDom(e), e
    }, TS.prototype.update = function (t, e) {
        var i = e.style;
        if (AS(i)) {
            var n = this;
            SS.prototype.update.call(this, e, function () {
                n.updateDom(e, e._shadowDom)
            })
        } else this.remove(t, e)
    }, TS.prototype.remove = function (t, e) {
        null != e._shadowDomId && (this.removeDom(t), t.style.filter = "")
    }, TS.prototype.updateDom = function (t, e) {
        var i = e.getElementsByTagName("feDropShadow");
        i = 0 === i.length ? this.createElement("feDropShadow") : i[0];
        var n, o, a, r, s = t.style, l = t.scale ? t.scale[0] || 1 : 1, u = t.scale ? t.scale[1] || 1 : 1;
        if (s.shadowBlur || s.shadowOffsetX || s.shadowOffsetY) n = s.shadowOffsetX || 0, o = s.shadowOffsetY || 0, a = s.shadowBlur, r = s.shadowColor; else {
            if (!s.textShadowBlur) return void this.removeDom(e, s);
            n = s.textShadowOffsetX || 0, o = s.textShadowOffsetY || 0, a = s.textShadowBlur, r = s.textShadowColor
        }
        i.setAttribute("dx", n / l), i.setAttribute("dy", o / u), i.setAttribute("flood-color", r);
        var h = a / 2 / l, c = a / 2 / u, d = h + " " + c;
        i.setAttribute("stdDeviation", d), e.setAttribute("x", "-100%"), e.setAttribute("y", "-100%"), e.setAttribute("width", Math.ceil(a / 2 * 200) + "%"), e.setAttribute("height", Math.ceil(a / 2 * 200) + "%"), e.appendChild(i), t._shadowDom = e
    }, TS.prototype.markUsed = function (t) {
        t._shadowDom && SS.prototype.markUsed.call(this, t._shadowDom)
    };
    var dW = function (t, e, i, n) {
        this.root = t, this.storage = e, this._opts = i = r({}, i || {});
        var o = rS("svg");
        o.setAttribute("xmlns", "http://www.w3.org/2000/svg"), o.setAttribute("version", "1.1"), o.setAttribute("baseProfile", "full"), o.style.cssText = "user-select:none;position:absolute;left:0;top:0;";
        var a = rS("g");
        o.appendChild(a);
        var s = rS("g");
        o.appendChild(s), this.gradientManager = new MS(n, s), this.clipPathManager = new IS(n, s), this.shadowManager = new TS(n, s);
        var l = document.createElement("div");
        l.style.cssText = "overflow:hidden;position:relative", this._svgDom = o, this._svgRoot = s, this._backgroundRoot = a, this._viewport = l, t.appendChild(l), l.appendChild(o), this.resize(i.width, i.height), this._visibleList = []
    };
    dW.prototype = {
        constructor: dW, getType: function () {
            return "svg"
        }, getViewportRoot: function () {
            return this._viewport
        }, getSvgDom: function () {
            return this._svgDom
        }, getSvgRoot: function () {
            return this._svgRoot
        }, getViewportRootOffset: function () {
            var t = this.getViewportRoot();
            return t ? {offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0} : void 0
        }, refresh: function () {
            var t = this.storage.getDisplayList(!0);
            this._paintList(t)
        }, setBackgroundColor: function (t) {
            this._backgroundRoot && this._backgroundNode && this._backgroundRoot.removeChild(this._backgroundNode);
            var e = rS("rect");
            e.setAttribute("width", this.getWidth()), e.setAttribute("height", this.getHeight()), e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("id", 0), e.style.fill = t, this._backgroundRoot.appendChild(e), this._backgroundNode = e
        }, _paintList: function (t) {
            this.gradientManager.markAllUnused(), this.clipPathManager.markAllUnused(), this.shadowManager.markAllUnused();
            var e, i = this._svgRoot, n = this._visibleList, o = t.length, a = [];
            for (e = 0; o > e; e++) {
                var r = t[e], s = CS(r), l = NS(r) || ES(r);
                r.invisible || (r.__dirty && (s && s.brush(r), this.clipPathManager.update(r), r.style && (this.gradientManager.update(r.style.fill), this.gradientManager.update(r.style.stroke), this.shadowManager.update(l, r)), r.__dirty = !1), a.push(r))
            }
            var u, h = uW(n, a);
            for (e = 0; e < h.length; e++) {
                var c = h[e];
                if (c.removed) for (var d = 0; d < c.count; d++) {
                    var r = n[c.indices[d]], l = NS(r), f = ES(r);
                    OS(i, l), OS(i, f)
                }
            }
            for (e = 0; e < h.length; e++) {
                var c = h[e];
                if (c.added) for (var d = 0; d < c.count; d++) {
                    var r = a[c.indices[d]], l = NS(r), f = ES(r);
                    u ? kS(i, l, u) : PS(i, l), l ? kS(i, f, l) : u ? kS(i, f, u) : PS(i, f), kS(i, f, l), u = f || l || u, this.gradientManager.addWithoutUpdate(l || f, r), this.shadowManager.addWithoutUpdate(l || f, r), this.clipPathManager.markUsed(r)
                } else if (!c.removed) for (var d = 0; d < c.count; d++) {
                    var r = a[c.indices[d]], l = NS(r), f = ES(r), l = NS(r), f = ES(r);
                    this.gradientManager.markUsed(r), this.gradientManager.addWithoutUpdate(l || f, r), this.shadowManager.markUsed(r), this.shadowManager.addWithoutUpdate(l || f, r), this.clipPathManager.markUsed(r), f && kS(i, f, l), u = l || f || u
                }
            }
            this.gradientManager.removeUnused(), this.clipPathManager.removeUnused(), this.shadowManager.removeUnused(), this._visibleList = a
        }, _getDefs: function (t) {
            var e = this._svgDom, i = e.getElementsByTagName("defs");
            if (0 === i.length) {
                if (t) {
                    var i = e.insertBefore(rS("defs"), e.firstChild);
                    return i.contains || (i.contains = function (t) {
                        var e = i.children;
                        if (!e) return !1;
                        for (var n = e.length - 1; n >= 0; --n) if (e[n] === t) return !0;
                        return !1
                    }), i
                }
                return null
            }
            return i[0]
        }, resize: function (t, e) {
            var i = this._viewport;
            i.style.display = "none";
            var n = this._opts;
            if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width !== t || this._height !== e) {
                this._width = t, this._height = e;
                var o = i.style;
                o.width = t + "px", o.height = e + "px";
                var a = this._svgDom;
                a.setAttribute("width", t), a.setAttribute("height", e)
            }
            this._backgroundNode && (this._backgroundNode.setAttribute("width", t), this._backgroundNode.setAttribute("height", e))
        }, getWidth: function () {
            return this._width
        }, getHeight: function () {
            return this._height
        }, _getSize: function (t) {
            var e = this._opts, i = ["width", "height"][t], n = ["clientWidth", "clientHeight"][t],
                o = ["paddingLeft", "paddingTop"][t], a = ["paddingRight", "paddingBottom"][t];
            if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);
            var r = this.root, s = document.defaultView.getComputedStyle(r);
            return (r[n] || DS(s[i]) || DS(r.style[i])) - (DS(s[o]) || 0) - (DS(s[a]) || 0) | 0
        }, dispose: function () {
            this.root.innerHTML = "", this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null
        }, clear: function () {
            this._viewport && this.root.removeChild(this._viewport)
        }, toDataURL: function () {
            this.refresh();
            var t = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, ">\n\r<"));
            return "data:image/svg+xml;charset=UTF-8," + t
        }
    }, f(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "pathToImage"], function (t) {
        dW.prototype[t] = RS(t)
    }), Qn("svg", dW), t.version = iL, t.dependencies = nL, t.PRIORITY = mL, t.init = bu, t.connect = Su, t.disConnect = Mu, t.disconnect = RL, t.dispose = Iu, t.getInstanceByDom = Tu, t.getInstanceById = Au, t.registerTheme = Du, t.registerPreprocessor = Cu, t.registerProcessor = Lu, t.registerPostUpdate = ku, t.registerAction = Pu, t.registerCoordinateSystem = Ou, t.getCoordinateSystemDimensions = Eu, t.registerLayout = Nu, t.registerVisual = Ru, t.registerLoading = Bu, t.extendComponentModel = Vu, t.extendComponentView = Gu, t.extendSeriesModel = Fu, t.extendChartView = Wu, t.setCanvasCreator = Hu, t.registerMap = Zu, t.getMap = Uu, t.dataTool = zL, t.zrender = tT, t.number = cD, t.format = yD, t.throttle = Sl, t.helper = Vk, t.matrix = MM, t.vector = lM, t.color = HM, t.parseGeoJSON = Fk, t.parseGeoJson = Uk, t.util = Xk, t.graphic = Yk, t.List = qL, t.Model = vr, t.Axis = Zk, t.env = WS
});